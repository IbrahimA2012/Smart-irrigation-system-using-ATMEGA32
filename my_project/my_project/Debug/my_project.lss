
my_project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005e86  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000034  00800060  00005e86  00005f1a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000309  00800094  00800094  00005f4e  2**0
                  ALLOC
  3 .stab         00007a10  00000000  00000000  00005f50  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000041c8  00000000  00000000  0000d960  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00011b28  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00011c68  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00011dd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00013a21  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0001490c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000156bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0001581c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00015aa9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00016277  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 2a 09 	jmp	0x1254	; 0x1254 <__vector_1>
       8:	0c 94 5d 09 	jmp	0x12ba	; 0x12ba <__vector_2>
       c:	0c 94 90 09 	jmp	0x1320	; 0x1320 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 3a 07 	jmp	0xe74	; 0xe74 <__vector_6>
      1c:	0c 94 03 20 	jmp	0x4006	; 0x4006 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 88 08 	jmp	0x1110	; 0x1110 <__vector_10>
      2c:	0c 94 f0 07 	jmp	0xfe0	; 0xfe0 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e8       	ldi	r30, 0x86	; 134
      68:	fe e5       	ldi	r31, 0x5E	; 94
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 39       	cpi	r26, 0x94	; 148
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a4 e9       	ldi	r26, 0x94	; 148
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ad 39       	cpi	r26, 0x9D	; 157
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 72 2b 	call	0x56e4	; 0x56e4 <main>
      8a:	0c 94 41 2f 	jmp	0x5e82	; 0x5e82 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 4a 2c 	jmp	0x5894	; 0x5894 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a8 e6       	ldi	r26, 0x68	; 104
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 66 2c 	jmp	0x58cc	; 0x58cc <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 56 2c 	jmp	0x58ac	; 0x58ac <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 72 2c 	jmp	0x58e4	; 0x58e4 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 56 2c 	jmp	0x58ac	; 0x58ac <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 72 2c 	jmp	0x58e4	; 0x58e4 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 4a 2c 	jmp	0x5894	; 0x5894 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	88 e6       	ldi	r24, 0x68	; 104
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 66 2c 	jmp	0x58cc	; 0x58cc <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 56 2c 	jmp	0x58ac	; 0x58ac <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 72 2c 	jmp	0x58e4	; 0x58e4 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 56 2c 	jmp	0x58ac	; 0x58ac <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 72 2c 	jmp	0x58e4	; 0x58e4 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 56 2c 	jmp	0x58ac	; 0x58ac <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 72 2c 	jmp	0x58e4	; 0x58e4 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 5a 2c 	jmp	0x58b4	; 0x58b4 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 76 2c 	jmp	0x58ec	; 0x58ec <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <UART_VidInit>:
#include "UART.h"
#include "../../LIB/BIT_MATH.h"
#include "../../LIB/STD_TYPES.h"

void UART_VidInit(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <UART_VidInit+0x6>
     b4c:	0f 92       	push	r0
     b4e:	cd b7       	in	r28, 0x3d	; 61
     b50:	de b7       	in	r29, 0x3e	; 62
	uint16 Local_u16Bud_Rate = 51;
     b52:	83 e3       	ldi	r24, 0x33	; 51
     b54:	90 e0       	ldi	r25, 0x00	; 0
     b56:	9b 83       	std	Y+3, r25	; 0x03
     b58:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8UCSRC = 0b10000000;
     b5a:	80 e8       	ldi	r24, 0x80	; 128
     b5c:	89 83       	std	Y+1, r24	; 0x01

	UBRRL =(u8)Local_u16Bud_Rate;
     b5e:	e9 e2       	ldi	r30, 0x29	; 41
     b60:	f0 e0       	ldi	r31, 0x00	; 0
     b62:	8a 81       	ldd	r24, Y+2	; 0x02
     b64:	80 83       	st	Z, r24
	UBRRH =(u8)(Local_u16Bud_Rate>>8);
     b66:	e0 e4       	ldi	r30, 0x40	; 64
     b68:	f0 e0       	ldi	r31, 0x00	; 0
     b6a:	8a 81       	ldd	r24, Y+2	; 0x02
     b6c:	9b 81       	ldd	r25, Y+3	; 0x03
     b6e:	89 2f       	mov	r24, r25
     b70:	99 27       	eor	r25, r25
     b72:	80 83       	st	Z, r24
	/*Normal speed*/
	CLEAR_BIT(UCSRA,U2X);
     b74:	ab e2       	ldi	r26, 0x2B	; 43
     b76:	b0 e0       	ldi	r27, 0x00	; 0
     b78:	eb e2       	ldi	r30, 0x2B	; 43
     b7a:	f0 e0       	ldi	r31, 0x00	; 0
     b7c:	80 81       	ld	r24, Z
     b7e:	8d 7f       	andi	r24, 0xFD	; 253
     b80:	8c 93       	st	X, r24
	/*Disable multi-processor*/
	CLEAR_BIT(UCSRA,MPCM);
     b82:	ab e2       	ldi	r26, 0x2B	; 43
     b84:	b0 e0       	ldi	r27, 0x00	; 0
     b86:	eb e2       	ldi	r30, 0x2B	; 43
     b88:	f0 e0       	ldi	r31, 0x00	; 0
     b8a:	80 81       	ld	r24, Z
     b8c:	8e 7f       	andi	r24, 0xFE	; 254
     b8e:	8c 93       	st	X, r24
	/*Enable Tx , Rx*/
	SET_BIT(UCSRB,RXEN);
     b90:	aa e2       	ldi	r26, 0x2A	; 42
     b92:	b0 e0       	ldi	r27, 0x00	; 0
     b94:	ea e2       	ldi	r30, 0x2A	; 42
     b96:	f0 e0       	ldi	r31, 0x00	; 0
     b98:	80 81       	ld	r24, Z
     b9a:	80 61       	ori	r24, 0x10	; 16
     b9c:	8c 93       	st	X, r24
	SET_BIT(UCSRB,TXEN);
     b9e:	aa e2       	ldi	r26, 0x2A	; 42
     ba0:	b0 e0       	ldi	r27, 0x00	; 0
     ba2:	ea e2       	ldi	r30, 0x2A	; 42
     ba4:	f0 e0       	ldi	r31, 0x00	; 0
     ba6:	80 81       	ld	r24, Z
     ba8:	88 60       	ori	r24, 0x08	; 8
     baa:	8c 93       	st	X, r24
	/*8 Bits Data*/
	SET_BIT(Local_u8UCSRC,UCSZ1);
     bac:	89 81       	ldd	r24, Y+1	; 0x01
     bae:	84 60       	ori	r24, 0x04	; 4
     bb0:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(Local_u8UCSRC,UCSZ0);
     bb2:	89 81       	ldd	r24, Y+1	; 0x01
     bb4:	82 60       	ori	r24, 0x02	; 2
     bb6:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(UCSRB,UCSZ2);
     bb8:	aa e2       	ldi	r26, 0x2A	; 42
     bba:	b0 e0       	ldi	r27, 0x00	; 0
     bbc:	ea e2       	ldi	r30, 0x2A	; 42
     bbe:	f0 e0       	ldi	r31, 0x00	; 0
     bc0:	80 81       	ld	r24, Z
     bc2:	8b 7f       	andi	r24, 0xFB	; 251
     bc4:	8c 93       	st	X, r24

	/*Asynchronous mode*/
	CLEAR_BIT(Local_u8UCSRC,UMSEL);
     bc6:	89 81       	ldd	r24, Y+1	; 0x01
     bc8:	8f 7b       	andi	r24, 0xBF	; 191
     bca:	89 83       	std	Y+1, r24	; 0x01
	/*Disable parity*/
	CLEAR_BIT(Local_u8UCSRC,UPM0);
     bcc:	89 81       	ldd	r24, Y+1	; 0x01
     bce:	8f 7e       	andi	r24, 0xEF	; 239
     bd0:	89 83       	std	Y+1, r24	; 0x01
	CLEAR_BIT(Local_u8UCSRC,UPM1);
     bd2:	89 81       	ldd	r24, Y+1	; 0x01
     bd4:	8f 7d       	andi	r24, 0xDF	; 223
     bd6:	89 83       	std	Y+1, r24	; 0x01
	/*2 stop bits*/
	SET_BIT(Local_u8UCSRC,USBS);
     bd8:	89 81       	ldd	r24, Y+1	; 0x01
     bda:	88 60       	ori	r24, 0x08	; 8
     bdc:	89 83       	std	Y+1, r24	; 0x01

	UCSRC =Local_u8UCSRC;
     bde:	e0 e4       	ldi	r30, 0x40	; 64
     be0:	f0 e0       	ldi	r31, 0x00	; 0
     be2:	89 81       	ldd	r24, Y+1	; 0x01
     be4:	80 83       	st	Z, r24
}
     be6:	0f 90       	pop	r0
     be8:	0f 90       	pop	r0
     bea:	0f 90       	pop	r0
     bec:	cf 91       	pop	r28
     bee:	df 91       	pop	r29
     bf0:	08 95       	ret

00000bf2 <UART_VidSendChar>:

void UART_VidSendChar(u8 Copy_u8Data)
{
     bf2:	df 93       	push	r29
     bf4:	cf 93       	push	r28
     bf6:	0f 92       	push	r0
     bf8:	cd b7       	in	r28, 0x3d	; 61
     bfa:	de b7       	in	r29, 0x3e	; 62
     bfc:	89 83       	std	Y+1, r24	; 0x01
	while(READ_BIT(UCSRA,UDRE)==0);
     bfe:	eb e2       	ldi	r30, 0x2B	; 43
     c00:	f0 e0       	ldi	r31, 0x00	; 0
     c02:	80 81       	ld	r24, Z
     c04:	82 95       	swap	r24
     c06:	86 95       	lsr	r24
     c08:	87 70       	andi	r24, 0x07	; 7
     c0a:	88 2f       	mov	r24, r24
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	81 70       	andi	r24, 0x01	; 1
     c10:	90 70       	andi	r25, 0x00	; 0
     c12:	00 97       	sbiw	r24, 0x00	; 0
     c14:	a1 f3       	breq	.-24     	; 0xbfe <UART_VidSendChar+0xc>
	UDR = Copy_u8Data;
     c16:	ec e2       	ldi	r30, 0x2C	; 44
     c18:	f0 e0       	ldi	r31, 0x00	; 0
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	80 83       	st	Z, r24
}
     c1e:	0f 90       	pop	r0
     c20:	cf 91       	pop	r28
     c22:	df 91       	pop	r29
     c24:	08 95       	ret

00000c26 <UART_VidReceiveChar>:

u8 UART_VidReceiveChar(void)
{
     c26:	df 93       	push	r29
     c28:	cf 93       	push	r28
     c2a:	cd b7       	in	r28, 0x3d	; 61
     c2c:	de b7       	in	r29, 0x3e	; 62
	while(READ_BIT(UCSRA,RXC)==0);
     c2e:	eb e2       	ldi	r30, 0x2B	; 43
     c30:	f0 e0       	ldi	r31, 0x00	; 0
     c32:	80 81       	ld	r24, Z
     c34:	88 23       	and	r24, r24
     c36:	dc f7       	brge	.-10     	; 0xc2e <UART_VidReceiveChar+0x8>
	return UDR;
     c38:	ec e2       	ldi	r30, 0x2C	; 44
     c3a:	f0 e0       	ldi	r31, 0x00	; 0
     c3c:	80 81       	ld	r24, Z
}
     c3e:	cf 91       	pop	r28
     c40:	df 91       	pop	r29
     c42:	08 95       	ret

00000c44 <UART_VidSendString>:

void UART_VidSendString(u8 *Copy_u8Data)
{
     c44:	df 93       	push	r29
     c46:	cf 93       	push	r28
     c48:	00 d0       	rcall	.+0      	; 0xc4a <UART_VidSendString+0x6>
     c4a:	cd b7       	in	r28, 0x3d	; 61
     c4c:	de b7       	in	r29, 0x3e	; 62
     c4e:	9a 83       	std	Y+2, r25	; 0x02
     c50:	89 83       	std	Y+1, r24	; 0x01
	while(READ_BIT(UCSRA,UDRE)==0);
     c52:	eb e2       	ldi	r30, 0x2B	; 43
     c54:	f0 e0       	ldi	r31, 0x00	; 0
     c56:	80 81       	ld	r24, Z
     c58:	82 95       	swap	r24
     c5a:	86 95       	lsr	r24
     c5c:	87 70       	andi	r24, 0x07	; 7
     c5e:	88 2f       	mov	r24, r24
     c60:	90 e0       	ldi	r25, 0x00	; 0
     c62:	81 70       	andi	r24, 0x01	; 1
     c64:	90 70       	andi	r25, 0x00	; 0
     c66:	00 97       	sbiw	r24, 0x00	; 0
     c68:	a1 f3       	breq	.-24     	; 0xc52 <UART_VidSendString+0xe>
     c6a:	0b c0       	rjmp	.+22     	; 0xc82 <UART_VidSendString+0x3e>
	while(*Copy_u8Data !='\0')
	{
		UART_VidSendChar(*Copy_u8Data++);
     c6c:	e9 81       	ldd	r30, Y+1	; 0x01
     c6e:	fa 81       	ldd	r31, Y+2	; 0x02
     c70:	20 81       	ld	r18, Z
     c72:	89 81       	ldd	r24, Y+1	; 0x01
     c74:	9a 81       	ldd	r25, Y+2	; 0x02
     c76:	01 96       	adiw	r24, 0x01	; 1
     c78:	9a 83       	std	Y+2, r25	; 0x02
     c7a:	89 83       	std	Y+1, r24	; 0x01
     c7c:	82 2f       	mov	r24, r18
     c7e:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <UART_VidSendChar>
}

void UART_VidSendString(u8 *Copy_u8Data)
{
	while(READ_BIT(UCSRA,UDRE)==0);
	while(*Copy_u8Data !='\0')
     c82:	e9 81       	ldd	r30, Y+1	; 0x01
     c84:	fa 81       	ldd	r31, Y+2	; 0x02
     c86:	80 81       	ld	r24, Z
     c88:	88 23       	and	r24, r24
     c8a:	81 f7       	brne	.-32     	; 0xc6c <UART_VidSendString+0x28>
	{
		UART_VidSendChar(*Copy_u8Data++);
	}
}
     c8c:	0f 90       	pop	r0
     c8e:	0f 90       	pop	r0
     c90:	cf 91       	pop	r28
     c92:	df 91       	pop	r29
     c94:	08 95       	ret

00000c96 <TMR1_Timer1Normal_Vid>:

static void(*TIMER1_PFICU)(void);


void TMR1_Timer1Normal_Vid(void)//timer1 input capture unit
{
     c96:	df 93       	push	r29
     c98:	cf 93       	push	r28
     c9a:	cd b7       	in	r28, 0x3d	; 61
     c9c:	de b7       	in	r29, 0x3e	; 62
	/* fast PWM */
	CLEAR_BIT(TCCR1A, WGM10);
     c9e:	af e4       	ldi	r26, 0x4F	; 79
     ca0:	b0 e0       	ldi	r27, 0x00	; 0
     ca2:	ef e4       	ldi	r30, 0x4F	; 79
     ca4:	f0 e0       	ldi	r31, 0x00	; 0
     ca6:	80 81       	ld	r24, Z
     ca8:	8e 7f       	andi	r24, 0xFE	; 254
     caa:	8c 93       	st	X, r24
	CLEAR_BIT(TCCR1A, WGM11);
     cac:	af e4       	ldi	r26, 0x4F	; 79
     cae:	b0 e0       	ldi	r27, 0x00	; 0
     cb0:	ef e4       	ldi	r30, 0x4F	; 79
     cb2:	f0 e0       	ldi	r31, 0x00	; 0
     cb4:	80 81       	ld	r24, Z
     cb6:	8d 7f       	andi	r24, 0xFD	; 253
     cb8:	8c 93       	st	X, r24
	CLEAR_BIT(TCCR1B, WGM12);
     cba:	ae e4       	ldi	r26, 0x4E	; 78
     cbc:	b0 e0       	ldi	r27, 0x00	; 0
     cbe:	ee e4       	ldi	r30, 0x4E	; 78
     cc0:	f0 e0       	ldi	r31, 0x00	; 0
     cc2:	80 81       	ld	r24, Z
     cc4:	87 7f       	andi	r24, 0xF7	; 247
     cc6:	8c 93       	st	X, r24
	CLEAR_BIT(TCCR1B, WGM13);
     cc8:	ae e4       	ldi	r26, 0x4E	; 78
     cca:	b0 e0       	ldi	r27, 0x00	; 0
     ccc:	ee e4       	ldi	r30, 0x4E	; 78
     cce:	f0 e0       	ldi	r31, 0x00	; 0
     cd0:	80 81       	ld	r24, Z
     cd2:	8f 7e       	andi	r24, 0xEF	; 239
     cd4:	8c 93       	st	X, r24

	/* CLK/8 */
	CLEAR_BIT(TCCR1B, CS10);//preScalar = 8
     cd6:	ae e4       	ldi	r26, 0x4E	; 78
     cd8:	b0 e0       	ldi	r27, 0x00	; 0
     cda:	ee e4       	ldi	r30, 0x4E	; 78
     cdc:	f0 e0       	ldi	r31, 0x00	; 0
     cde:	80 81       	ld	r24, Z
     ce0:	8e 7f       	andi	r24, 0xFE	; 254
     ce2:	8c 93       	st	X, r24
	SET_BIT(TCCR1B, CS11);
     ce4:	ae e4       	ldi	r26, 0x4E	; 78
     ce6:	b0 e0       	ldi	r27, 0x00	; 0
     ce8:	ee e4       	ldi	r30, 0x4E	; 78
     cea:	f0 e0       	ldi	r31, 0x00	; 0
     cec:	80 81       	ld	r24, Z
     cee:	82 60       	ori	r24, 0x02	; 2
     cf0:	8c 93       	st	X, r24
	CLEAR_BIT(TCCR1B, CS12);
     cf2:	ae e4       	ldi	r26, 0x4E	; 78
     cf4:	b0 e0       	ldi	r27, 0x00	; 0
     cf6:	ee e4       	ldi	r30, 0x4E	; 78
     cf8:	f0 e0       	ldi	r31, 0x00	; 0
     cfa:	80 81       	ld	r24, Z
     cfc:	8b 7f       	andi	r24, 0xFB	; 251
     cfe:	8c 93       	st	X, r24
}
     d00:	cf 91       	pop	r28
     d02:	df 91       	pop	r29
     d04:	08 95       	ret

00000d06 <TMR1_Timer1FPWM_Vid>:
void TMR1_Timer1FPWM_Vid(void)//timer1 fast PWM
{
     d06:	df 93       	push	r29
     d08:	cf 93       	push	r28
     d0a:	cd b7       	in	r28, 0x3d	; 61
     d0c:	de b7       	in	r29, 0x3e	; 62
	/* fast PWM */
	CLEAR_BIT(TCCR1A, WGM10);
     d0e:	af e4       	ldi	r26, 0x4F	; 79
     d10:	b0 e0       	ldi	r27, 0x00	; 0
     d12:	ef e4       	ldi	r30, 0x4F	; 79
     d14:	f0 e0       	ldi	r31, 0x00	; 0
     d16:	80 81       	ld	r24, Z
     d18:	8e 7f       	andi	r24, 0xFE	; 254
     d1a:	8c 93       	st	X, r24
	SET_BIT(TCCR1A, WGM11);
     d1c:	af e4       	ldi	r26, 0x4F	; 79
     d1e:	b0 e0       	ldi	r27, 0x00	; 0
     d20:	ef e4       	ldi	r30, 0x4F	; 79
     d22:	f0 e0       	ldi	r31, 0x00	; 0
     d24:	80 81       	ld	r24, Z
     d26:	82 60       	ori	r24, 0x02	; 2
     d28:	8c 93       	st	X, r24
	SET_BIT(TCCR1B, WGM12);
     d2a:	ae e4       	ldi	r26, 0x4E	; 78
     d2c:	b0 e0       	ldi	r27, 0x00	; 0
     d2e:	ee e4       	ldi	r30, 0x4E	; 78
     d30:	f0 e0       	ldi	r31, 0x00	; 0
     d32:	80 81       	ld	r24, Z
     d34:	88 60       	ori	r24, 0x08	; 8
     d36:	8c 93       	st	X, r24
	SET_BIT(TCCR1B, WGM13);
     d38:	ae e4       	ldi	r26, 0x4E	; 78
     d3a:	b0 e0       	ldi	r27, 0x00	; 0
     d3c:	ee e4       	ldi	r30, 0x4E	; 78
     d3e:	f0 e0       	ldi	r31, 0x00	; 0
     d40:	80 81       	ld	r24, Z
     d42:	80 61       	ori	r24, 0x10	; 16
     d44:	8c 93       	st	X, r24

	/* clear OCR1A */
	CLEAR_BIT(TCCR1A, COM1A0);
     d46:	af e4       	ldi	r26, 0x4F	; 79
     d48:	b0 e0       	ldi	r27, 0x00	; 0
     d4a:	ef e4       	ldi	r30, 0x4F	; 79
     d4c:	f0 e0       	ldi	r31, 0x00	; 0
     d4e:	80 81       	ld	r24, Z
     d50:	8f 7b       	andi	r24, 0xBF	; 191
     d52:	8c 93       	st	X, r24
	SET_BIT(TCCR1A, COM1A1);
     d54:	af e4       	ldi	r26, 0x4F	; 79
     d56:	b0 e0       	ldi	r27, 0x00	; 0
     d58:	ef e4       	ldi	r30, 0x4F	; 79
     d5a:	f0 e0       	ldi	r31, 0x00	; 0
     d5c:	80 81       	ld	r24, Z
     d5e:	80 68       	ori	r24, 0x80	; 128
     d60:	8c 93       	st	X, r24

	/*Time OVF*/
	ICR1 = 19999;//time overflow = 20ms --> 20000us
     d62:	e6 e4       	ldi	r30, 0x46	; 70
     d64:	f0 e0       	ldi	r31, 0x00	; 0
     d66:	8f e1       	ldi	r24, 0x1F	; 31
     d68:	9e e4       	ldi	r25, 0x4E	; 78
     d6a:	91 83       	std	Z+1, r25	; 0x01
     d6c:	80 83       	st	Z, r24

	/* CLK/8 */
	CLEAR_BIT(TCCR1B, CS10);//preScalar = 8
     d6e:	ae e4       	ldi	r26, 0x4E	; 78
     d70:	b0 e0       	ldi	r27, 0x00	; 0
     d72:	ee e4       	ldi	r30, 0x4E	; 78
     d74:	f0 e0       	ldi	r31, 0x00	; 0
     d76:	80 81       	ld	r24, Z
     d78:	8e 7f       	andi	r24, 0xFE	; 254
     d7a:	8c 93       	st	X, r24
	SET_BIT(TCCR1B, CS11);
     d7c:	ae e4       	ldi	r26, 0x4E	; 78
     d7e:	b0 e0       	ldi	r27, 0x00	; 0
     d80:	ee e4       	ldi	r30, 0x4E	; 78
     d82:	f0 e0       	ldi	r31, 0x00	; 0
     d84:	80 81       	ld	r24, Z
     d86:	82 60       	ori	r24, 0x02	; 2
     d88:	8c 93       	st	X, r24
	CLEAR_BIT(TCCR1B, CS12);
     d8a:	ae e4       	ldi	r26, 0x4E	; 78
     d8c:	b0 e0       	ldi	r27, 0x00	; 0
     d8e:	ee e4       	ldi	r30, 0x4E	; 78
     d90:	f0 e0       	ldi	r31, 0x00	; 0
     d92:	80 81       	ld	r24, Z
     d94:	8b 7f       	andi	r24, 0xFB	; 251
     d96:	8c 93       	st	X, r24

}
     d98:	cf 91       	pop	r28
     d9a:	df 91       	pop	r29
     d9c:	08 95       	ret

00000d9e <TMR1_ICUInit_Vid>:

void TMR1_ICUInit_Vid(void)
{
     d9e:	df 93       	push	r29
     da0:	cf 93       	push	r28
     da2:	cd b7       	in	r28, 0x3d	; 61
     da4:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(TCCR1B, ICES1);//rising edge
     da6:	ae e4       	ldi	r26, 0x4E	; 78
     da8:	b0 e0       	ldi	r27, 0x00	; 0
     daa:	ee e4       	ldi	r30, 0x4E	; 78
     dac:	f0 e0       	ldi	r31, 0x00	; 0
     dae:	80 81       	ld	r24, Z
     db0:	80 64       	ori	r24, 0x40	; 64
     db2:	8c 93       	st	X, r24
	SET_BIT(TIMSK, TICIE1);//ICU_INTEnable
     db4:	a9 e5       	ldi	r26, 0x59	; 89
     db6:	b0 e0       	ldi	r27, 0x00	; 0
     db8:	e9 e5       	ldi	r30, 0x59	; 89
     dba:	f0 e0       	ldi	r31, 0x00	; 0
     dbc:	80 81       	ld	r24, Z
     dbe:	80 62       	ori	r24, 0x20	; 32
     dc0:	8c 93       	st	X, r24
}
     dc2:	cf 91       	pop	r28
     dc4:	df 91       	pop	r29
     dc6:	08 95       	ret

00000dc8 <ICU_VidEdgeSelect>:

void ICU_VidEdgeSelect(u8 Copy_u8EdgeSelect)
{
     dc8:	df 93       	push	r29
     dca:	cf 93       	push	r28
     dcc:	00 d0       	rcall	.+0      	; 0xdce <ICU_VidEdgeSelect+0x6>
     dce:	0f 92       	push	r0
     dd0:	cd b7       	in	r28, 0x3d	; 61
     dd2:	de b7       	in	r29, 0x3e	; 62
     dd4:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8EdgeSelect)
     dd6:	89 81       	ldd	r24, Y+1	; 0x01
     dd8:	28 2f       	mov	r18, r24
     dda:	30 e0       	ldi	r19, 0x00	; 0
     ddc:	3b 83       	std	Y+3, r19	; 0x03
     dde:	2a 83       	std	Y+2, r18	; 0x02
     de0:	8a 81       	ldd	r24, Y+2	; 0x02
     de2:	9b 81       	ldd	r25, Y+3	; 0x03
     de4:	00 97       	sbiw	r24, 0x00	; 0
     de6:	31 f0       	breq	.+12     	; 0xdf4 <ICU_VidEdgeSelect+0x2c>
     de8:	2a 81       	ldd	r18, Y+2	; 0x02
     dea:	3b 81       	ldd	r19, Y+3	; 0x03
     dec:	21 30       	cpi	r18, 0x01	; 1
     dee:	31 05       	cpc	r19, r1
     df0:	49 f0       	breq	.+18     	; 0xe04 <ICU_VidEdgeSelect+0x3c>
     df2:	0f c0       	rjmp	.+30     	; 0xe12 <ICU_VidEdgeSelect+0x4a>
	{
		case 0 : CLEAR_BIT(TCCR1B, ICES1);break;
     df4:	ae e4       	ldi	r26, 0x4E	; 78
     df6:	b0 e0       	ldi	r27, 0x00	; 0
     df8:	ee e4       	ldi	r30, 0x4E	; 78
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	80 81       	ld	r24, Z
     dfe:	8f 7b       	andi	r24, 0xBF	; 191
     e00:	8c 93       	st	X, r24
     e02:	07 c0       	rjmp	.+14     	; 0xe12 <ICU_VidEdgeSelect+0x4a>
		case 1 : SET_BIT(TCCR1B, ICES1);break;
     e04:	ae e4       	ldi	r26, 0x4E	; 78
     e06:	b0 e0       	ldi	r27, 0x00	; 0
     e08:	ee e4       	ldi	r30, 0x4E	; 78
     e0a:	f0 e0       	ldi	r31, 0x00	; 0
     e0c:	80 81       	ld	r24, Z
     e0e:	80 64       	ori	r24, 0x40	; 64
     e10:	8c 93       	st	X, r24
	}
}
     e12:	0f 90       	pop	r0
     e14:	0f 90       	pop	r0
     e16:	0f 90       	pop	r0
     e18:	cf 91       	pop	r28
     e1a:	df 91       	pop	r29
     e1c:	08 95       	ret

00000e1e <ICU_u16ReadICR>:

uint16 ICU_u16ReadICR(void)
{
     e1e:	df 93       	push	r29
     e20:	cf 93       	push	r28
     e22:	cd b7       	in	r28, 0x3d	; 61
     e24:	de b7       	in	r29, 0x3e	; 62
	return ICR1;
     e26:	e6 e4       	ldi	r30, 0x46	; 70
     e28:	f0 e0       	ldi	r31, 0x00	; 0
     e2a:	80 81       	ld	r24, Z
     e2c:	91 81       	ldd	r25, Z+1	; 0x01
}
     e2e:	cf 91       	pop	r28
     e30:	df 91       	pop	r29
     e32:	08 95       	ret

00000e34 <ICU_VidINT_Disable>:

void ICU_VidINT_Disable(void)
{
     e34:	df 93       	push	r29
     e36:	cf 93       	push	r28
     e38:	cd b7       	in	r28, 0x3d	; 61
     e3a:	de b7       	in	r29, 0x3e	; 62
	CLEAR_BIT(TIMSK, TICIE1);
     e3c:	a9 e5       	ldi	r26, 0x59	; 89
     e3e:	b0 e0       	ldi	r27, 0x00	; 0
     e40:	e9 e5       	ldi	r30, 0x59	; 89
     e42:	f0 e0       	ldi	r31, 0x00	; 0
     e44:	80 81       	ld	r24, Z
     e46:	8f 7d       	andi	r24, 0xDF	; 223
     e48:	8c 93       	st	X, r24
}
     e4a:	cf 91       	pop	r28
     e4c:	df 91       	pop	r29
     e4e:	08 95       	ret

00000e50 <ICU_VID_SetCallBack>:

void ICU_VID_SetCallBack(void(*Copy_PFCallBack)(void))
{
     e50:	df 93       	push	r29
     e52:	cf 93       	push	r28
     e54:	00 d0       	rcall	.+0      	; 0xe56 <ICU_VID_SetCallBack+0x6>
     e56:	cd b7       	in	r28, 0x3d	; 61
     e58:	de b7       	in	r29, 0x3e	; 62
     e5a:	9a 83       	std	Y+2, r25	; 0x02
     e5c:	89 83       	std	Y+1, r24	; 0x01
	TIMER1_PFICU = Copy_PFCallBack;
     e5e:	89 81       	ldd	r24, Y+1	; 0x01
     e60:	9a 81       	ldd	r25, Y+2	; 0x02
     e62:	90 93 95 00 	sts	0x0095, r25
     e66:	80 93 94 00 	sts	0x0094, r24
}
     e6a:	0f 90       	pop	r0
     e6c:	0f 90       	pop	r0
     e6e:	cf 91       	pop	r28
     e70:	df 91       	pop	r29
     e72:	08 95       	ret

00000e74 <__vector_6>:

ISR(TIMER1_CAPT_vect)
{
     e74:	1f 92       	push	r1
     e76:	0f 92       	push	r0
     e78:	0f b6       	in	r0, 0x3f	; 63
     e7a:	0f 92       	push	r0
     e7c:	11 24       	eor	r1, r1
     e7e:	2f 93       	push	r18
     e80:	3f 93       	push	r19
     e82:	4f 93       	push	r20
     e84:	5f 93       	push	r21
     e86:	6f 93       	push	r22
     e88:	7f 93       	push	r23
     e8a:	8f 93       	push	r24
     e8c:	9f 93       	push	r25
     e8e:	af 93       	push	r26
     e90:	bf 93       	push	r27
     e92:	ef 93       	push	r30
     e94:	ff 93       	push	r31
     e96:	df 93       	push	r29
     e98:	cf 93       	push	r28
     e9a:	cd b7       	in	r28, 0x3d	; 61
     e9c:	de b7       	in	r29, 0x3e	; 62
	if(TIMER1_PFICU != NULL)
     e9e:	80 91 94 00 	lds	r24, 0x0094
     ea2:	90 91 95 00 	lds	r25, 0x0095
     ea6:	00 97       	sbiw	r24, 0x00	; 0
     ea8:	29 f0       	breq	.+10     	; 0xeb4 <__vector_6+0x40>
	{
		TIMER1_PFICU();
     eaa:	e0 91 94 00 	lds	r30, 0x0094
     eae:	f0 91 95 00 	lds	r31, 0x0095
     eb2:	09 95       	icall
	}
}
     eb4:	cf 91       	pop	r28
     eb6:	df 91       	pop	r29
     eb8:	ff 91       	pop	r31
     eba:	ef 91       	pop	r30
     ebc:	bf 91       	pop	r27
     ebe:	af 91       	pop	r26
     ec0:	9f 91       	pop	r25
     ec2:	8f 91       	pop	r24
     ec4:	7f 91       	pop	r23
     ec6:	6f 91       	pop	r22
     ec8:	5f 91       	pop	r21
     eca:	4f 91       	pop	r20
     ecc:	3f 91       	pop	r19
     ece:	2f 91       	pop	r18
     ed0:	0f 90       	pop	r0
     ed2:	0f be       	out	0x3f, r0	; 63
     ed4:	0f 90       	pop	r0
     ed6:	1f 90       	pop	r1
     ed8:	18 95       	reti

00000eda <TMR0_Timer0InitOVF_Vid>:
static void (*TIMER0_PF_CTC) (void);

uint16 Global_u16Time_ms = 0;

void TMR0_Timer0InitOVF_Vid(void)
{
     eda:	df 93       	push	r29
     edc:	cf 93       	push	r28
     ede:	cd b7       	in	r28, 0x3d	; 61
     ee0:	de b7       	in	r29, 0x3e	; 62
	/* Normal Mode */
	CLEAR_BIT(TCCR0, WGM00);
     ee2:	a3 e5       	ldi	r26, 0x53	; 83
     ee4:	b0 e0       	ldi	r27, 0x00	; 0
     ee6:	e3 e5       	ldi	r30, 0x53	; 83
     ee8:	f0 e0       	ldi	r31, 0x00	; 0
     eea:	80 81       	ld	r24, Z
     eec:	8f 7b       	andi	r24, 0xBF	; 191
     eee:	8c 93       	st	X, r24
	CLEAR_BIT(TCCR0, WGM01);
     ef0:	a3 e5       	ldi	r26, 0x53	; 83
     ef2:	b0 e0       	ldi	r27, 0x00	; 0
     ef4:	e3 e5       	ldi	r30, 0x53	; 83
     ef6:	f0 e0       	ldi	r31, 0x00	; 0
     ef8:	80 81       	ld	r24, Z
     efa:	87 7f       	andi	r24, 0xF7	; 247
     efc:	8c 93       	st	X, r24

	/* OVF Interrupt */
	SET_BIT(TIMSK, TOIE0);
     efe:	a9 e5       	ldi	r26, 0x59	; 89
     f00:	b0 e0       	ldi	r27, 0x00	; 0
     f02:	e9 e5       	ldi	r30, 0x59	; 89
     f04:	f0 e0       	ldi	r31, 0x00	; 0
     f06:	80 81       	ld	r24, Z
     f08:	81 60       	ori	r24, 0x01	; 1
     f0a:	8c 93       	st	X, r24

	TCNT0 = 192;
     f0c:	e2 e5       	ldi	r30, 0x52	; 82
     f0e:	f0 e0       	ldi	r31, 0x00	; 0
     f10:	80 ec       	ldi	r24, 0xC0	; 192
     f12:	80 83       	st	Z, r24

	/* CLK/8 */
	CLEAR_BIT(TCCR0, CS00);
     f14:	a3 e5       	ldi	r26, 0x53	; 83
     f16:	b0 e0       	ldi	r27, 0x00	; 0
     f18:	e3 e5       	ldi	r30, 0x53	; 83
     f1a:	f0 e0       	ldi	r31, 0x00	; 0
     f1c:	80 81       	ld	r24, Z
     f1e:	8e 7f       	andi	r24, 0xFE	; 254
     f20:	8c 93       	st	X, r24
	SET_BIT(TCCR0, CS01);
     f22:	a3 e5       	ldi	r26, 0x53	; 83
     f24:	b0 e0       	ldi	r27, 0x00	; 0
     f26:	e3 e5       	ldi	r30, 0x53	; 83
     f28:	f0 e0       	ldi	r31, 0x00	; 0
     f2a:	80 81       	ld	r24, Z
     f2c:	82 60       	ori	r24, 0x02	; 2
     f2e:	8c 93       	st	X, r24
	CLEAR_BIT(TCCR0, CS02);
     f30:	a3 e5       	ldi	r26, 0x53	; 83
     f32:	b0 e0       	ldi	r27, 0x00	; 0
     f34:	e3 e5       	ldi	r30, 0x53	; 83
     f36:	f0 e0       	ldi	r31, 0x00	; 0
     f38:	80 81       	ld	r24, Z
     f3a:	8b 7f       	andi	r24, 0xFB	; 251
     f3c:	8c 93       	st	X, r24

}
     f3e:	cf 91       	pop	r28
     f40:	df 91       	pop	r29
     f42:	08 95       	ret

00000f44 <TIMER0_VidTimer0FPWMInit>:

void TIMER0_VidTimer0FPWMInit(void)
{
     f44:	df 93       	push	r29
     f46:	cf 93       	push	r28
     f48:	cd b7       	in	r28, 0x3d	; 61
     f4a:	de b7       	in	r29, 0x3e	; 62
	/*Fast PWM*/
	SET_BIT(TCCR0,WGM00);
     f4c:	a3 e5       	ldi	r26, 0x53	; 83
     f4e:	b0 e0       	ldi	r27, 0x00	; 0
     f50:	e3 e5       	ldi	r30, 0x53	; 83
     f52:	f0 e0       	ldi	r31, 0x00	; 0
     f54:	80 81       	ld	r24, Z
     f56:	80 64       	ori	r24, 0x40	; 64
     f58:	8c 93       	st	X, r24
	SET_BIT(TCCR0,WGM01);
     f5a:	a3 e5       	ldi	r26, 0x53	; 83
     f5c:	b0 e0       	ldi	r27, 0x00	; 0
     f5e:	e3 e5       	ldi	r30, 0x53	; 83
     f60:	f0 e0       	ldi	r31, 0x00	; 0
     f62:	80 81       	ld	r24, Z
     f64:	88 60       	ori	r24, 0x08	; 8
     f66:	8c 93       	st	X, r24

	/*Clear OC0 on compare match . set OC0 ay TOP*/
	CLEAR_BIT(TCCR0,COM00);
     f68:	a3 e5       	ldi	r26, 0x53	; 83
     f6a:	b0 e0       	ldi	r27, 0x00	; 0
     f6c:	e3 e5       	ldi	r30, 0x53	; 83
     f6e:	f0 e0       	ldi	r31, 0x00	; 0
     f70:	80 81       	ld	r24, Z
     f72:	8f 7e       	andi	r24, 0xEF	; 239
     f74:	8c 93       	st	X, r24
	SET_BIT(TCCR0,COM01);
     f76:	a3 e5       	ldi	r26, 0x53	; 83
     f78:	b0 e0       	ldi	r27, 0x00	; 0
     f7a:	e3 e5       	ldi	r30, 0x53	; 83
     f7c:	f0 e0       	ldi	r31, 0x00	; 0
     f7e:	80 81       	ld	r24, Z
     f80:	80 62       	ori	r24, 0x20	; 32
     f82:	8c 93       	st	X, r24

	OCR0 = 99;
     f84:	ec e5       	ldi	r30, 0x5C	; 92
     f86:	f0 e0       	ldi	r31, 0x00	; 0
     f88:	83 e6       	ldi	r24, 0x63	; 99
     f8a:	80 83       	st	Z, r24

	/* CLK/8 */
	CLEAR_BIT(TCCR0, CS00);
     f8c:	a3 e5       	ldi	r26, 0x53	; 83
     f8e:	b0 e0       	ldi	r27, 0x00	; 0
     f90:	e3 e5       	ldi	r30, 0x53	; 83
     f92:	f0 e0       	ldi	r31, 0x00	; 0
     f94:	80 81       	ld	r24, Z
     f96:	8e 7f       	andi	r24, 0xFE	; 254
     f98:	8c 93       	st	X, r24
	SET_BIT(TCCR0, CS01);
     f9a:	a3 e5       	ldi	r26, 0x53	; 83
     f9c:	b0 e0       	ldi	r27, 0x00	; 0
     f9e:	e3 e5       	ldi	r30, 0x53	; 83
     fa0:	f0 e0       	ldi	r31, 0x00	; 0
     fa2:	80 81       	ld	r24, Z
     fa4:	82 60       	ori	r24, 0x02	; 2
     fa6:	8c 93       	st	X, r24
	CLEAR_BIT(TCCR0, CS02);
     fa8:	a3 e5       	ldi	r26, 0x53	; 83
     faa:	b0 e0       	ldi	r27, 0x00	; 0
     fac:	e3 e5       	ldi	r30, 0x53	; 83
     fae:	f0 e0       	ldi	r31, 0x00	; 0
     fb0:	80 81       	ld	r24, Z
     fb2:	8b 7f       	andi	r24, 0xFB	; 251
     fb4:	8c 93       	st	X, r24

}
     fb6:	cf 91       	pop	r28
     fb8:	df 91       	pop	r29
     fba:	08 95       	ret

00000fbc <TMR0_Timer0SetCallBackOVF>:



void TMR0_Timer0SetCallBackOVF(void (*Copy_u8TimerOVF) (void))
{
     fbc:	df 93       	push	r29
     fbe:	cf 93       	push	r28
     fc0:	00 d0       	rcall	.+0      	; 0xfc2 <TMR0_Timer0SetCallBackOVF+0x6>
     fc2:	cd b7       	in	r28, 0x3d	; 61
     fc4:	de b7       	in	r29, 0x3e	; 62
     fc6:	9a 83       	std	Y+2, r25	; 0x02
     fc8:	89 83       	std	Y+1, r24	; 0x01
	TIMER0_PF_OVF = Copy_u8TimerOVF;
     fca:	89 81       	ldd	r24, Y+1	; 0x01
     fcc:	9a 81       	ldd	r25, Y+2	; 0x02
     fce:	90 93 9d 00 	sts	0x009D, r25
     fd2:	80 93 9c 00 	sts	0x009C, r24
}
     fd6:	0f 90       	pop	r0
     fd8:	0f 90       	pop	r0
     fda:	cf 91       	pop	r28
     fdc:	df 91       	pop	r29
     fde:	08 95       	ret

00000fe0 <__vector_11>:


ISR(TIMER0_OVF_vect)
{
     fe0:	1f 92       	push	r1
     fe2:	0f 92       	push	r0
     fe4:	0f b6       	in	r0, 0x3f	; 63
     fe6:	0f 92       	push	r0
     fe8:	11 24       	eor	r1, r1
     fea:	2f 93       	push	r18
     fec:	3f 93       	push	r19
     fee:	4f 93       	push	r20
     ff0:	5f 93       	push	r21
     ff2:	6f 93       	push	r22
     ff4:	7f 93       	push	r23
     ff6:	8f 93       	push	r24
     ff8:	9f 93       	push	r25
     ffa:	af 93       	push	r26
     ffc:	bf 93       	push	r27
     ffe:	ef 93       	push	r30
    1000:	ff 93       	push	r31
    1002:	df 93       	push	r29
    1004:	cf 93       	push	r28
    1006:	cd b7       	in	r28, 0x3d	; 61
    1008:	de b7       	in	r29, 0x3e	; 62
	static uint16 Local_u16CtrOVF = 0;
	Local_u16CtrOVF++;
    100a:	80 91 98 00 	lds	r24, 0x0098
    100e:	90 91 99 00 	lds	r25, 0x0099
    1012:	01 96       	adiw	r24, 0x01	; 1
    1014:	90 93 99 00 	sts	0x0099, r25
    1018:	80 93 98 00 	sts	0x0098, r24
	if(Local_u16CtrOVF == 3907)
    101c:	80 91 98 00 	lds	r24, 0x0098
    1020:	90 91 99 00 	lds	r25, 0x0099
    1024:	2f e0       	ldi	r18, 0x0F	; 15
    1026:	83 34       	cpi	r24, 0x43	; 67
    1028:	92 07       	cpc	r25, r18
    102a:	69 f4       	brne	.+26     	; 0x1046 <__vector_11+0x66>
	{
		TIMER0_PF_OVF();
    102c:	e0 91 9c 00 	lds	r30, 0x009C
    1030:	f0 91 9d 00 	lds	r31, 0x009D
    1034:	09 95       	icall
		Local_u16CtrOVF = 0;
    1036:	10 92 99 00 	sts	0x0099, r1
    103a:	10 92 98 00 	sts	0x0098, r1
		TCNT0 = 192;
    103e:	e2 e5       	ldi	r30, 0x52	; 82
    1040:	f0 e0       	ldi	r31, 0x00	; 0
    1042:	80 ec       	ldi	r24, 0xC0	; 192
    1044:	80 83       	st	Z, r24
	}

}
    1046:	cf 91       	pop	r28
    1048:	df 91       	pop	r29
    104a:	ff 91       	pop	r31
    104c:	ef 91       	pop	r30
    104e:	bf 91       	pop	r27
    1050:	af 91       	pop	r26
    1052:	9f 91       	pop	r25
    1054:	8f 91       	pop	r24
    1056:	7f 91       	pop	r23
    1058:	6f 91       	pop	r22
    105a:	5f 91       	pop	r21
    105c:	4f 91       	pop	r20
    105e:	3f 91       	pop	r19
    1060:	2f 91       	pop	r18
    1062:	0f 90       	pop	r0
    1064:	0f be       	out	0x3f, r0	; 63
    1066:	0f 90       	pop	r0
    1068:	1f 90       	pop	r1
    106a:	18 95       	reti

0000106c <TMR0_Timer0InitCTC_Vid>:


void TMR0_Timer0InitCTC_Vid(uint16 Copy_u8Time_ms)
{
    106c:	df 93       	push	r29
    106e:	cf 93       	push	r28
    1070:	00 d0       	rcall	.+0      	; 0x1072 <TMR0_Timer0InitCTC_Vid+0x6>
    1072:	cd b7       	in	r28, 0x3d	; 61
    1074:	de b7       	in	r29, 0x3e	; 62
    1076:	9a 83       	std	Y+2, r25	; 0x02
    1078:	89 83       	std	Y+1, r24	; 0x01
	Global_u16Time_ms = Copy_u8Time_ms;
    107a:	89 81       	ldd	r24, Y+1	; 0x01
    107c:	9a 81       	ldd	r25, Y+2	; 0x02
    107e:	90 93 97 00 	sts	0x0097, r25
    1082:	80 93 96 00 	sts	0x0096, r24

	/* CTC Mode */
	CLEAR_BIT(TCCR0, WGM00);
    1086:	a3 e5       	ldi	r26, 0x53	; 83
    1088:	b0 e0       	ldi	r27, 0x00	; 0
    108a:	e3 e5       	ldi	r30, 0x53	; 83
    108c:	f0 e0       	ldi	r31, 0x00	; 0
    108e:	80 81       	ld	r24, Z
    1090:	8f 7b       	andi	r24, 0xBF	; 191
    1092:	8c 93       	st	X, r24
	SET_BIT(TCCR0, WGM01);
    1094:	a3 e5       	ldi	r26, 0x53	; 83
    1096:	b0 e0       	ldi	r27, 0x00	; 0
    1098:	e3 e5       	ldi	r30, 0x53	; 83
    109a:	f0 e0       	ldi	r31, 0x00	; 0
    109c:	80 81       	ld	r24, Z
    109e:	88 60       	ori	r24, 0x08	; 8
    10a0:	8c 93       	st	X, r24

	/* OVF Interrupt */
	SET_BIT(TIMSK, OCIE0);
    10a2:	a9 e5       	ldi	r26, 0x59	; 89
    10a4:	b0 e0       	ldi	r27, 0x00	; 0
    10a6:	e9 e5       	ldi	r30, 0x59	; 89
    10a8:	f0 e0       	ldi	r31, 0x00	; 0
    10aa:	80 81       	ld	r24, Z
    10ac:	82 60       	ori	r24, 0x02	; 2
    10ae:	8c 93       	st	X, r24

	OCR0 = 199;/* need 1milliSecond /// AssumePreScalar=8 --> TickTime=10e-6 /// AssumeNumberOfTicks=250 --> NumberOfFlagSetted=4*/
    10b0:	ec e5       	ldi	r30, 0x5C	; 92
    10b2:	f0 e0       	ldi	r31, 0x00	; 0
    10b4:	87 ec       	ldi	r24, 0xC7	; 199
    10b6:	80 83       	st	Z, r24

	/* CLK/8 */
	CLEAR_BIT(TCCR0, CS00);
    10b8:	a3 e5       	ldi	r26, 0x53	; 83
    10ba:	b0 e0       	ldi	r27, 0x00	; 0
    10bc:	e3 e5       	ldi	r30, 0x53	; 83
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    10c0:	80 81       	ld	r24, Z
    10c2:	8e 7f       	andi	r24, 0xFE	; 254
    10c4:	8c 93       	st	X, r24
	SET_BIT(TCCR0, CS01);
    10c6:	a3 e5       	ldi	r26, 0x53	; 83
    10c8:	b0 e0       	ldi	r27, 0x00	; 0
    10ca:	e3 e5       	ldi	r30, 0x53	; 83
    10cc:	f0 e0       	ldi	r31, 0x00	; 0
    10ce:	80 81       	ld	r24, Z
    10d0:	82 60       	ori	r24, 0x02	; 2
    10d2:	8c 93       	st	X, r24
	CLEAR_BIT(TCCR0, CS02);
    10d4:	a3 e5       	ldi	r26, 0x53	; 83
    10d6:	b0 e0       	ldi	r27, 0x00	; 0
    10d8:	e3 e5       	ldi	r30, 0x53	; 83
    10da:	f0 e0       	ldi	r31, 0x00	; 0
    10dc:	80 81       	ld	r24, Z
    10de:	8b 7f       	andi	r24, 0xFB	; 251
    10e0:	8c 93       	st	X, r24
}
    10e2:	0f 90       	pop	r0
    10e4:	0f 90       	pop	r0
    10e6:	cf 91       	pop	r28
    10e8:	df 91       	pop	r29
    10ea:	08 95       	ret

000010ec <TMR0_Timer0SetCallBackCTC>:

void TMR0_Timer0SetCallBackCTC(void (*Copy_u8TimerCTC) (void))
{
    10ec:	df 93       	push	r29
    10ee:	cf 93       	push	r28
    10f0:	00 d0       	rcall	.+0      	; 0x10f2 <TMR0_Timer0SetCallBackCTC+0x6>
    10f2:	cd b7       	in	r28, 0x3d	; 61
    10f4:	de b7       	in	r29, 0x3e	; 62
    10f6:	9a 83       	std	Y+2, r25	; 0x02
    10f8:	89 83       	std	Y+1, r24	; 0x01
	TIMER0_PF_CTC = Copy_u8TimerCTC;
    10fa:	89 81       	ldd	r24, Y+1	; 0x01
    10fc:	9a 81       	ldd	r25, Y+2	; 0x02
    10fe:	90 93 9f 00 	sts	0x009F, r25
    1102:	80 93 9e 00 	sts	0x009E, r24
}
    1106:	0f 90       	pop	r0
    1108:	0f 90       	pop	r0
    110a:	cf 91       	pop	r28
    110c:	df 91       	pop	r29
    110e:	08 95       	ret

00001110 <__vector_10>:

ISR(TIMER0_COMP_vect)
{
    1110:	1f 92       	push	r1
    1112:	0f 92       	push	r0
    1114:	0f b6       	in	r0, 0x3f	; 63
    1116:	0f 92       	push	r0
    1118:	11 24       	eor	r1, r1
    111a:	2f 93       	push	r18
    111c:	3f 93       	push	r19
    111e:	4f 93       	push	r20
    1120:	5f 93       	push	r21
    1122:	6f 93       	push	r22
    1124:	7f 93       	push	r23
    1126:	8f 93       	push	r24
    1128:	9f 93       	push	r25
    112a:	af 93       	push	r26
    112c:	bf 93       	push	r27
    112e:	ef 93       	push	r30
    1130:	ff 93       	push	r31
    1132:	df 93       	push	r29
    1134:	cf 93       	push	r28
    1136:	cd b7       	in	r28, 0x3d	; 61
    1138:	de b7       	in	r29, 0x3e	; 62
	static uint16 Local_u16CtrCTC = 0;
	Local_u16CtrCTC++;
    113a:	80 91 9a 00 	lds	r24, 0x009A
    113e:	90 91 9b 00 	lds	r25, 0x009B
    1142:	01 96       	adiw	r24, 0x01	; 1
    1144:	90 93 9b 00 	sts	0x009B, r25
    1148:	80 93 9a 00 	sts	0x009A, r24
	if(Local_u16CtrCTC ==5)
    114c:	80 91 9a 00 	lds	r24, 0x009A
    1150:	90 91 9b 00 	lds	r25, 0x009B
    1154:	85 30       	cpi	r24, 0x05	; 5
    1156:	91 05       	cpc	r25, r1
    1158:	49 f4       	brne	.+18     	; 0x116c <__vector_10+0x5c>
	{
		TIMER0_PF_CTC();
    115a:	e0 91 9e 00 	lds	r30, 0x009E
    115e:	f0 91 9f 00 	lds	r31, 0x009F
    1162:	09 95       	icall
		Local_u16CtrCTC = 0;
    1164:	10 92 9b 00 	sts	0x009B, r1
    1168:	10 92 9a 00 	sts	0x009A, r1
	}
}
    116c:	cf 91       	pop	r28
    116e:	df 91       	pop	r29
    1170:	ff 91       	pop	r31
    1172:	ef 91       	pop	r30
    1174:	bf 91       	pop	r27
    1176:	af 91       	pop	r26
    1178:	9f 91       	pop	r25
    117a:	8f 91       	pop	r24
    117c:	7f 91       	pop	r23
    117e:	6f 91       	pop	r22
    1180:	5f 91       	pop	r21
    1182:	4f 91       	pop	r20
    1184:	3f 91       	pop	r19
    1186:	2f 91       	pop	r18
    1188:	0f 90       	pop	r0
    118a:	0f be       	out	0x3f, r0	; 63
    118c:	0f 90       	pop	r0
    118e:	1f 90       	pop	r1
    1190:	18 95       	reti

00001192 <GIE_VidEnable>:

#include "../../LIB/BIT_MATH.h"
#include "avr/io.h"

void GIE_VidEnable(void)
{
    1192:	df 93       	push	r29
    1194:	cf 93       	push	r28
    1196:	cd b7       	in	r28, 0x3d	; 61
    1198:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,7);
    119a:	af e5       	ldi	r26, 0x5F	; 95
    119c:	b0 e0       	ldi	r27, 0x00	; 0
    119e:	ef e5       	ldi	r30, 0x5F	; 95
    11a0:	f0 e0       	ldi	r31, 0x00	; 0
    11a2:	80 81       	ld	r24, Z
    11a4:	80 68       	ori	r24, 0x80	; 128
    11a6:	8c 93       	st	X, r24
}
    11a8:	cf 91       	pop	r28
    11aa:	df 91       	pop	r29
    11ac:	08 95       	ret

000011ae <GIE_VidDisable>:
void GIE_VidDisable(void)
{
    11ae:	df 93       	push	r29
    11b0:	cf 93       	push	r28
    11b2:	cd b7       	in	r28, 0x3d	; 61
    11b4:	de b7       	in	r29, 0x3e	; 62
	CLEAR_BIT(SREG,7);
    11b6:	af e5       	ldi	r26, 0x5F	; 95
    11b8:	b0 e0       	ldi	r27, 0x00	; 0
    11ba:	ef e5       	ldi	r30, 0x5F	; 95
    11bc:	f0 e0       	ldi	r31, 0x00	; 0
    11be:	80 81       	ld	r24, Z
    11c0:	8f 77       	andi	r24, 0x7F	; 127
    11c2:	8c 93       	st	X, r24
}
    11c4:	cf 91       	pop	r28
    11c6:	df 91       	pop	r29
    11c8:	08 95       	ret

000011ca <INT_Vid_init>:

void (*EXTI_PVidTemp[3])(void) = {NULL , NULL ,NULL};


void INT_Vid_init(void)
{
    11ca:	df 93       	push	r29
    11cc:	cf 93       	push	r28
    11ce:	cd b7       	in	r28, 0x3d	; 61
    11d0:	de b7       	in	r29, 0x3e	; 62
	CLEAR_BIT(MCUCR,ISC01);
#elif INT_MODE==INT_FALLING_EDGE
	CLEAR_BIT(MCUCR,ISC00);
	SET_BIT(MCUCR,ISC01);
#elif INT_MODE==INT_RISING_EDGE
	SET_BIT(MCUCR,ISC00);
    11d2:	a5 e5       	ldi	r26, 0x55	; 85
    11d4:	b0 e0       	ldi	r27, 0x00	; 0
    11d6:	e5 e5       	ldi	r30, 0x55	; 85
    11d8:	f0 e0       	ldi	r31, 0x00	; 0
    11da:	80 81       	ld	r24, Z
    11dc:	81 60       	ori	r24, 0x01	; 1
    11de:	8c 93       	st	X, r24
	SET_BIT(MCUCR,ISC01);
    11e0:	a5 e5       	ldi	r26, 0x55	; 85
    11e2:	b0 e0       	ldi	r27, 0x00	; 0
    11e4:	e5 e5       	ldi	r30, 0x55	; 85
    11e6:	f0 e0       	ldi	r31, 0x00	; 0
    11e8:	80 81       	ld	r24, Z
    11ea:	82 60       	ori	r24, 0x02	; 2
    11ec:	8c 93       	st	X, r24
#endif
	SET_BIT(GICR,INT0);
    11ee:	ab e5       	ldi	r26, 0x5B	; 91
    11f0:	b0 e0       	ldi	r27, 0x00	; 0
    11f2:	eb e5       	ldi	r30, 0x5B	; 91
    11f4:	f0 e0       	ldi	r31, 0x00	; 0
    11f6:	80 81       	ld	r24, Z
    11f8:	80 64       	ori	r24, 0x40	; 64
    11fa:	8c 93       	st	X, r24
#elif INT_MODE==INT_RISING_EDGE
	SET_BIT(MCUCR,ISC2);
#endif
	SET_BIT(GICR,INT2);
#endif
}
    11fc:	cf 91       	pop	r28
    11fe:	df 91       	pop	r29
    1200:	08 95       	ret

00001202 <GIE_VidInit>:

void GIE_VidInit(void)
{
    1202:	df 93       	push	r29
    1204:	cf 93       	push	r28
    1206:	cd b7       	in	r28, 0x3d	; 61
    1208:	de b7       	in	r29, 0x3e	; 62
#if INT_GIE==ENABLE
	SET_BIT(SREG,I_BIT);
    120a:	af e5       	ldi	r26, 0x5F	; 95
    120c:	b0 e0       	ldi	r27, 0x00	; 0
    120e:	ef e5       	ldi	r30, 0x5F	; 95
    1210:	f0 e0       	ldi	r31, 0x00	; 0
    1212:	80 81       	ld	r24, Z
    1214:	80 68       	ori	r24, 0x80	; 128
    1216:	8c 93       	st	X, r24
#elif INT_GIE==DISABLE
	CLEAR_BIT(SREG,I_BIT);
#endif
}
    1218:	cf 91       	pop	r28
    121a:	df 91       	pop	r29
    121c:	08 95       	ret

0000121e <EXTI_VidSetCallBack>:

void EXTI_VidSetCallBack(u8 Copy_index , void (*copy_ptr)(void))
{
    121e:	df 93       	push	r29
    1220:	cf 93       	push	r28
    1222:	00 d0       	rcall	.+0      	; 0x1224 <EXTI_VidSetCallBack+0x6>
    1224:	0f 92       	push	r0
    1226:	cd b7       	in	r28, 0x3d	; 61
    1228:	de b7       	in	r29, 0x3e	; 62
    122a:	89 83       	std	Y+1, r24	; 0x01
    122c:	7b 83       	std	Y+3, r23	; 0x03
    122e:	6a 83       	std	Y+2, r22	; 0x02
	EXTI_PVidTemp[Copy_index] = copy_ptr;
    1230:	89 81       	ldd	r24, Y+1	; 0x01
    1232:	88 2f       	mov	r24, r24
    1234:	90 e0       	ldi	r25, 0x00	; 0
    1236:	88 0f       	add	r24, r24
    1238:	99 1f       	adc	r25, r25
    123a:	fc 01       	movw	r30, r24
    123c:	e0 56       	subi	r30, 0x60	; 96
    123e:	ff 4f       	sbci	r31, 0xFF	; 255
    1240:	8a 81       	ldd	r24, Y+2	; 0x02
    1242:	9b 81       	ldd	r25, Y+3	; 0x03
    1244:	91 83       	std	Z+1, r25	; 0x01
    1246:	80 83       	st	Z, r24
}
    1248:	0f 90       	pop	r0
    124a:	0f 90       	pop	r0
    124c:	0f 90       	pop	r0
    124e:	cf 91       	pop	r28
    1250:	df 91       	pop	r29
    1252:	08 95       	ret

00001254 <__vector_1>:

ISR(INT0_vect)
{
    1254:	1f 92       	push	r1
    1256:	0f 92       	push	r0
    1258:	0f b6       	in	r0, 0x3f	; 63
    125a:	0f 92       	push	r0
    125c:	11 24       	eor	r1, r1
    125e:	2f 93       	push	r18
    1260:	3f 93       	push	r19
    1262:	4f 93       	push	r20
    1264:	5f 93       	push	r21
    1266:	6f 93       	push	r22
    1268:	7f 93       	push	r23
    126a:	8f 93       	push	r24
    126c:	9f 93       	push	r25
    126e:	af 93       	push	r26
    1270:	bf 93       	push	r27
    1272:	ef 93       	push	r30
    1274:	ff 93       	push	r31
    1276:	df 93       	push	r29
    1278:	cf 93       	push	r28
    127a:	cd b7       	in	r28, 0x3d	; 61
    127c:	de b7       	in	r29, 0x3e	; 62
	if(EXTI_PVidTemp[0] != NULL)
    127e:	80 91 a0 00 	lds	r24, 0x00A0
    1282:	90 91 a1 00 	lds	r25, 0x00A1
    1286:	00 97       	sbiw	r24, 0x00	; 0
    1288:	29 f0       	breq	.+10     	; 0x1294 <__vector_1+0x40>
	{
		EXTI_PVidTemp[0]();
    128a:	e0 91 a0 00 	lds	r30, 0x00A0
    128e:	f0 91 a1 00 	lds	r31, 0x00A1
    1292:	09 95       	icall
	}
}
    1294:	cf 91       	pop	r28
    1296:	df 91       	pop	r29
    1298:	ff 91       	pop	r31
    129a:	ef 91       	pop	r30
    129c:	bf 91       	pop	r27
    129e:	af 91       	pop	r26
    12a0:	9f 91       	pop	r25
    12a2:	8f 91       	pop	r24
    12a4:	7f 91       	pop	r23
    12a6:	6f 91       	pop	r22
    12a8:	5f 91       	pop	r21
    12aa:	4f 91       	pop	r20
    12ac:	3f 91       	pop	r19
    12ae:	2f 91       	pop	r18
    12b0:	0f 90       	pop	r0
    12b2:	0f be       	out	0x3f, r0	; 63
    12b4:	0f 90       	pop	r0
    12b6:	1f 90       	pop	r1
    12b8:	18 95       	reti

000012ba <__vector_2>:

ISR(INT1_vect)
{
    12ba:	1f 92       	push	r1
    12bc:	0f 92       	push	r0
    12be:	0f b6       	in	r0, 0x3f	; 63
    12c0:	0f 92       	push	r0
    12c2:	11 24       	eor	r1, r1
    12c4:	2f 93       	push	r18
    12c6:	3f 93       	push	r19
    12c8:	4f 93       	push	r20
    12ca:	5f 93       	push	r21
    12cc:	6f 93       	push	r22
    12ce:	7f 93       	push	r23
    12d0:	8f 93       	push	r24
    12d2:	9f 93       	push	r25
    12d4:	af 93       	push	r26
    12d6:	bf 93       	push	r27
    12d8:	ef 93       	push	r30
    12da:	ff 93       	push	r31
    12dc:	df 93       	push	r29
    12de:	cf 93       	push	r28
    12e0:	cd b7       	in	r28, 0x3d	; 61
    12e2:	de b7       	in	r29, 0x3e	; 62
	if(EXTI_PVidTemp[1] != NULL)
    12e4:	80 91 a2 00 	lds	r24, 0x00A2
    12e8:	90 91 a3 00 	lds	r25, 0x00A3
    12ec:	00 97       	sbiw	r24, 0x00	; 0
    12ee:	29 f0       	breq	.+10     	; 0x12fa <__vector_2+0x40>
	{
		EXTI_PVidTemp[1]();
    12f0:	e0 91 a2 00 	lds	r30, 0x00A2
    12f4:	f0 91 a3 00 	lds	r31, 0x00A3
    12f8:	09 95       	icall
	}
}
    12fa:	cf 91       	pop	r28
    12fc:	df 91       	pop	r29
    12fe:	ff 91       	pop	r31
    1300:	ef 91       	pop	r30
    1302:	bf 91       	pop	r27
    1304:	af 91       	pop	r26
    1306:	9f 91       	pop	r25
    1308:	8f 91       	pop	r24
    130a:	7f 91       	pop	r23
    130c:	6f 91       	pop	r22
    130e:	5f 91       	pop	r21
    1310:	4f 91       	pop	r20
    1312:	3f 91       	pop	r19
    1314:	2f 91       	pop	r18
    1316:	0f 90       	pop	r0
    1318:	0f be       	out	0x3f, r0	; 63
    131a:	0f 90       	pop	r0
    131c:	1f 90       	pop	r1
    131e:	18 95       	reti

00001320 <__vector_3>:

ISR(INT2_vect)
{
    1320:	1f 92       	push	r1
    1322:	0f 92       	push	r0
    1324:	0f b6       	in	r0, 0x3f	; 63
    1326:	0f 92       	push	r0
    1328:	11 24       	eor	r1, r1
    132a:	2f 93       	push	r18
    132c:	3f 93       	push	r19
    132e:	4f 93       	push	r20
    1330:	5f 93       	push	r21
    1332:	6f 93       	push	r22
    1334:	7f 93       	push	r23
    1336:	8f 93       	push	r24
    1338:	9f 93       	push	r25
    133a:	af 93       	push	r26
    133c:	bf 93       	push	r27
    133e:	ef 93       	push	r30
    1340:	ff 93       	push	r31
    1342:	df 93       	push	r29
    1344:	cf 93       	push	r28
    1346:	cd b7       	in	r28, 0x3d	; 61
    1348:	de b7       	in	r29, 0x3e	; 62
	if(EXTI_PVidTemp[2] != NULL)
    134a:	80 91 a4 00 	lds	r24, 0x00A4
    134e:	90 91 a5 00 	lds	r25, 0x00A5
    1352:	00 97       	sbiw	r24, 0x00	; 0
    1354:	29 f0       	breq	.+10     	; 0x1360 <__vector_3+0x40>
	{
		EXTI_PVidTemp[2]();
    1356:	e0 91 a4 00 	lds	r30, 0x00A4
    135a:	f0 91 a5 00 	lds	r31, 0x00A5
    135e:	09 95       	icall
	}
}
    1360:	cf 91       	pop	r28
    1362:	df 91       	pop	r29
    1364:	ff 91       	pop	r31
    1366:	ef 91       	pop	r30
    1368:	bf 91       	pop	r27
    136a:	af 91       	pop	r26
    136c:	9f 91       	pop	r25
    136e:	8f 91       	pop	r24
    1370:	7f 91       	pop	r23
    1372:	6f 91       	pop	r22
    1374:	5f 91       	pop	r21
    1376:	4f 91       	pop	r20
    1378:	3f 91       	pop	r19
    137a:	2f 91       	pop	r18
    137c:	0f 90       	pop	r0
    137e:	0f be       	out	0x3f, r0	; 63
    1380:	0f 90       	pop	r0
    1382:	1f 90       	pop	r1
    1384:	18 95       	reti

00001386 <DIO_VidSetPinDirection>:
#include "DIO.h"



void DIO_VidSetPinDirection(u8 Copy_u8Port , u8 Copy_u8Pin , u8 Copy_u8Direction)
{
    1386:	df 93       	push	r29
    1388:	cf 93       	push	r28
    138a:	cd b7       	in	r28, 0x3d	; 61
    138c:	de b7       	in	r29, 0x3e	; 62
    138e:	27 97       	sbiw	r28, 0x07	; 7
    1390:	0f b6       	in	r0, 0x3f	; 63
    1392:	f8 94       	cli
    1394:	de bf       	out	0x3e, r29	; 62
    1396:	0f be       	out	0x3f, r0	; 63
    1398:	cd bf       	out	0x3d, r28	; 61
    139a:	89 83       	std	Y+1, r24	; 0x01
    139c:	6a 83       	std	Y+2, r22	; 0x02
    139e:	4b 83       	std	Y+3, r20	; 0x03
	if(Copy_u8Direction == 1)
    13a0:	8b 81       	ldd	r24, Y+3	; 0x03
    13a2:	81 30       	cpi	r24, 0x01	; 1
    13a4:	09 f0       	breq	.+2      	; 0x13a8 <DIO_VidSetPinDirection+0x22>
    13a6:	6f c0       	rjmp	.+222    	; 0x1486 <DIO_VidSetPinDirection+0x100>
	{
		switch(Copy_u8Port)
    13a8:	89 81       	ldd	r24, Y+1	; 0x01
    13aa:	28 2f       	mov	r18, r24
    13ac:	30 e0       	ldi	r19, 0x00	; 0
    13ae:	3f 83       	std	Y+7, r19	; 0x07
    13b0:	2e 83       	std	Y+6, r18	; 0x06
    13b2:	8e 81       	ldd	r24, Y+6	; 0x06
    13b4:	9f 81       	ldd	r25, Y+7	; 0x07
    13b6:	81 30       	cpi	r24, 0x01	; 1
    13b8:	91 05       	cpc	r25, r1
    13ba:	49 f1       	breq	.+82     	; 0x140e <DIO_VidSetPinDirection+0x88>
    13bc:	2e 81       	ldd	r18, Y+6	; 0x06
    13be:	3f 81       	ldd	r19, Y+7	; 0x07
    13c0:	22 30       	cpi	r18, 0x02	; 2
    13c2:	31 05       	cpc	r19, r1
    13c4:	2c f4       	brge	.+10     	; 0x13d0 <DIO_VidSetPinDirection+0x4a>
    13c6:	8e 81       	ldd	r24, Y+6	; 0x06
    13c8:	9f 81       	ldd	r25, Y+7	; 0x07
    13ca:	00 97       	sbiw	r24, 0x00	; 0
    13cc:	61 f0       	breq	.+24     	; 0x13e6 <DIO_VidSetPinDirection+0x60>
    13ce:	d2 c0       	rjmp	.+420    	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
    13d0:	2e 81       	ldd	r18, Y+6	; 0x06
    13d2:	3f 81       	ldd	r19, Y+7	; 0x07
    13d4:	22 30       	cpi	r18, 0x02	; 2
    13d6:	31 05       	cpc	r19, r1
    13d8:	71 f1       	breq	.+92     	; 0x1436 <DIO_VidSetPinDirection+0xb0>
    13da:	8e 81       	ldd	r24, Y+6	; 0x06
    13dc:	9f 81       	ldd	r25, Y+7	; 0x07
    13de:	83 30       	cpi	r24, 0x03	; 3
    13e0:	91 05       	cpc	r25, r1
    13e2:	e9 f1       	breq	.+122    	; 0x145e <DIO_VidSetPinDirection+0xd8>
    13e4:	c7 c0       	rjmp	.+398    	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
		{
			case 0:SET_BIT(DDRA, Copy_u8Pin);break;
    13e6:	aa e3       	ldi	r26, 0x3A	; 58
    13e8:	b0 e0       	ldi	r27, 0x00	; 0
    13ea:	ea e3       	ldi	r30, 0x3A	; 58
    13ec:	f0 e0       	ldi	r31, 0x00	; 0
    13ee:	80 81       	ld	r24, Z
    13f0:	48 2f       	mov	r20, r24
    13f2:	8a 81       	ldd	r24, Y+2	; 0x02
    13f4:	28 2f       	mov	r18, r24
    13f6:	30 e0       	ldi	r19, 0x00	; 0
    13f8:	81 e0       	ldi	r24, 0x01	; 1
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	02 2e       	mov	r0, r18
    13fe:	02 c0       	rjmp	.+4      	; 0x1404 <DIO_VidSetPinDirection+0x7e>
    1400:	88 0f       	add	r24, r24
    1402:	99 1f       	adc	r25, r25
    1404:	0a 94       	dec	r0
    1406:	e2 f7       	brpl	.-8      	; 0x1400 <DIO_VidSetPinDirection+0x7a>
    1408:	84 2b       	or	r24, r20
    140a:	8c 93       	st	X, r24
    140c:	b3 c0       	rjmp	.+358    	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
			case 1:SET_BIT(DDRB, Copy_u8Pin);break;
    140e:	a7 e3       	ldi	r26, 0x37	; 55
    1410:	b0 e0       	ldi	r27, 0x00	; 0
    1412:	e7 e3       	ldi	r30, 0x37	; 55
    1414:	f0 e0       	ldi	r31, 0x00	; 0
    1416:	80 81       	ld	r24, Z
    1418:	48 2f       	mov	r20, r24
    141a:	8a 81       	ldd	r24, Y+2	; 0x02
    141c:	28 2f       	mov	r18, r24
    141e:	30 e0       	ldi	r19, 0x00	; 0
    1420:	81 e0       	ldi	r24, 0x01	; 1
    1422:	90 e0       	ldi	r25, 0x00	; 0
    1424:	02 2e       	mov	r0, r18
    1426:	02 c0       	rjmp	.+4      	; 0x142c <DIO_VidSetPinDirection+0xa6>
    1428:	88 0f       	add	r24, r24
    142a:	99 1f       	adc	r25, r25
    142c:	0a 94       	dec	r0
    142e:	e2 f7       	brpl	.-8      	; 0x1428 <DIO_VidSetPinDirection+0xa2>
    1430:	84 2b       	or	r24, r20
    1432:	8c 93       	st	X, r24
    1434:	9f c0       	rjmp	.+318    	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
			case 2:SET_BIT(DDRC, Copy_u8Pin);break;
    1436:	a4 e3       	ldi	r26, 0x34	; 52
    1438:	b0 e0       	ldi	r27, 0x00	; 0
    143a:	e4 e3       	ldi	r30, 0x34	; 52
    143c:	f0 e0       	ldi	r31, 0x00	; 0
    143e:	80 81       	ld	r24, Z
    1440:	48 2f       	mov	r20, r24
    1442:	8a 81       	ldd	r24, Y+2	; 0x02
    1444:	28 2f       	mov	r18, r24
    1446:	30 e0       	ldi	r19, 0x00	; 0
    1448:	81 e0       	ldi	r24, 0x01	; 1
    144a:	90 e0       	ldi	r25, 0x00	; 0
    144c:	02 2e       	mov	r0, r18
    144e:	02 c0       	rjmp	.+4      	; 0x1454 <DIO_VidSetPinDirection+0xce>
    1450:	88 0f       	add	r24, r24
    1452:	99 1f       	adc	r25, r25
    1454:	0a 94       	dec	r0
    1456:	e2 f7       	brpl	.-8      	; 0x1450 <DIO_VidSetPinDirection+0xca>
    1458:	84 2b       	or	r24, r20
    145a:	8c 93       	st	X, r24
    145c:	8b c0       	rjmp	.+278    	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
			case 3:SET_BIT(DDRD, Copy_u8Pin);break;
    145e:	a1 e3       	ldi	r26, 0x31	; 49
    1460:	b0 e0       	ldi	r27, 0x00	; 0
    1462:	e1 e3       	ldi	r30, 0x31	; 49
    1464:	f0 e0       	ldi	r31, 0x00	; 0
    1466:	80 81       	ld	r24, Z
    1468:	48 2f       	mov	r20, r24
    146a:	8a 81       	ldd	r24, Y+2	; 0x02
    146c:	28 2f       	mov	r18, r24
    146e:	30 e0       	ldi	r19, 0x00	; 0
    1470:	81 e0       	ldi	r24, 0x01	; 1
    1472:	90 e0       	ldi	r25, 0x00	; 0
    1474:	02 2e       	mov	r0, r18
    1476:	02 c0       	rjmp	.+4      	; 0x147c <DIO_VidSetPinDirection+0xf6>
    1478:	88 0f       	add	r24, r24
    147a:	99 1f       	adc	r25, r25
    147c:	0a 94       	dec	r0
    147e:	e2 f7       	brpl	.-8      	; 0x1478 <DIO_VidSetPinDirection+0xf2>
    1480:	84 2b       	or	r24, r20
    1482:	8c 93       	st	X, r24
    1484:	77 c0       	rjmp	.+238    	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
		}
	}
	else if(Copy_u8Direction == 0)
    1486:	8b 81       	ldd	r24, Y+3	; 0x03
    1488:	88 23       	and	r24, r24
    148a:	09 f0       	breq	.+2      	; 0x148e <DIO_VidSetPinDirection+0x108>
    148c:	73 c0       	rjmp	.+230    	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
	{
		switch(Copy_u8Port)
    148e:	89 81       	ldd	r24, Y+1	; 0x01
    1490:	28 2f       	mov	r18, r24
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	3d 83       	std	Y+5, r19	; 0x05
    1496:	2c 83       	std	Y+4, r18	; 0x04
    1498:	8c 81       	ldd	r24, Y+4	; 0x04
    149a:	9d 81       	ldd	r25, Y+5	; 0x05
    149c:	81 30       	cpi	r24, 0x01	; 1
    149e:	91 05       	cpc	r25, r1
    14a0:	59 f1       	breq	.+86     	; 0x14f8 <DIO_VidSetPinDirection+0x172>
    14a2:	2c 81       	ldd	r18, Y+4	; 0x04
    14a4:	3d 81       	ldd	r19, Y+5	; 0x05
    14a6:	22 30       	cpi	r18, 0x02	; 2
    14a8:	31 05       	cpc	r19, r1
    14aa:	2c f4       	brge	.+10     	; 0x14b6 <DIO_VidSetPinDirection+0x130>
    14ac:	8c 81       	ldd	r24, Y+4	; 0x04
    14ae:	9d 81       	ldd	r25, Y+5	; 0x05
    14b0:	00 97       	sbiw	r24, 0x00	; 0
    14b2:	69 f0       	breq	.+26     	; 0x14ce <DIO_VidSetPinDirection+0x148>
    14b4:	5f c0       	rjmp	.+190    	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
    14b6:	2c 81       	ldd	r18, Y+4	; 0x04
    14b8:	3d 81       	ldd	r19, Y+5	; 0x05
    14ba:	22 30       	cpi	r18, 0x02	; 2
    14bc:	31 05       	cpc	r19, r1
    14be:	89 f1       	breq	.+98     	; 0x1522 <DIO_VidSetPinDirection+0x19c>
    14c0:	8c 81       	ldd	r24, Y+4	; 0x04
    14c2:	9d 81       	ldd	r25, Y+5	; 0x05
    14c4:	83 30       	cpi	r24, 0x03	; 3
    14c6:	91 05       	cpc	r25, r1
    14c8:	09 f4       	brne	.+2      	; 0x14cc <DIO_VidSetPinDirection+0x146>
    14ca:	40 c0       	rjmp	.+128    	; 0x154c <DIO_VidSetPinDirection+0x1c6>
    14cc:	53 c0       	rjmp	.+166    	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
		{
			case 0:CLEAR_BIT(DDRA, Copy_u8Pin);break;
    14ce:	aa e3       	ldi	r26, 0x3A	; 58
    14d0:	b0 e0       	ldi	r27, 0x00	; 0
    14d2:	ea e3       	ldi	r30, 0x3A	; 58
    14d4:	f0 e0       	ldi	r31, 0x00	; 0
    14d6:	80 81       	ld	r24, Z
    14d8:	48 2f       	mov	r20, r24
    14da:	8a 81       	ldd	r24, Y+2	; 0x02
    14dc:	28 2f       	mov	r18, r24
    14de:	30 e0       	ldi	r19, 0x00	; 0
    14e0:	81 e0       	ldi	r24, 0x01	; 1
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	02 2e       	mov	r0, r18
    14e6:	02 c0       	rjmp	.+4      	; 0x14ec <DIO_VidSetPinDirection+0x166>
    14e8:	88 0f       	add	r24, r24
    14ea:	99 1f       	adc	r25, r25
    14ec:	0a 94       	dec	r0
    14ee:	e2 f7       	brpl	.-8      	; 0x14e8 <DIO_VidSetPinDirection+0x162>
    14f0:	80 95       	com	r24
    14f2:	84 23       	and	r24, r20
    14f4:	8c 93       	st	X, r24
    14f6:	3e c0       	rjmp	.+124    	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
			case 1:CLEAR_BIT(DDRB, Copy_u8Pin);break;
    14f8:	a7 e3       	ldi	r26, 0x37	; 55
    14fa:	b0 e0       	ldi	r27, 0x00	; 0
    14fc:	e7 e3       	ldi	r30, 0x37	; 55
    14fe:	f0 e0       	ldi	r31, 0x00	; 0
    1500:	80 81       	ld	r24, Z
    1502:	48 2f       	mov	r20, r24
    1504:	8a 81       	ldd	r24, Y+2	; 0x02
    1506:	28 2f       	mov	r18, r24
    1508:	30 e0       	ldi	r19, 0x00	; 0
    150a:	81 e0       	ldi	r24, 0x01	; 1
    150c:	90 e0       	ldi	r25, 0x00	; 0
    150e:	02 2e       	mov	r0, r18
    1510:	02 c0       	rjmp	.+4      	; 0x1516 <DIO_VidSetPinDirection+0x190>
    1512:	88 0f       	add	r24, r24
    1514:	99 1f       	adc	r25, r25
    1516:	0a 94       	dec	r0
    1518:	e2 f7       	brpl	.-8      	; 0x1512 <DIO_VidSetPinDirection+0x18c>
    151a:	80 95       	com	r24
    151c:	84 23       	and	r24, r20
    151e:	8c 93       	st	X, r24
    1520:	29 c0       	rjmp	.+82     	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
			case 2:CLEAR_BIT(DDRC, Copy_u8Pin);break;
    1522:	a4 e3       	ldi	r26, 0x34	; 52
    1524:	b0 e0       	ldi	r27, 0x00	; 0
    1526:	e4 e3       	ldi	r30, 0x34	; 52
    1528:	f0 e0       	ldi	r31, 0x00	; 0
    152a:	80 81       	ld	r24, Z
    152c:	48 2f       	mov	r20, r24
    152e:	8a 81       	ldd	r24, Y+2	; 0x02
    1530:	28 2f       	mov	r18, r24
    1532:	30 e0       	ldi	r19, 0x00	; 0
    1534:	81 e0       	ldi	r24, 0x01	; 1
    1536:	90 e0       	ldi	r25, 0x00	; 0
    1538:	02 2e       	mov	r0, r18
    153a:	02 c0       	rjmp	.+4      	; 0x1540 <DIO_VidSetPinDirection+0x1ba>
    153c:	88 0f       	add	r24, r24
    153e:	99 1f       	adc	r25, r25
    1540:	0a 94       	dec	r0
    1542:	e2 f7       	brpl	.-8      	; 0x153c <DIO_VidSetPinDirection+0x1b6>
    1544:	80 95       	com	r24
    1546:	84 23       	and	r24, r20
    1548:	8c 93       	st	X, r24
    154a:	14 c0       	rjmp	.+40     	; 0x1574 <DIO_VidSetPinDirection+0x1ee>
			case 3:CLEAR_BIT(DDRD, Copy_u8Pin);break;
    154c:	a1 e3       	ldi	r26, 0x31	; 49
    154e:	b0 e0       	ldi	r27, 0x00	; 0
    1550:	e1 e3       	ldi	r30, 0x31	; 49
    1552:	f0 e0       	ldi	r31, 0x00	; 0
    1554:	80 81       	ld	r24, Z
    1556:	48 2f       	mov	r20, r24
    1558:	8a 81       	ldd	r24, Y+2	; 0x02
    155a:	28 2f       	mov	r18, r24
    155c:	30 e0       	ldi	r19, 0x00	; 0
    155e:	81 e0       	ldi	r24, 0x01	; 1
    1560:	90 e0       	ldi	r25, 0x00	; 0
    1562:	02 2e       	mov	r0, r18
    1564:	02 c0       	rjmp	.+4      	; 0x156a <DIO_VidSetPinDirection+0x1e4>
    1566:	88 0f       	add	r24, r24
    1568:	99 1f       	adc	r25, r25
    156a:	0a 94       	dec	r0
    156c:	e2 f7       	brpl	.-8      	; 0x1566 <DIO_VidSetPinDirection+0x1e0>
    156e:	80 95       	com	r24
    1570:	84 23       	and	r24, r20
    1572:	8c 93       	st	X, r24
		}
	}
}
    1574:	27 96       	adiw	r28, 0x07	; 7
    1576:	0f b6       	in	r0, 0x3f	; 63
    1578:	f8 94       	cli
    157a:	de bf       	out	0x3e, r29	; 62
    157c:	0f be       	out	0x3f, r0	; 63
    157e:	cd bf       	out	0x3d, r28	; 61
    1580:	cf 91       	pop	r28
    1582:	df 91       	pop	r29
    1584:	08 95       	ret

00001586 <DIO_VidSetPinValue>:

void DIO_VidSetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin , u8 Copy_u8Value)
{
    1586:	df 93       	push	r29
    1588:	cf 93       	push	r28
    158a:	cd b7       	in	r28, 0x3d	; 61
    158c:	de b7       	in	r29, 0x3e	; 62
    158e:	27 97       	sbiw	r28, 0x07	; 7
    1590:	0f b6       	in	r0, 0x3f	; 63
    1592:	f8 94       	cli
    1594:	de bf       	out	0x3e, r29	; 62
    1596:	0f be       	out	0x3f, r0	; 63
    1598:	cd bf       	out	0x3d, r28	; 61
    159a:	89 83       	std	Y+1, r24	; 0x01
    159c:	6a 83       	std	Y+2, r22	; 0x02
    159e:	4b 83       	std	Y+3, r20	; 0x03
	if(Copy_u8Value == 1)
    15a0:	8b 81       	ldd	r24, Y+3	; 0x03
    15a2:	81 30       	cpi	r24, 0x01	; 1
    15a4:	09 f0       	breq	.+2      	; 0x15a8 <DIO_VidSetPinValue+0x22>
    15a6:	6f c0       	rjmp	.+222    	; 0x1686 <DIO_VidSetPinValue+0x100>
	{
		switch(Copy_u8Port)
    15a8:	89 81       	ldd	r24, Y+1	; 0x01
    15aa:	28 2f       	mov	r18, r24
    15ac:	30 e0       	ldi	r19, 0x00	; 0
    15ae:	3f 83       	std	Y+7, r19	; 0x07
    15b0:	2e 83       	std	Y+6, r18	; 0x06
    15b2:	8e 81       	ldd	r24, Y+6	; 0x06
    15b4:	9f 81       	ldd	r25, Y+7	; 0x07
    15b6:	81 30       	cpi	r24, 0x01	; 1
    15b8:	91 05       	cpc	r25, r1
    15ba:	49 f1       	breq	.+82     	; 0x160e <DIO_VidSetPinValue+0x88>
    15bc:	2e 81       	ldd	r18, Y+6	; 0x06
    15be:	3f 81       	ldd	r19, Y+7	; 0x07
    15c0:	22 30       	cpi	r18, 0x02	; 2
    15c2:	31 05       	cpc	r19, r1
    15c4:	2c f4       	brge	.+10     	; 0x15d0 <DIO_VidSetPinValue+0x4a>
    15c6:	8e 81       	ldd	r24, Y+6	; 0x06
    15c8:	9f 81       	ldd	r25, Y+7	; 0x07
    15ca:	00 97       	sbiw	r24, 0x00	; 0
    15cc:	61 f0       	breq	.+24     	; 0x15e6 <DIO_VidSetPinValue+0x60>
    15ce:	d2 c0       	rjmp	.+420    	; 0x1774 <DIO_VidSetPinValue+0x1ee>
    15d0:	2e 81       	ldd	r18, Y+6	; 0x06
    15d2:	3f 81       	ldd	r19, Y+7	; 0x07
    15d4:	22 30       	cpi	r18, 0x02	; 2
    15d6:	31 05       	cpc	r19, r1
    15d8:	71 f1       	breq	.+92     	; 0x1636 <DIO_VidSetPinValue+0xb0>
    15da:	8e 81       	ldd	r24, Y+6	; 0x06
    15dc:	9f 81       	ldd	r25, Y+7	; 0x07
    15de:	83 30       	cpi	r24, 0x03	; 3
    15e0:	91 05       	cpc	r25, r1
    15e2:	e9 f1       	breq	.+122    	; 0x165e <DIO_VidSetPinValue+0xd8>
    15e4:	c7 c0       	rjmp	.+398    	; 0x1774 <DIO_VidSetPinValue+0x1ee>
		{
			case 0:SET_BIT(PORTA, Copy_u8Pin);break;
    15e6:	ab e3       	ldi	r26, 0x3B	; 59
    15e8:	b0 e0       	ldi	r27, 0x00	; 0
    15ea:	eb e3       	ldi	r30, 0x3B	; 59
    15ec:	f0 e0       	ldi	r31, 0x00	; 0
    15ee:	80 81       	ld	r24, Z
    15f0:	48 2f       	mov	r20, r24
    15f2:	8a 81       	ldd	r24, Y+2	; 0x02
    15f4:	28 2f       	mov	r18, r24
    15f6:	30 e0       	ldi	r19, 0x00	; 0
    15f8:	81 e0       	ldi	r24, 0x01	; 1
    15fa:	90 e0       	ldi	r25, 0x00	; 0
    15fc:	02 2e       	mov	r0, r18
    15fe:	02 c0       	rjmp	.+4      	; 0x1604 <DIO_VidSetPinValue+0x7e>
    1600:	88 0f       	add	r24, r24
    1602:	99 1f       	adc	r25, r25
    1604:	0a 94       	dec	r0
    1606:	e2 f7       	brpl	.-8      	; 0x1600 <DIO_VidSetPinValue+0x7a>
    1608:	84 2b       	or	r24, r20
    160a:	8c 93       	st	X, r24
    160c:	b3 c0       	rjmp	.+358    	; 0x1774 <DIO_VidSetPinValue+0x1ee>
			case 1:SET_BIT(PORTB, Copy_u8Pin);break;
    160e:	a8 e3       	ldi	r26, 0x38	; 56
    1610:	b0 e0       	ldi	r27, 0x00	; 0
    1612:	e8 e3       	ldi	r30, 0x38	; 56
    1614:	f0 e0       	ldi	r31, 0x00	; 0
    1616:	80 81       	ld	r24, Z
    1618:	48 2f       	mov	r20, r24
    161a:	8a 81       	ldd	r24, Y+2	; 0x02
    161c:	28 2f       	mov	r18, r24
    161e:	30 e0       	ldi	r19, 0x00	; 0
    1620:	81 e0       	ldi	r24, 0x01	; 1
    1622:	90 e0       	ldi	r25, 0x00	; 0
    1624:	02 2e       	mov	r0, r18
    1626:	02 c0       	rjmp	.+4      	; 0x162c <DIO_VidSetPinValue+0xa6>
    1628:	88 0f       	add	r24, r24
    162a:	99 1f       	adc	r25, r25
    162c:	0a 94       	dec	r0
    162e:	e2 f7       	brpl	.-8      	; 0x1628 <DIO_VidSetPinValue+0xa2>
    1630:	84 2b       	or	r24, r20
    1632:	8c 93       	st	X, r24
    1634:	9f c0       	rjmp	.+318    	; 0x1774 <DIO_VidSetPinValue+0x1ee>
			case 2:SET_BIT(PORTC, Copy_u8Pin);break;
    1636:	a5 e3       	ldi	r26, 0x35	; 53
    1638:	b0 e0       	ldi	r27, 0x00	; 0
    163a:	e5 e3       	ldi	r30, 0x35	; 53
    163c:	f0 e0       	ldi	r31, 0x00	; 0
    163e:	80 81       	ld	r24, Z
    1640:	48 2f       	mov	r20, r24
    1642:	8a 81       	ldd	r24, Y+2	; 0x02
    1644:	28 2f       	mov	r18, r24
    1646:	30 e0       	ldi	r19, 0x00	; 0
    1648:	81 e0       	ldi	r24, 0x01	; 1
    164a:	90 e0       	ldi	r25, 0x00	; 0
    164c:	02 2e       	mov	r0, r18
    164e:	02 c0       	rjmp	.+4      	; 0x1654 <DIO_VidSetPinValue+0xce>
    1650:	88 0f       	add	r24, r24
    1652:	99 1f       	adc	r25, r25
    1654:	0a 94       	dec	r0
    1656:	e2 f7       	brpl	.-8      	; 0x1650 <DIO_VidSetPinValue+0xca>
    1658:	84 2b       	or	r24, r20
    165a:	8c 93       	st	X, r24
    165c:	8b c0       	rjmp	.+278    	; 0x1774 <DIO_VidSetPinValue+0x1ee>
			case 3:SET_BIT(PORTD, Copy_u8Pin);break;
    165e:	a2 e3       	ldi	r26, 0x32	; 50
    1660:	b0 e0       	ldi	r27, 0x00	; 0
    1662:	e2 e3       	ldi	r30, 0x32	; 50
    1664:	f0 e0       	ldi	r31, 0x00	; 0
    1666:	80 81       	ld	r24, Z
    1668:	48 2f       	mov	r20, r24
    166a:	8a 81       	ldd	r24, Y+2	; 0x02
    166c:	28 2f       	mov	r18, r24
    166e:	30 e0       	ldi	r19, 0x00	; 0
    1670:	81 e0       	ldi	r24, 0x01	; 1
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	02 2e       	mov	r0, r18
    1676:	02 c0       	rjmp	.+4      	; 0x167c <DIO_VidSetPinValue+0xf6>
    1678:	88 0f       	add	r24, r24
    167a:	99 1f       	adc	r25, r25
    167c:	0a 94       	dec	r0
    167e:	e2 f7       	brpl	.-8      	; 0x1678 <DIO_VidSetPinValue+0xf2>
    1680:	84 2b       	or	r24, r20
    1682:	8c 93       	st	X, r24
    1684:	77 c0       	rjmp	.+238    	; 0x1774 <DIO_VidSetPinValue+0x1ee>
		}
	}
	else if(Copy_u8Value == 0)
    1686:	8b 81       	ldd	r24, Y+3	; 0x03
    1688:	88 23       	and	r24, r24
    168a:	09 f0       	breq	.+2      	; 0x168e <DIO_VidSetPinValue+0x108>
    168c:	73 c0       	rjmp	.+230    	; 0x1774 <DIO_VidSetPinValue+0x1ee>
	{
		switch(Copy_u8Port)
    168e:	89 81       	ldd	r24, Y+1	; 0x01
    1690:	28 2f       	mov	r18, r24
    1692:	30 e0       	ldi	r19, 0x00	; 0
    1694:	3d 83       	std	Y+5, r19	; 0x05
    1696:	2c 83       	std	Y+4, r18	; 0x04
    1698:	8c 81       	ldd	r24, Y+4	; 0x04
    169a:	9d 81       	ldd	r25, Y+5	; 0x05
    169c:	81 30       	cpi	r24, 0x01	; 1
    169e:	91 05       	cpc	r25, r1
    16a0:	59 f1       	breq	.+86     	; 0x16f8 <DIO_VidSetPinValue+0x172>
    16a2:	2c 81       	ldd	r18, Y+4	; 0x04
    16a4:	3d 81       	ldd	r19, Y+5	; 0x05
    16a6:	22 30       	cpi	r18, 0x02	; 2
    16a8:	31 05       	cpc	r19, r1
    16aa:	2c f4       	brge	.+10     	; 0x16b6 <DIO_VidSetPinValue+0x130>
    16ac:	8c 81       	ldd	r24, Y+4	; 0x04
    16ae:	9d 81       	ldd	r25, Y+5	; 0x05
    16b0:	00 97       	sbiw	r24, 0x00	; 0
    16b2:	69 f0       	breq	.+26     	; 0x16ce <DIO_VidSetPinValue+0x148>
    16b4:	5f c0       	rjmp	.+190    	; 0x1774 <DIO_VidSetPinValue+0x1ee>
    16b6:	2c 81       	ldd	r18, Y+4	; 0x04
    16b8:	3d 81       	ldd	r19, Y+5	; 0x05
    16ba:	22 30       	cpi	r18, 0x02	; 2
    16bc:	31 05       	cpc	r19, r1
    16be:	89 f1       	breq	.+98     	; 0x1722 <DIO_VidSetPinValue+0x19c>
    16c0:	8c 81       	ldd	r24, Y+4	; 0x04
    16c2:	9d 81       	ldd	r25, Y+5	; 0x05
    16c4:	83 30       	cpi	r24, 0x03	; 3
    16c6:	91 05       	cpc	r25, r1
    16c8:	09 f4       	brne	.+2      	; 0x16cc <DIO_VidSetPinValue+0x146>
    16ca:	40 c0       	rjmp	.+128    	; 0x174c <DIO_VidSetPinValue+0x1c6>
    16cc:	53 c0       	rjmp	.+166    	; 0x1774 <DIO_VidSetPinValue+0x1ee>
		{
			case 0:CLEAR_BIT(PORTA, Copy_u8Pin);break;
    16ce:	ab e3       	ldi	r26, 0x3B	; 59
    16d0:	b0 e0       	ldi	r27, 0x00	; 0
    16d2:	eb e3       	ldi	r30, 0x3B	; 59
    16d4:	f0 e0       	ldi	r31, 0x00	; 0
    16d6:	80 81       	ld	r24, Z
    16d8:	48 2f       	mov	r20, r24
    16da:	8a 81       	ldd	r24, Y+2	; 0x02
    16dc:	28 2f       	mov	r18, r24
    16de:	30 e0       	ldi	r19, 0x00	; 0
    16e0:	81 e0       	ldi	r24, 0x01	; 1
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	02 2e       	mov	r0, r18
    16e6:	02 c0       	rjmp	.+4      	; 0x16ec <DIO_VidSetPinValue+0x166>
    16e8:	88 0f       	add	r24, r24
    16ea:	99 1f       	adc	r25, r25
    16ec:	0a 94       	dec	r0
    16ee:	e2 f7       	brpl	.-8      	; 0x16e8 <DIO_VidSetPinValue+0x162>
    16f0:	80 95       	com	r24
    16f2:	84 23       	and	r24, r20
    16f4:	8c 93       	st	X, r24
    16f6:	3e c0       	rjmp	.+124    	; 0x1774 <DIO_VidSetPinValue+0x1ee>
			case 1:CLEAR_BIT(PORTB, Copy_u8Pin);break;
    16f8:	a8 e3       	ldi	r26, 0x38	; 56
    16fa:	b0 e0       	ldi	r27, 0x00	; 0
    16fc:	e8 e3       	ldi	r30, 0x38	; 56
    16fe:	f0 e0       	ldi	r31, 0x00	; 0
    1700:	80 81       	ld	r24, Z
    1702:	48 2f       	mov	r20, r24
    1704:	8a 81       	ldd	r24, Y+2	; 0x02
    1706:	28 2f       	mov	r18, r24
    1708:	30 e0       	ldi	r19, 0x00	; 0
    170a:	81 e0       	ldi	r24, 0x01	; 1
    170c:	90 e0       	ldi	r25, 0x00	; 0
    170e:	02 2e       	mov	r0, r18
    1710:	02 c0       	rjmp	.+4      	; 0x1716 <DIO_VidSetPinValue+0x190>
    1712:	88 0f       	add	r24, r24
    1714:	99 1f       	adc	r25, r25
    1716:	0a 94       	dec	r0
    1718:	e2 f7       	brpl	.-8      	; 0x1712 <DIO_VidSetPinValue+0x18c>
    171a:	80 95       	com	r24
    171c:	84 23       	and	r24, r20
    171e:	8c 93       	st	X, r24
    1720:	29 c0       	rjmp	.+82     	; 0x1774 <DIO_VidSetPinValue+0x1ee>
			case 2:CLEAR_BIT(PORTC, Copy_u8Pin);break;
    1722:	a5 e3       	ldi	r26, 0x35	; 53
    1724:	b0 e0       	ldi	r27, 0x00	; 0
    1726:	e5 e3       	ldi	r30, 0x35	; 53
    1728:	f0 e0       	ldi	r31, 0x00	; 0
    172a:	80 81       	ld	r24, Z
    172c:	48 2f       	mov	r20, r24
    172e:	8a 81       	ldd	r24, Y+2	; 0x02
    1730:	28 2f       	mov	r18, r24
    1732:	30 e0       	ldi	r19, 0x00	; 0
    1734:	81 e0       	ldi	r24, 0x01	; 1
    1736:	90 e0       	ldi	r25, 0x00	; 0
    1738:	02 2e       	mov	r0, r18
    173a:	02 c0       	rjmp	.+4      	; 0x1740 <DIO_VidSetPinValue+0x1ba>
    173c:	88 0f       	add	r24, r24
    173e:	99 1f       	adc	r25, r25
    1740:	0a 94       	dec	r0
    1742:	e2 f7       	brpl	.-8      	; 0x173c <DIO_VidSetPinValue+0x1b6>
    1744:	80 95       	com	r24
    1746:	84 23       	and	r24, r20
    1748:	8c 93       	st	X, r24
    174a:	14 c0       	rjmp	.+40     	; 0x1774 <DIO_VidSetPinValue+0x1ee>
			case 3:CLEAR_BIT(PORTD, Copy_u8Pin);break;
    174c:	a2 e3       	ldi	r26, 0x32	; 50
    174e:	b0 e0       	ldi	r27, 0x00	; 0
    1750:	e2 e3       	ldi	r30, 0x32	; 50
    1752:	f0 e0       	ldi	r31, 0x00	; 0
    1754:	80 81       	ld	r24, Z
    1756:	48 2f       	mov	r20, r24
    1758:	8a 81       	ldd	r24, Y+2	; 0x02
    175a:	28 2f       	mov	r18, r24
    175c:	30 e0       	ldi	r19, 0x00	; 0
    175e:	81 e0       	ldi	r24, 0x01	; 1
    1760:	90 e0       	ldi	r25, 0x00	; 0
    1762:	02 2e       	mov	r0, r18
    1764:	02 c0       	rjmp	.+4      	; 0x176a <DIO_VidSetPinValue+0x1e4>
    1766:	88 0f       	add	r24, r24
    1768:	99 1f       	adc	r25, r25
    176a:	0a 94       	dec	r0
    176c:	e2 f7       	brpl	.-8      	; 0x1766 <DIO_VidSetPinValue+0x1e0>
    176e:	80 95       	com	r24
    1770:	84 23       	and	r24, r20
    1772:	8c 93       	st	X, r24
		}
	}
}
    1774:	27 96       	adiw	r28, 0x07	; 7
    1776:	0f b6       	in	r0, 0x3f	; 63
    1778:	f8 94       	cli
    177a:	de bf       	out	0x3e, r29	; 62
    177c:	0f be       	out	0x3f, r0	; 63
    177e:	cd bf       	out	0x3d, r28	; 61
    1780:	cf 91       	pop	r28
    1782:	df 91       	pop	r29
    1784:	08 95       	ret

00001786 <DIO_VidSetPortDirection>:


void DIO_VidSetPortDirection(u8 Copy_u8Port, u8 copy_u8Direction)
{
    1786:	df 93       	push	r29
    1788:	cf 93       	push	r28
    178a:	00 d0       	rcall	.+0      	; 0x178c <DIO_VidSetPortDirection+0x6>
    178c:	00 d0       	rcall	.+0      	; 0x178e <DIO_VidSetPortDirection+0x8>
    178e:	cd b7       	in	r28, 0x3d	; 61
    1790:	de b7       	in	r29, 0x3e	; 62
    1792:	89 83       	std	Y+1, r24	; 0x01
    1794:	6a 83       	std	Y+2, r22	; 0x02

	switch(Copy_u8Port)
    1796:	89 81       	ldd	r24, Y+1	; 0x01
    1798:	28 2f       	mov	r18, r24
    179a:	30 e0       	ldi	r19, 0x00	; 0
    179c:	3c 83       	std	Y+4, r19	; 0x04
    179e:	2b 83       	std	Y+3, r18	; 0x03
    17a0:	8b 81       	ldd	r24, Y+3	; 0x03
    17a2:	9c 81       	ldd	r25, Y+4	; 0x04
    17a4:	81 30       	cpi	r24, 0x01	; 1
    17a6:	91 05       	cpc	r25, r1
    17a8:	d1 f0       	breq	.+52     	; 0x17de <DIO_VidSetPortDirection+0x58>
    17aa:	2b 81       	ldd	r18, Y+3	; 0x03
    17ac:	3c 81       	ldd	r19, Y+4	; 0x04
    17ae:	22 30       	cpi	r18, 0x02	; 2
    17b0:	31 05       	cpc	r19, r1
    17b2:	2c f4       	brge	.+10     	; 0x17be <DIO_VidSetPortDirection+0x38>
    17b4:	8b 81       	ldd	r24, Y+3	; 0x03
    17b6:	9c 81       	ldd	r25, Y+4	; 0x04
    17b8:	00 97       	sbiw	r24, 0x00	; 0
    17ba:	61 f0       	breq	.+24     	; 0x17d4 <DIO_VidSetPortDirection+0x4e>
    17bc:	1e c0       	rjmp	.+60     	; 0x17fa <DIO_VidSetPortDirection+0x74>
    17be:	2b 81       	ldd	r18, Y+3	; 0x03
    17c0:	3c 81       	ldd	r19, Y+4	; 0x04
    17c2:	22 30       	cpi	r18, 0x02	; 2
    17c4:	31 05       	cpc	r19, r1
    17c6:	81 f0       	breq	.+32     	; 0x17e8 <DIO_VidSetPortDirection+0x62>
    17c8:	8b 81       	ldd	r24, Y+3	; 0x03
    17ca:	9c 81       	ldd	r25, Y+4	; 0x04
    17cc:	83 30       	cpi	r24, 0x03	; 3
    17ce:	91 05       	cpc	r25, r1
    17d0:	81 f0       	breq	.+32     	; 0x17f2 <DIO_VidSetPortDirection+0x6c>
    17d2:	13 c0       	rjmp	.+38     	; 0x17fa <DIO_VidSetPortDirection+0x74>
	{
		case 0:DDRA = copy_u8Direction;break;
    17d4:	ea e3       	ldi	r30, 0x3A	; 58
    17d6:	f0 e0       	ldi	r31, 0x00	; 0
    17d8:	8a 81       	ldd	r24, Y+2	; 0x02
    17da:	80 83       	st	Z, r24
    17dc:	0e c0       	rjmp	.+28     	; 0x17fa <DIO_VidSetPortDirection+0x74>
		case 1:DDRB = copy_u8Direction;break;
    17de:	e7 e3       	ldi	r30, 0x37	; 55
    17e0:	f0 e0       	ldi	r31, 0x00	; 0
    17e2:	8a 81       	ldd	r24, Y+2	; 0x02
    17e4:	80 83       	st	Z, r24
    17e6:	09 c0       	rjmp	.+18     	; 0x17fa <DIO_VidSetPortDirection+0x74>
		case 2:DDRC = copy_u8Direction;break;
    17e8:	e4 e3       	ldi	r30, 0x34	; 52
    17ea:	f0 e0       	ldi	r31, 0x00	; 0
    17ec:	8a 81       	ldd	r24, Y+2	; 0x02
    17ee:	80 83       	st	Z, r24
    17f0:	04 c0       	rjmp	.+8      	; 0x17fa <DIO_VidSetPortDirection+0x74>
		case 3:DDRD = copy_u8Direction;break;
    17f2:	e1 e3       	ldi	r30, 0x31	; 49
    17f4:	f0 e0       	ldi	r31, 0x00	; 0
    17f6:	8a 81       	ldd	r24, Y+2	; 0x02
    17f8:	80 83       	st	Z, r24
	}


}
    17fa:	0f 90       	pop	r0
    17fc:	0f 90       	pop	r0
    17fe:	0f 90       	pop	r0
    1800:	0f 90       	pop	r0
    1802:	cf 91       	pop	r28
    1804:	df 91       	pop	r29
    1806:	08 95       	ret

00001808 <DIO_VidSetPortValue>:

void DIO_VidSetPortValue(u8 Copy_u8Port, u8 Copy_u8Value)
{
    1808:	df 93       	push	r29
    180a:	cf 93       	push	r28
    180c:	00 d0       	rcall	.+0      	; 0x180e <DIO_VidSetPortValue+0x6>
    180e:	00 d0       	rcall	.+0      	; 0x1810 <DIO_VidSetPortValue+0x8>
    1810:	cd b7       	in	r28, 0x3d	; 61
    1812:	de b7       	in	r29, 0x3e	; 62
    1814:	89 83       	std	Y+1, r24	; 0x01
    1816:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8Port)
    1818:	89 81       	ldd	r24, Y+1	; 0x01
    181a:	28 2f       	mov	r18, r24
    181c:	30 e0       	ldi	r19, 0x00	; 0
    181e:	3c 83       	std	Y+4, r19	; 0x04
    1820:	2b 83       	std	Y+3, r18	; 0x03
    1822:	8b 81       	ldd	r24, Y+3	; 0x03
    1824:	9c 81       	ldd	r25, Y+4	; 0x04
    1826:	81 30       	cpi	r24, 0x01	; 1
    1828:	91 05       	cpc	r25, r1
    182a:	d1 f0       	breq	.+52     	; 0x1860 <DIO_VidSetPortValue+0x58>
    182c:	2b 81       	ldd	r18, Y+3	; 0x03
    182e:	3c 81       	ldd	r19, Y+4	; 0x04
    1830:	22 30       	cpi	r18, 0x02	; 2
    1832:	31 05       	cpc	r19, r1
    1834:	2c f4       	brge	.+10     	; 0x1840 <DIO_VidSetPortValue+0x38>
    1836:	8b 81       	ldd	r24, Y+3	; 0x03
    1838:	9c 81       	ldd	r25, Y+4	; 0x04
    183a:	00 97       	sbiw	r24, 0x00	; 0
    183c:	61 f0       	breq	.+24     	; 0x1856 <DIO_VidSetPortValue+0x4e>
    183e:	1e c0       	rjmp	.+60     	; 0x187c <DIO_VidSetPortValue+0x74>
    1840:	2b 81       	ldd	r18, Y+3	; 0x03
    1842:	3c 81       	ldd	r19, Y+4	; 0x04
    1844:	22 30       	cpi	r18, 0x02	; 2
    1846:	31 05       	cpc	r19, r1
    1848:	81 f0       	breq	.+32     	; 0x186a <DIO_VidSetPortValue+0x62>
    184a:	8b 81       	ldd	r24, Y+3	; 0x03
    184c:	9c 81       	ldd	r25, Y+4	; 0x04
    184e:	83 30       	cpi	r24, 0x03	; 3
    1850:	91 05       	cpc	r25, r1
    1852:	81 f0       	breq	.+32     	; 0x1874 <DIO_VidSetPortValue+0x6c>
    1854:	13 c0       	rjmp	.+38     	; 0x187c <DIO_VidSetPortValue+0x74>
	{
		case 0:PORTA = Copy_u8Value;break;
    1856:	eb e3       	ldi	r30, 0x3B	; 59
    1858:	f0 e0       	ldi	r31, 0x00	; 0
    185a:	8a 81       	ldd	r24, Y+2	; 0x02
    185c:	80 83       	st	Z, r24
    185e:	0e c0       	rjmp	.+28     	; 0x187c <DIO_VidSetPortValue+0x74>
		case 1:PORTB = Copy_u8Value;break;
    1860:	e8 e3       	ldi	r30, 0x38	; 56
    1862:	f0 e0       	ldi	r31, 0x00	; 0
    1864:	8a 81       	ldd	r24, Y+2	; 0x02
    1866:	80 83       	st	Z, r24
    1868:	09 c0       	rjmp	.+18     	; 0x187c <DIO_VidSetPortValue+0x74>
		case 2:PORTC = Copy_u8Value;break;
    186a:	e5 e3       	ldi	r30, 0x35	; 53
    186c:	f0 e0       	ldi	r31, 0x00	; 0
    186e:	8a 81       	ldd	r24, Y+2	; 0x02
    1870:	80 83       	st	Z, r24
    1872:	04 c0       	rjmp	.+8      	; 0x187c <DIO_VidSetPortValue+0x74>
		case 3:PORTD = Copy_u8Value;break;
    1874:	e2 e3       	ldi	r30, 0x32	; 50
    1876:	f0 e0       	ldi	r31, 0x00	; 0
    1878:	8a 81       	ldd	r24, Y+2	; 0x02
    187a:	80 83       	st	Z, r24
	}

}
    187c:	0f 90       	pop	r0
    187e:	0f 90       	pop	r0
    1880:	0f 90       	pop	r0
    1882:	0f 90       	pop	r0
    1884:	cf 91       	pop	r28
    1886:	df 91       	pop	r29
    1888:	08 95       	ret

0000188a <DIO_8uGetPinValue>:

u8 DIO_8uGetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin)
{
    188a:	df 93       	push	r29
    188c:	cf 93       	push	r28
    188e:	00 d0       	rcall	.+0      	; 0x1890 <DIO_8uGetPinValue+0x6>
    1890:	00 d0       	rcall	.+0      	; 0x1892 <DIO_8uGetPinValue+0x8>
    1892:	0f 92       	push	r0
    1894:	cd b7       	in	r28, 0x3d	; 61
    1896:	de b7       	in	r29, 0x3e	; 62
    1898:	89 83       	std	Y+1, r24	; 0x01
    189a:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8Port)
    189c:	89 81       	ldd	r24, Y+1	; 0x01
    189e:	28 2f       	mov	r18, r24
    18a0:	30 e0       	ldi	r19, 0x00	; 0
    18a2:	3d 83       	std	Y+5, r19	; 0x05
    18a4:	2c 83       	std	Y+4, r18	; 0x04
    18a6:	4c 81       	ldd	r20, Y+4	; 0x04
    18a8:	5d 81       	ldd	r21, Y+5	; 0x05
    18aa:	41 30       	cpi	r20, 0x01	; 1
    18ac:	51 05       	cpc	r21, r1
    18ae:	49 f1       	breq	.+82     	; 0x1902 <DIO_8uGetPinValue+0x78>
    18b0:	8c 81       	ldd	r24, Y+4	; 0x04
    18b2:	9d 81       	ldd	r25, Y+5	; 0x05
    18b4:	82 30       	cpi	r24, 0x02	; 2
    18b6:	91 05       	cpc	r25, r1
    18b8:	34 f4       	brge	.+12     	; 0x18c6 <DIO_8uGetPinValue+0x3c>
    18ba:	2c 81       	ldd	r18, Y+4	; 0x04
    18bc:	3d 81       	ldd	r19, Y+5	; 0x05
    18be:	21 15       	cp	r18, r1
    18c0:	31 05       	cpc	r19, r1
    18c2:	61 f0       	breq	.+24     	; 0x18dc <DIO_8uGetPinValue+0x52>
    18c4:	57 c0       	rjmp	.+174    	; 0x1974 <DIO_8uGetPinValue+0xea>
    18c6:	4c 81       	ldd	r20, Y+4	; 0x04
    18c8:	5d 81       	ldd	r21, Y+5	; 0x05
    18ca:	42 30       	cpi	r20, 0x02	; 2
    18cc:	51 05       	cpc	r21, r1
    18ce:	61 f1       	breq	.+88     	; 0x1928 <DIO_8uGetPinValue+0x9e>
    18d0:	8c 81       	ldd	r24, Y+4	; 0x04
    18d2:	9d 81       	ldd	r25, Y+5	; 0x05
    18d4:	83 30       	cpi	r24, 0x03	; 3
    18d6:	91 05       	cpc	r25, r1
    18d8:	d1 f1       	breq	.+116    	; 0x194e <DIO_8uGetPinValue+0xc4>
    18da:	4c c0       	rjmp	.+152    	; 0x1974 <DIO_8uGetPinValue+0xea>
	{
		case 0: return READ_BIT(PINA,Copy_u8Pin) ;break;
    18dc:	e9 e3       	ldi	r30, 0x39	; 57
    18de:	f0 e0       	ldi	r31, 0x00	; 0
    18e0:	80 81       	ld	r24, Z
    18e2:	28 2f       	mov	r18, r24
    18e4:	30 e0       	ldi	r19, 0x00	; 0
    18e6:	8a 81       	ldd	r24, Y+2	; 0x02
    18e8:	88 2f       	mov	r24, r24
    18ea:	90 e0       	ldi	r25, 0x00	; 0
    18ec:	a9 01       	movw	r20, r18
    18ee:	02 c0       	rjmp	.+4      	; 0x18f4 <DIO_8uGetPinValue+0x6a>
    18f0:	55 95       	asr	r21
    18f2:	47 95       	ror	r20
    18f4:	8a 95       	dec	r24
    18f6:	e2 f7       	brpl	.-8      	; 0x18f0 <DIO_8uGetPinValue+0x66>
    18f8:	ca 01       	movw	r24, r20
    18fa:	58 2f       	mov	r21, r24
    18fc:	51 70       	andi	r21, 0x01	; 1
    18fe:	5b 83       	std	Y+3, r21	; 0x03
    1900:	3a c0       	rjmp	.+116    	; 0x1976 <DIO_8uGetPinValue+0xec>
		case 1: return READ_BIT(PINB,Copy_u8Pin) ;break;
    1902:	e6 e3       	ldi	r30, 0x36	; 54
    1904:	f0 e0       	ldi	r31, 0x00	; 0
    1906:	80 81       	ld	r24, Z
    1908:	28 2f       	mov	r18, r24
    190a:	30 e0       	ldi	r19, 0x00	; 0
    190c:	8a 81       	ldd	r24, Y+2	; 0x02
    190e:	88 2f       	mov	r24, r24
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	a9 01       	movw	r20, r18
    1914:	02 c0       	rjmp	.+4      	; 0x191a <DIO_8uGetPinValue+0x90>
    1916:	55 95       	asr	r21
    1918:	47 95       	ror	r20
    191a:	8a 95       	dec	r24
    191c:	e2 f7       	brpl	.-8      	; 0x1916 <DIO_8uGetPinValue+0x8c>
    191e:	ca 01       	movw	r24, r20
    1920:	58 2f       	mov	r21, r24
    1922:	51 70       	andi	r21, 0x01	; 1
    1924:	5b 83       	std	Y+3, r21	; 0x03
    1926:	27 c0       	rjmp	.+78     	; 0x1976 <DIO_8uGetPinValue+0xec>
		case 2: return READ_BIT(PINC,Copy_u8Pin) ;break;
    1928:	e3 e3       	ldi	r30, 0x33	; 51
    192a:	f0 e0       	ldi	r31, 0x00	; 0
    192c:	80 81       	ld	r24, Z
    192e:	28 2f       	mov	r18, r24
    1930:	30 e0       	ldi	r19, 0x00	; 0
    1932:	8a 81       	ldd	r24, Y+2	; 0x02
    1934:	88 2f       	mov	r24, r24
    1936:	90 e0       	ldi	r25, 0x00	; 0
    1938:	a9 01       	movw	r20, r18
    193a:	02 c0       	rjmp	.+4      	; 0x1940 <DIO_8uGetPinValue+0xb6>
    193c:	55 95       	asr	r21
    193e:	47 95       	ror	r20
    1940:	8a 95       	dec	r24
    1942:	e2 f7       	brpl	.-8      	; 0x193c <DIO_8uGetPinValue+0xb2>
    1944:	ca 01       	movw	r24, r20
    1946:	58 2f       	mov	r21, r24
    1948:	51 70       	andi	r21, 0x01	; 1
    194a:	5b 83       	std	Y+3, r21	; 0x03
    194c:	14 c0       	rjmp	.+40     	; 0x1976 <DIO_8uGetPinValue+0xec>
		case 3: return READ_BIT(PIND,Copy_u8Pin) ;break;
    194e:	e0 e3       	ldi	r30, 0x30	; 48
    1950:	f0 e0       	ldi	r31, 0x00	; 0
    1952:	80 81       	ld	r24, Z
    1954:	28 2f       	mov	r18, r24
    1956:	30 e0       	ldi	r19, 0x00	; 0
    1958:	8a 81       	ldd	r24, Y+2	; 0x02
    195a:	88 2f       	mov	r24, r24
    195c:	90 e0       	ldi	r25, 0x00	; 0
    195e:	a9 01       	movw	r20, r18
    1960:	02 c0       	rjmp	.+4      	; 0x1966 <DIO_8uGetPinValue+0xdc>
    1962:	55 95       	asr	r21
    1964:	47 95       	ror	r20
    1966:	8a 95       	dec	r24
    1968:	e2 f7       	brpl	.-8      	; 0x1962 <DIO_8uGetPinValue+0xd8>
    196a:	ca 01       	movw	r24, r20
    196c:	58 2f       	mov	r21, r24
    196e:	51 70       	andi	r21, 0x01	; 1
    1970:	5b 83       	std	Y+3, r21	; 0x03
    1972:	01 c0       	rjmp	.+2      	; 0x1976 <DIO_8uGetPinValue+0xec>
	}
	return 0;
    1974:	1b 82       	std	Y+3, r1	; 0x03
    1976:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1978:	0f 90       	pop	r0
    197a:	0f 90       	pop	r0
    197c:	0f 90       	pop	r0
    197e:	0f 90       	pop	r0
    1980:	0f 90       	pop	r0
    1982:	cf 91       	pop	r28
    1984:	df 91       	pop	r29
    1986:	08 95       	ret

00001988 <DIO_VidTogglePin>:

void DIO_VidTogglePin(u8 Copy_u8Port, u8 Copy_u8Pin)
{
    1988:	df 93       	push	r29
    198a:	cf 93       	push	r28
    198c:	00 d0       	rcall	.+0      	; 0x198e <DIO_VidTogglePin+0x6>
    198e:	00 d0       	rcall	.+0      	; 0x1990 <DIO_VidTogglePin+0x8>
    1990:	cd b7       	in	r28, 0x3d	; 61
    1992:	de b7       	in	r29, 0x3e	; 62
    1994:	89 83       	std	Y+1, r24	; 0x01
    1996:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8Port)
    1998:	89 81       	ldd	r24, Y+1	; 0x01
    199a:	28 2f       	mov	r18, r24
    199c:	30 e0       	ldi	r19, 0x00	; 0
    199e:	3c 83       	std	Y+4, r19	; 0x04
    19a0:	2b 83       	std	Y+3, r18	; 0x03
    19a2:	8b 81       	ldd	r24, Y+3	; 0x03
    19a4:	9c 81       	ldd	r25, Y+4	; 0x04
    19a6:	81 30       	cpi	r24, 0x01	; 1
    19a8:	91 05       	cpc	r25, r1
    19aa:	49 f1       	breq	.+82     	; 0x19fe <DIO_VidTogglePin+0x76>
    19ac:	2b 81       	ldd	r18, Y+3	; 0x03
    19ae:	3c 81       	ldd	r19, Y+4	; 0x04
    19b0:	22 30       	cpi	r18, 0x02	; 2
    19b2:	31 05       	cpc	r19, r1
    19b4:	2c f4       	brge	.+10     	; 0x19c0 <DIO_VidTogglePin+0x38>
    19b6:	8b 81       	ldd	r24, Y+3	; 0x03
    19b8:	9c 81       	ldd	r25, Y+4	; 0x04
    19ba:	00 97       	sbiw	r24, 0x00	; 0
    19bc:	61 f0       	breq	.+24     	; 0x19d6 <DIO_VidTogglePin+0x4e>
    19be:	5a c0       	rjmp	.+180    	; 0x1a74 <DIO_VidTogglePin+0xec>
    19c0:	2b 81       	ldd	r18, Y+3	; 0x03
    19c2:	3c 81       	ldd	r19, Y+4	; 0x04
    19c4:	22 30       	cpi	r18, 0x02	; 2
    19c6:	31 05       	cpc	r19, r1
    19c8:	71 f1       	breq	.+92     	; 0x1a26 <DIO_VidTogglePin+0x9e>
    19ca:	8b 81       	ldd	r24, Y+3	; 0x03
    19cc:	9c 81       	ldd	r25, Y+4	; 0x04
    19ce:	83 30       	cpi	r24, 0x03	; 3
    19d0:	91 05       	cpc	r25, r1
    19d2:	e9 f1       	breq	.+122    	; 0x1a4e <DIO_VidTogglePin+0xc6>
    19d4:	4f c0       	rjmp	.+158    	; 0x1a74 <DIO_VidTogglePin+0xec>
		{
			case 0:  TOGGLE_BIT(PORTA,Copy_u8Pin) ;break;
    19d6:	ab e3       	ldi	r26, 0x3B	; 59
    19d8:	b0 e0       	ldi	r27, 0x00	; 0
    19da:	eb e3       	ldi	r30, 0x3B	; 59
    19dc:	f0 e0       	ldi	r31, 0x00	; 0
    19de:	80 81       	ld	r24, Z
    19e0:	48 2f       	mov	r20, r24
    19e2:	8a 81       	ldd	r24, Y+2	; 0x02
    19e4:	28 2f       	mov	r18, r24
    19e6:	30 e0       	ldi	r19, 0x00	; 0
    19e8:	81 e0       	ldi	r24, 0x01	; 1
    19ea:	90 e0       	ldi	r25, 0x00	; 0
    19ec:	02 2e       	mov	r0, r18
    19ee:	02 c0       	rjmp	.+4      	; 0x19f4 <DIO_VidTogglePin+0x6c>
    19f0:	88 0f       	add	r24, r24
    19f2:	99 1f       	adc	r25, r25
    19f4:	0a 94       	dec	r0
    19f6:	e2 f7       	brpl	.-8      	; 0x19f0 <DIO_VidTogglePin+0x68>
    19f8:	84 27       	eor	r24, r20
    19fa:	8c 93       	st	X, r24
    19fc:	3b c0       	rjmp	.+118    	; 0x1a74 <DIO_VidTogglePin+0xec>
			case 1:  TOGGLE_BIT(PORTB,Copy_u8Pin) ;break;
    19fe:	a8 e3       	ldi	r26, 0x38	; 56
    1a00:	b0 e0       	ldi	r27, 0x00	; 0
    1a02:	e8 e3       	ldi	r30, 0x38	; 56
    1a04:	f0 e0       	ldi	r31, 0x00	; 0
    1a06:	80 81       	ld	r24, Z
    1a08:	48 2f       	mov	r20, r24
    1a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a0c:	28 2f       	mov	r18, r24
    1a0e:	30 e0       	ldi	r19, 0x00	; 0
    1a10:	81 e0       	ldi	r24, 0x01	; 1
    1a12:	90 e0       	ldi	r25, 0x00	; 0
    1a14:	02 2e       	mov	r0, r18
    1a16:	02 c0       	rjmp	.+4      	; 0x1a1c <DIO_VidTogglePin+0x94>
    1a18:	88 0f       	add	r24, r24
    1a1a:	99 1f       	adc	r25, r25
    1a1c:	0a 94       	dec	r0
    1a1e:	e2 f7       	brpl	.-8      	; 0x1a18 <DIO_VidTogglePin+0x90>
    1a20:	84 27       	eor	r24, r20
    1a22:	8c 93       	st	X, r24
    1a24:	27 c0       	rjmp	.+78     	; 0x1a74 <DIO_VidTogglePin+0xec>
			case 2:  TOGGLE_BIT(PORTC,Copy_u8Pin) ;break;
    1a26:	a5 e3       	ldi	r26, 0x35	; 53
    1a28:	b0 e0       	ldi	r27, 0x00	; 0
    1a2a:	e5 e3       	ldi	r30, 0x35	; 53
    1a2c:	f0 e0       	ldi	r31, 0x00	; 0
    1a2e:	80 81       	ld	r24, Z
    1a30:	48 2f       	mov	r20, r24
    1a32:	8a 81       	ldd	r24, Y+2	; 0x02
    1a34:	28 2f       	mov	r18, r24
    1a36:	30 e0       	ldi	r19, 0x00	; 0
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	90 e0       	ldi	r25, 0x00	; 0
    1a3c:	02 2e       	mov	r0, r18
    1a3e:	02 c0       	rjmp	.+4      	; 0x1a44 <DIO_VidTogglePin+0xbc>
    1a40:	88 0f       	add	r24, r24
    1a42:	99 1f       	adc	r25, r25
    1a44:	0a 94       	dec	r0
    1a46:	e2 f7       	brpl	.-8      	; 0x1a40 <DIO_VidTogglePin+0xb8>
    1a48:	84 27       	eor	r24, r20
    1a4a:	8c 93       	st	X, r24
    1a4c:	13 c0       	rjmp	.+38     	; 0x1a74 <DIO_VidTogglePin+0xec>
			case 3:  TOGGLE_BIT(PORTD,Copy_u8Pin) ;break;
    1a4e:	a2 e3       	ldi	r26, 0x32	; 50
    1a50:	b0 e0       	ldi	r27, 0x00	; 0
    1a52:	e2 e3       	ldi	r30, 0x32	; 50
    1a54:	f0 e0       	ldi	r31, 0x00	; 0
    1a56:	80 81       	ld	r24, Z
    1a58:	48 2f       	mov	r20, r24
    1a5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a5c:	28 2f       	mov	r18, r24
    1a5e:	30 e0       	ldi	r19, 0x00	; 0
    1a60:	81 e0       	ldi	r24, 0x01	; 1
    1a62:	90 e0       	ldi	r25, 0x00	; 0
    1a64:	02 2e       	mov	r0, r18
    1a66:	02 c0       	rjmp	.+4      	; 0x1a6c <DIO_VidTogglePin+0xe4>
    1a68:	88 0f       	add	r24, r24
    1a6a:	99 1f       	adc	r25, r25
    1a6c:	0a 94       	dec	r0
    1a6e:	e2 f7       	brpl	.-8      	; 0x1a68 <DIO_VidTogglePin+0xe0>
    1a70:	84 27       	eor	r24, r20
    1a72:	8c 93       	st	X, r24
		}

}
    1a74:	0f 90       	pop	r0
    1a76:	0f 90       	pop	r0
    1a78:	0f 90       	pop	r0
    1a7a:	0f 90       	pop	r0
    1a7c:	cf 91       	pop	r28
    1a7e:	df 91       	pop	r29
    1a80:	08 95       	ret

00001a82 <ADC_VidInit>:
#include "../../LIB/BIT_MATH.h"
#include "../../LIB/STD_TYPES.h"
#include <avr/io.h>

void ADC_VidInit(void)
{
    1a82:	df 93       	push	r29
    1a84:	cf 93       	push	r28
    1a86:	cd b7       	in	r28, 0x3d	; 61
    1a88:	de b7       	in	r29, 0x3e	; 62
	/*select voltage reference 2.56v*/
	SET_BIT(ADMUX,REFS1);
    1a8a:	a7 e2       	ldi	r26, 0x27	; 39
    1a8c:	b0 e0       	ldi	r27, 0x00	; 0
    1a8e:	e7 e2       	ldi	r30, 0x27	; 39
    1a90:	f0 e0       	ldi	r31, 0x00	; 0
    1a92:	80 81       	ld	r24, Z
    1a94:	80 68       	ori	r24, 0x80	; 128
    1a96:	8c 93       	st	X, r24
	SET_BIT(ADMUX,REFS0);
    1a98:	a7 e2       	ldi	r26, 0x27	; 39
    1a9a:	b0 e0       	ldi	r27, 0x00	; 0
    1a9c:	e7 e2       	ldi	r30, 0x27	; 39
    1a9e:	f0 e0       	ldi	r31, 0x00	; 0
    1aa0:	80 81       	ld	r24, Z
    1aa2:	80 64       	ori	r24, 0x40	; 64
    1aa4:	8c 93       	st	X, r24
	/*Right*/
	CLEAR_BIT(ADMUX,ADLAR);
    1aa6:	a7 e2       	ldi	r26, 0x27	; 39
    1aa8:	b0 e0       	ldi	r27, 0x00	; 0
    1aaa:	e7 e2       	ldi	r30, 0x27	; 39
    1aac:	f0 e0       	ldi	r31, 0x00	; 0
    1aae:	80 81       	ld	r24, Z
    1ab0:	8f 7d       	andi	r24, 0xDF	; 223
    1ab2:	8c 93       	st	X, r24
	/*Disable auto trigger*/
	CLEAR_BIT(ADCSRA,ADATE);
    1ab4:	a6 e2       	ldi	r26, 0x26	; 38
    1ab6:	b0 e0       	ldi	r27, 0x00	; 0
    1ab8:	e6 e2       	ldi	r30, 0x26	; 38
    1aba:	f0 e0       	ldi	r31, 0x00	; 0
    1abc:	80 81       	ld	r24, Z
    1abe:	8f 7d       	andi	r24, 0xDF	; 223
    1ac0:	8c 93       	st	X, r24
	/*Division factor*/
	CLEAR_BIT(ADCSRA,ADPS0);
    1ac2:	a6 e2       	ldi	r26, 0x26	; 38
    1ac4:	b0 e0       	ldi	r27, 0x00	; 0
    1ac6:	e6 e2       	ldi	r30, 0x26	; 38
    1ac8:	f0 e0       	ldi	r31, 0x00	; 0
    1aca:	80 81       	ld	r24, Z
    1acc:	8e 7f       	andi	r24, 0xFE	; 254
    1ace:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADPS1);
    1ad0:	a6 e2       	ldi	r26, 0x26	; 38
    1ad2:	b0 e0       	ldi	r27, 0x00	; 0
    1ad4:	e6 e2       	ldi	r30, 0x26	; 38
    1ad6:	f0 e0       	ldi	r31, 0x00	; 0
    1ad8:	80 81       	ld	r24, Z
    1ada:	82 60       	ori	r24, 0x02	; 2
    1adc:	8c 93       	st	X, r24
	SET_BIT(ADCSRA,ADPS2);
    1ade:	a6 e2       	ldi	r26, 0x26	; 38
    1ae0:	b0 e0       	ldi	r27, 0x00	; 0
    1ae2:	e6 e2       	ldi	r30, 0x26	; 38
    1ae4:	f0 e0       	ldi	r31, 0x00	; 0
    1ae6:	80 81       	ld	r24, Z
    1ae8:	84 60       	ori	r24, 0x04	; 4
    1aea:	8c 93       	st	X, r24
	/*ADC Enable*/
	SET_BIT(ADCSRA,ADEN);
    1aec:	a6 e2       	ldi	r26, 0x26	; 38
    1aee:	b0 e0       	ldi	r27, 0x00	; 0
    1af0:	e6 e2       	ldi	r30, 0x26	; 38
    1af2:	f0 e0       	ldi	r31, 0x00	; 0
    1af4:	80 81       	ld	r24, Z
    1af6:	80 68       	ori	r24, 0x80	; 128
    1af8:	8c 93       	st	X, r24
}
    1afa:	cf 91       	pop	r28
    1afc:	df 91       	pop	r29
    1afe:	08 95       	ret

00001b00 <ADC_u16GetDigitalValue>:

uint16 ADC_u16GetDigitalValue(u8 Copy_CannleNum)
{
    1b00:	df 93       	push	r29
    1b02:	cf 93       	push	r28
    1b04:	00 d0       	rcall	.+0      	; 0x1b06 <ADC_u16GetDigitalValue+0x6>
    1b06:	0f 92       	push	r0
    1b08:	cd b7       	in	r28, 0x3d	; 61
    1b0a:	de b7       	in	r29, 0x3e	; 62
    1b0c:	8b 83       	std	Y+3, r24	; 0x03
	uint16 l_adc_value;
	ADMUX &=0xE0;
    1b0e:	a7 e2       	ldi	r26, 0x27	; 39
    1b10:	b0 e0       	ldi	r27, 0x00	; 0
    1b12:	e7 e2       	ldi	r30, 0x27	; 39
    1b14:	f0 e0       	ldi	r31, 0x00	; 0
    1b16:	80 81       	ld	r24, Z
    1b18:	80 7e       	andi	r24, 0xE0	; 224
    1b1a:	8c 93       	st	X, r24
	/*select channel num*/
	ADMUX|=Copy_CannleNum;
    1b1c:	a7 e2       	ldi	r26, 0x27	; 39
    1b1e:	b0 e0       	ldi	r27, 0x00	; 0
    1b20:	e7 e2       	ldi	r30, 0x27	; 39
    1b22:	f0 e0       	ldi	r31, 0x00	; 0
    1b24:	90 81       	ld	r25, Z
    1b26:	8b 81       	ldd	r24, Y+3	; 0x03
    1b28:	89 2b       	or	r24, r25
    1b2a:	8c 93       	st	X, r24
	/*start conversion*/
	SET_BIT(ADCSRA,ADSC);
    1b2c:	a6 e2       	ldi	r26, 0x26	; 38
    1b2e:	b0 e0       	ldi	r27, 0x00	; 0
    1b30:	e6 e2       	ldi	r30, 0x26	; 38
    1b32:	f0 e0       	ldi	r31, 0x00	; 0
    1b34:	80 81       	ld	r24, Z
    1b36:	80 64       	ori	r24, 0x40	; 64
    1b38:	8c 93       	st	X, r24

	while(!READ_BIT(ADCSRA,ADIF));
    1b3a:	e6 e2       	ldi	r30, 0x26	; 38
    1b3c:	f0 e0       	ldi	r31, 0x00	; 0
    1b3e:	80 81       	ld	r24, Z
    1b40:	82 95       	swap	r24
    1b42:	8f 70       	andi	r24, 0x0F	; 15
    1b44:	88 2f       	mov	r24, r24
    1b46:	90 e0       	ldi	r25, 0x00	; 0
    1b48:	81 70       	andi	r24, 0x01	; 1
    1b4a:	90 70       	andi	r25, 0x00	; 0
    1b4c:	00 97       	sbiw	r24, 0x00	; 0
    1b4e:	a9 f3       	breq	.-22     	; 0x1b3a <ADC_u16GetDigitalValue+0x3a>

	/*flag = 0*/
	SET_BIT(ADCSRA,ADIF);
    1b50:	a6 e2       	ldi	r26, 0x26	; 38
    1b52:	b0 e0       	ldi	r27, 0x00	; 0
    1b54:	e6 e2       	ldi	r30, 0x26	; 38
    1b56:	f0 e0       	ldi	r31, 0x00	; 0
    1b58:	80 81       	ld	r24, Z
    1b5a:	80 61       	ori	r24, 0x10	; 16
    1b5c:	8c 93       	st	X, r24

	l_adc_value = ADC_REG;
    1b5e:	e4 e2       	ldi	r30, 0x24	; 36
    1b60:	f0 e0       	ldi	r31, 0x00	; 0
    1b62:	80 81       	ld	r24, Z
    1b64:	91 81       	ldd	r25, Z+1	; 0x01
    1b66:	9a 83       	std	Y+2, r25	; 0x02
    1b68:	89 83       	std	Y+1, r24	; 0x01

return l_adc_value;
    1b6a:	89 81       	ldd	r24, Y+1	; 0x01
    1b6c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1b6e:	0f 90       	pop	r0
    1b70:	0f 90       	pop	r0
    1b72:	0f 90       	pop	r0
    1b74:	cf 91       	pop	r28
    1b76:	df 91       	pop	r29
    1b78:	08 95       	ret

00001b7a <STEP_Init_Vid>:
#include "avr/io.h"



void STEP_Init_Vid(void)
{
    1b7a:	df 93       	push	r29
    1b7c:	cf 93       	push	r28
    1b7e:	cd b7       	in	r28, 0x3d	; 61
    1b80:	de b7       	in	r29, 0x3e	; 62
	DIO_VidSetPinDirection(STEP_PORT,STEP_COIL_BLUE, DIO_OUT);
    1b82:	82 e0       	ldi	r24, 0x02	; 2
    1b84:	60 e0       	ldi	r22, 0x00	; 0
    1b86:	41 e0       	ldi	r20, 0x01	; 1
    1b88:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>
	DIO_VidSetPinDirection(STEP_PORT,STEP_COIL_ORANGE, DIO_OUT);
    1b8c:	82 e0       	ldi	r24, 0x02	; 2
    1b8e:	63 e0       	ldi	r22, 0x03	; 3
    1b90:	41 e0       	ldi	r20, 0x01	; 1
    1b92:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>
	DIO_VidSetPinDirection(STEP_PORT,STEP_COIL_PINK, DIO_OUT);
    1b96:	82 e0       	ldi	r24, 0x02	; 2
    1b98:	61 e0       	ldi	r22, 0x01	; 1
    1b9a:	41 e0       	ldi	r20, 0x01	; 1
    1b9c:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>
	DIO_VidSetPinDirection(STEP_PORT,STEP_COIL_YELLOW, DIO_OUT);
    1ba0:	82 e0       	ldi	r24, 0x02	; 2
    1ba2:	62 e0       	ldi	r22, 0x02	; 2
    1ba4:	41 e0       	ldi	r20, 0x01	; 1
    1ba6:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>
	DIO_VidSetPinValue(STEP_PORT,STEP_COIL_BLUE,DIO_OUT);
    1baa:	82 e0       	ldi	r24, 0x02	; 2
    1bac:	60 e0       	ldi	r22, 0x00	; 0
    1bae:	41 e0       	ldi	r20, 0x01	; 1
    1bb0:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
	DIO_VidSetPinValue(STEP_PORT,STEP_COIL_ORANGE, DIO_LOW);
    1bb4:	82 e0       	ldi	r24, 0x02	; 2
    1bb6:	63 e0       	ldi	r22, 0x03	; 3
    1bb8:	40 e0       	ldi	r20, 0x00	; 0
    1bba:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
	DIO_VidSetPinValue(STEP_PORT,STEP_COIL_PINK, DIO_LOW);
    1bbe:	82 e0       	ldi	r24, 0x02	; 2
    1bc0:	61 e0       	ldi	r22, 0x01	; 1
    1bc2:	40 e0       	ldi	r20, 0x00	; 0
    1bc4:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
	DIO_VidSetPinValue(STEP_PORT,STEP_COIL_YELLOW, DIO_LOW);
    1bc8:	82 e0       	ldi	r24, 0x02	; 2
    1bca:	62 e0       	ldi	r22, 0x02	; 2
    1bcc:	40 e0       	ldi	r20, 0x00	; 0
    1bce:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>

}
    1bd2:	cf 91       	pop	r28
    1bd4:	df 91       	pop	r29
    1bd6:	08 95       	ret

00001bd8 <STEP_HCW_Vid>:

void STEP_HCW_Vid(void)
{
    1bd8:	0f 93       	push	r16
    1bda:	1f 93       	push	r17
    1bdc:	df 93       	push	r29
    1bde:	cf 93       	push	r28
    1be0:	cd b7       	in	r28, 0x3d	; 61
    1be2:	de b7       	in	r29, 0x3e	; 62
    1be4:	c0 57       	subi	r28, 0x70	; 112
    1be6:	d0 40       	sbci	r29, 0x00	; 0
    1be8:	0f b6       	in	r0, 0x3f	; 63
    1bea:	f8 94       	cli
    1bec:	de bf       	out	0x3e, r29	; 62
    1bee:	0f be       	out	0x3f, r0	; 63
    1bf0:	cd bf       	out	0x3d, r28	; 61
	DIO_VidSetPinValue(STEP_PORT, STEP_COIL_BLUE, DIO_HIGH);
    1bf2:	82 e0       	ldi	r24, 0x02	; 2
    1bf4:	60 e0       	ldi	r22, 0x00	; 0
    1bf6:	41 e0       	ldi	r20, 0x01	; 1
    1bf8:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
	DIO_VidSetPinValue(STEP_PORT, STEP_COIL_ORANGE, DIO_HIGH);
    1bfc:	82 e0       	ldi	r24, 0x02	; 2
    1bfe:	63 e0       	ldi	r22, 0x03	; 3
    1c00:	41 e0       	ldi	r20, 0x01	; 1
    1c02:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
    1c06:	fe 01       	movw	r30, r28
    1c08:	e3 59       	subi	r30, 0x93	; 147
    1c0a:	ff 4f       	sbci	r31, 0xFF	; 255
    1c0c:	80 e0       	ldi	r24, 0x00	; 0
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	a6 e9       	ldi	r26, 0x96	; 150
    1c12:	b3 e4       	ldi	r27, 0x43	; 67
    1c14:	80 83       	st	Z, r24
    1c16:	91 83       	std	Z+1, r25	; 0x01
    1c18:	a2 83       	std	Z+2, r26	; 0x02
    1c1a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c1c:	8e 01       	movw	r16, r28
    1c1e:	07 59       	subi	r16, 0x97	; 151
    1c20:	1f 4f       	sbci	r17, 0xFF	; 255
    1c22:	fe 01       	movw	r30, r28
    1c24:	e3 59       	subi	r30, 0x93	; 147
    1c26:	ff 4f       	sbci	r31, 0xFF	; 255
    1c28:	60 81       	ld	r22, Z
    1c2a:	71 81       	ldd	r23, Z+1	; 0x01
    1c2c:	82 81       	ldd	r24, Z+2	; 0x02
    1c2e:	93 81       	ldd	r25, Z+3	; 0x03
    1c30:	20 e0       	ldi	r18, 0x00	; 0
    1c32:	30 e0       	ldi	r19, 0x00	; 0
    1c34:	4a ef       	ldi	r20, 0xFA	; 250
    1c36:	54 e4       	ldi	r21, 0x44	; 68
    1c38:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c3c:	dc 01       	movw	r26, r24
    1c3e:	cb 01       	movw	r24, r22
    1c40:	f8 01       	movw	r30, r16
    1c42:	80 83       	st	Z, r24
    1c44:	91 83       	std	Z+1, r25	; 0x01
    1c46:	a2 83       	std	Z+2, r26	; 0x02
    1c48:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1c4a:	fe 01       	movw	r30, r28
    1c4c:	e7 59       	subi	r30, 0x97	; 151
    1c4e:	ff 4f       	sbci	r31, 0xFF	; 255
    1c50:	60 81       	ld	r22, Z
    1c52:	71 81       	ldd	r23, Z+1	; 0x01
    1c54:	82 81       	ldd	r24, Z+2	; 0x02
    1c56:	93 81       	ldd	r25, Z+3	; 0x03
    1c58:	20 e0       	ldi	r18, 0x00	; 0
    1c5a:	30 e0       	ldi	r19, 0x00	; 0
    1c5c:	40 e8       	ldi	r20, 0x80	; 128
    1c5e:	5f e3       	ldi	r21, 0x3F	; 63
    1c60:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1c64:	88 23       	and	r24, r24
    1c66:	44 f4       	brge	.+16     	; 0x1c78 <STEP_HCW_Vid+0xa0>
		__ticks = 1;
    1c68:	fe 01       	movw	r30, r28
    1c6a:	e9 59       	subi	r30, 0x99	; 153
    1c6c:	ff 4f       	sbci	r31, 0xFF	; 255
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	90 e0       	ldi	r25, 0x00	; 0
    1c72:	91 83       	std	Z+1, r25	; 0x01
    1c74:	80 83       	st	Z, r24
    1c76:	64 c0       	rjmp	.+200    	; 0x1d40 <STEP_HCW_Vid+0x168>
	else if (__tmp > 65535)
    1c78:	fe 01       	movw	r30, r28
    1c7a:	e7 59       	subi	r30, 0x97	; 151
    1c7c:	ff 4f       	sbci	r31, 0xFF	; 255
    1c7e:	60 81       	ld	r22, Z
    1c80:	71 81       	ldd	r23, Z+1	; 0x01
    1c82:	82 81       	ldd	r24, Z+2	; 0x02
    1c84:	93 81       	ldd	r25, Z+3	; 0x03
    1c86:	20 e0       	ldi	r18, 0x00	; 0
    1c88:	3f ef       	ldi	r19, 0xFF	; 255
    1c8a:	4f e7       	ldi	r20, 0x7F	; 127
    1c8c:	57 e4       	ldi	r21, 0x47	; 71
    1c8e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1c92:	18 16       	cp	r1, r24
    1c94:	0c f0       	brlt	.+2      	; 0x1c98 <STEP_HCW_Vid+0xc0>
    1c96:	43 c0       	rjmp	.+134    	; 0x1d1e <STEP_HCW_Vid+0x146>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c98:	fe 01       	movw	r30, r28
    1c9a:	e3 59       	subi	r30, 0x93	; 147
    1c9c:	ff 4f       	sbci	r31, 0xFF	; 255
    1c9e:	60 81       	ld	r22, Z
    1ca0:	71 81       	ldd	r23, Z+1	; 0x01
    1ca2:	82 81       	ldd	r24, Z+2	; 0x02
    1ca4:	93 81       	ldd	r25, Z+3	; 0x03
    1ca6:	20 e0       	ldi	r18, 0x00	; 0
    1ca8:	30 e0       	ldi	r19, 0x00	; 0
    1caa:	40 e2       	ldi	r20, 0x20	; 32
    1cac:	51 e4       	ldi	r21, 0x41	; 65
    1cae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cb2:	dc 01       	movw	r26, r24
    1cb4:	cb 01       	movw	r24, r22
    1cb6:	8e 01       	movw	r16, r28
    1cb8:	09 59       	subi	r16, 0x99	; 153
    1cba:	1f 4f       	sbci	r17, 0xFF	; 255
    1cbc:	bc 01       	movw	r22, r24
    1cbe:	cd 01       	movw	r24, r26
    1cc0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cc4:	dc 01       	movw	r26, r24
    1cc6:	cb 01       	movw	r24, r22
    1cc8:	f8 01       	movw	r30, r16
    1cca:	91 83       	std	Z+1, r25	; 0x01
    1ccc:	80 83       	st	Z, r24
    1cce:	1f c0       	rjmp	.+62     	; 0x1d0e <STEP_HCW_Vid+0x136>
    1cd0:	fe 01       	movw	r30, r28
    1cd2:	eb 59       	subi	r30, 0x9B	; 155
    1cd4:	ff 4f       	sbci	r31, 0xFF	; 255
    1cd6:	88 ec       	ldi	r24, 0xC8	; 200
    1cd8:	90 e0       	ldi	r25, 0x00	; 0
    1cda:	91 83       	std	Z+1, r25	; 0x01
    1cdc:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1cde:	fe 01       	movw	r30, r28
    1ce0:	eb 59       	subi	r30, 0x9B	; 155
    1ce2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ce4:	80 81       	ld	r24, Z
    1ce6:	91 81       	ldd	r25, Z+1	; 0x01
    1ce8:	01 97       	sbiw	r24, 0x01	; 1
    1cea:	f1 f7       	brne	.-4      	; 0x1ce8 <STEP_HCW_Vid+0x110>
    1cec:	fe 01       	movw	r30, r28
    1cee:	eb 59       	subi	r30, 0x9B	; 155
    1cf0:	ff 4f       	sbci	r31, 0xFF	; 255
    1cf2:	91 83       	std	Z+1, r25	; 0x01
    1cf4:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1cf6:	de 01       	movw	r26, r28
    1cf8:	a9 59       	subi	r26, 0x99	; 153
    1cfa:	bf 4f       	sbci	r27, 0xFF	; 255
    1cfc:	fe 01       	movw	r30, r28
    1cfe:	e9 59       	subi	r30, 0x99	; 153
    1d00:	ff 4f       	sbci	r31, 0xFF	; 255
    1d02:	80 81       	ld	r24, Z
    1d04:	91 81       	ldd	r25, Z+1	; 0x01
    1d06:	01 97       	sbiw	r24, 0x01	; 1
    1d08:	11 96       	adiw	r26, 0x01	; 1
    1d0a:	9c 93       	st	X, r25
    1d0c:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d0e:	fe 01       	movw	r30, r28
    1d10:	e9 59       	subi	r30, 0x99	; 153
    1d12:	ff 4f       	sbci	r31, 0xFF	; 255
    1d14:	80 81       	ld	r24, Z
    1d16:	91 81       	ldd	r25, Z+1	; 0x01
    1d18:	00 97       	sbiw	r24, 0x00	; 0
    1d1a:	d1 f6       	brne	.-76     	; 0x1cd0 <STEP_HCW_Vid+0xf8>
    1d1c:	27 c0       	rjmp	.+78     	; 0x1d6c <STEP_HCW_Vid+0x194>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d1e:	8e 01       	movw	r16, r28
    1d20:	09 59       	subi	r16, 0x99	; 153
    1d22:	1f 4f       	sbci	r17, 0xFF	; 255
    1d24:	fe 01       	movw	r30, r28
    1d26:	e7 59       	subi	r30, 0x97	; 151
    1d28:	ff 4f       	sbci	r31, 0xFF	; 255
    1d2a:	60 81       	ld	r22, Z
    1d2c:	71 81       	ldd	r23, Z+1	; 0x01
    1d2e:	82 81       	ldd	r24, Z+2	; 0x02
    1d30:	93 81       	ldd	r25, Z+3	; 0x03
    1d32:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d36:	dc 01       	movw	r26, r24
    1d38:	cb 01       	movw	r24, r22
    1d3a:	f8 01       	movw	r30, r16
    1d3c:	91 83       	std	Z+1, r25	; 0x01
    1d3e:	80 83       	st	Z, r24
    1d40:	de 01       	movw	r26, r28
    1d42:	ad 59       	subi	r26, 0x9D	; 157
    1d44:	bf 4f       	sbci	r27, 0xFF	; 255
    1d46:	fe 01       	movw	r30, r28
    1d48:	e9 59       	subi	r30, 0x99	; 153
    1d4a:	ff 4f       	sbci	r31, 0xFF	; 255
    1d4c:	80 81       	ld	r24, Z
    1d4e:	91 81       	ldd	r25, Z+1	; 0x01
    1d50:	8d 93       	st	X+, r24
    1d52:	9c 93       	st	X, r25
    1d54:	fe 01       	movw	r30, r28
    1d56:	ed 59       	subi	r30, 0x9D	; 157
    1d58:	ff 4f       	sbci	r31, 0xFF	; 255
    1d5a:	80 81       	ld	r24, Z
    1d5c:	91 81       	ldd	r25, Z+1	; 0x01
    1d5e:	01 97       	sbiw	r24, 0x01	; 1
    1d60:	f1 f7       	brne	.-4      	; 0x1d5e <STEP_HCW_Vid+0x186>
    1d62:	fe 01       	movw	r30, r28
    1d64:	ed 59       	subi	r30, 0x9D	; 157
    1d66:	ff 4f       	sbci	r31, 0xFF	; 255
    1d68:	91 83       	std	Z+1, r25	; 0x01
    1d6a:	80 83       	st	Z, r24
	_delay_ms(STEP_DELAY);
	DIO_VidSetPinValue(STEP_PORT, STEP_COIL_ORANGE, DIO_LOW);
    1d6c:	82 e0       	ldi	r24, 0x02	; 2
    1d6e:	63 e0       	ldi	r22, 0x03	; 3
    1d70:	40 e0       	ldi	r20, 0x00	; 0
    1d72:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
    1d76:	fe 01       	movw	r30, r28
    1d78:	e1 5a       	subi	r30, 0xA1	; 161
    1d7a:	ff 4f       	sbci	r31, 0xFF	; 255
    1d7c:	80 e0       	ldi	r24, 0x00	; 0
    1d7e:	90 e0       	ldi	r25, 0x00	; 0
    1d80:	a6 e9       	ldi	r26, 0x96	; 150
    1d82:	b3 e4       	ldi	r27, 0x43	; 67
    1d84:	80 83       	st	Z, r24
    1d86:	91 83       	std	Z+1, r25	; 0x01
    1d88:	a2 83       	std	Z+2, r26	; 0x02
    1d8a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d8c:	8e 01       	movw	r16, r28
    1d8e:	05 5a       	subi	r16, 0xA5	; 165
    1d90:	1f 4f       	sbci	r17, 0xFF	; 255
    1d92:	fe 01       	movw	r30, r28
    1d94:	e1 5a       	subi	r30, 0xA1	; 161
    1d96:	ff 4f       	sbci	r31, 0xFF	; 255
    1d98:	60 81       	ld	r22, Z
    1d9a:	71 81       	ldd	r23, Z+1	; 0x01
    1d9c:	82 81       	ldd	r24, Z+2	; 0x02
    1d9e:	93 81       	ldd	r25, Z+3	; 0x03
    1da0:	20 e0       	ldi	r18, 0x00	; 0
    1da2:	30 e0       	ldi	r19, 0x00	; 0
    1da4:	4a ef       	ldi	r20, 0xFA	; 250
    1da6:	54 e4       	ldi	r21, 0x44	; 68
    1da8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1dac:	dc 01       	movw	r26, r24
    1dae:	cb 01       	movw	r24, r22
    1db0:	f8 01       	movw	r30, r16
    1db2:	80 83       	st	Z, r24
    1db4:	91 83       	std	Z+1, r25	; 0x01
    1db6:	a2 83       	std	Z+2, r26	; 0x02
    1db8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1dba:	fe 01       	movw	r30, r28
    1dbc:	e5 5a       	subi	r30, 0xA5	; 165
    1dbe:	ff 4f       	sbci	r31, 0xFF	; 255
    1dc0:	60 81       	ld	r22, Z
    1dc2:	71 81       	ldd	r23, Z+1	; 0x01
    1dc4:	82 81       	ldd	r24, Z+2	; 0x02
    1dc6:	93 81       	ldd	r25, Z+3	; 0x03
    1dc8:	20 e0       	ldi	r18, 0x00	; 0
    1dca:	30 e0       	ldi	r19, 0x00	; 0
    1dcc:	40 e8       	ldi	r20, 0x80	; 128
    1dce:	5f e3       	ldi	r21, 0x3F	; 63
    1dd0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1dd4:	88 23       	and	r24, r24
    1dd6:	44 f4       	brge	.+16     	; 0x1de8 <STEP_HCW_Vid+0x210>
		__ticks = 1;
    1dd8:	fe 01       	movw	r30, r28
    1dda:	e7 5a       	subi	r30, 0xA7	; 167
    1ddc:	ff 4f       	sbci	r31, 0xFF	; 255
    1dde:	81 e0       	ldi	r24, 0x01	; 1
    1de0:	90 e0       	ldi	r25, 0x00	; 0
    1de2:	91 83       	std	Z+1, r25	; 0x01
    1de4:	80 83       	st	Z, r24
    1de6:	64 c0       	rjmp	.+200    	; 0x1eb0 <STEP_HCW_Vid+0x2d8>
	else if (__tmp > 65535)
    1de8:	fe 01       	movw	r30, r28
    1dea:	e5 5a       	subi	r30, 0xA5	; 165
    1dec:	ff 4f       	sbci	r31, 0xFF	; 255
    1dee:	60 81       	ld	r22, Z
    1df0:	71 81       	ldd	r23, Z+1	; 0x01
    1df2:	82 81       	ldd	r24, Z+2	; 0x02
    1df4:	93 81       	ldd	r25, Z+3	; 0x03
    1df6:	20 e0       	ldi	r18, 0x00	; 0
    1df8:	3f ef       	ldi	r19, 0xFF	; 255
    1dfa:	4f e7       	ldi	r20, 0x7F	; 127
    1dfc:	57 e4       	ldi	r21, 0x47	; 71
    1dfe:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1e02:	18 16       	cp	r1, r24
    1e04:	0c f0       	brlt	.+2      	; 0x1e08 <STEP_HCW_Vid+0x230>
    1e06:	43 c0       	rjmp	.+134    	; 0x1e8e <STEP_HCW_Vid+0x2b6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e08:	fe 01       	movw	r30, r28
    1e0a:	e1 5a       	subi	r30, 0xA1	; 161
    1e0c:	ff 4f       	sbci	r31, 0xFF	; 255
    1e0e:	60 81       	ld	r22, Z
    1e10:	71 81       	ldd	r23, Z+1	; 0x01
    1e12:	82 81       	ldd	r24, Z+2	; 0x02
    1e14:	93 81       	ldd	r25, Z+3	; 0x03
    1e16:	20 e0       	ldi	r18, 0x00	; 0
    1e18:	30 e0       	ldi	r19, 0x00	; 0
    1e1a:	40 e2       	ldi	r20, 0x20	; 32
    1e1c:	51 e4       	ldi	r21, 0x41	; 65
    1e1e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e22:	dc 01       	movw	r26, r24
    1e24:	cb 01       	movw	r24, r22
    1e26:	8e 01       	movw	r16, r28
    1e28:	07 5a       	subi	r16, 0xA7	; 167
    1e2a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e2c:	bc 01       	movw	r22, r24
    1e2e:	cd 01       	movw	r24, r26
    1e30:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e34:	dc 01       	movw	r26, r24
    1e36:	cb 01       	movw	r24, r22
    1e38:	f8 01       	movw	r30, r16
    1e3a:	91 83       	std	Z+1, r25	; 0x01
    1e3c:	80 83       	st	Z, r24
    1e3e:	1f c0       	rjmp	.+62     	; 0x1e7e <STEP_HCW_Vid+0x2a6>
    1e40:	fe 01       	movw	r30, r28
    1e42:	e9 5a       	subi	r30, 0xA9	; 169
    1e44:	ff 4f       	sbci	r31, 0xFF	; 255
    1e46:	88 ec       	ldi	r24, 0xC8	; 200
    1e48:	90 e0       	ldi	r25, 0x00	; 0
    1e4a:	91 83       	std	Z+1, r25	; 0x01
    1e4c:	80 83       	st	Z, r24
    1e4e:	fe 01       	movw	r30, r28
    1e50:	e9 5a       	subi	r30, 0xA9	; 169
    1e52:	ff 4f       	sbci	r31, 0xFF	; 255
    1e54:	80 81       	ld	r24, Z
    1e56:	91 81       	ldd	r25, Z+1	; 0x01
    1e58:	01 97       	sbiw	r24, 0x01	; 1
    1e5a:	f1 f7       	brne	.-4      	; 0x1e58 <STEP_HCW_Vid+0x280>
    1e5c:	fe 01       	movw	r30, r28
    1e5e:	e9 5a       	subi	r30, 0xA9	; 169
    1e60:	ff 4f       	sbci	r31, 0xFF	; 255
    1e62:	91 83       	std	Z+1, r25	; 0x01
    1e64:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e66:	de 01       	movw	r26, r28
    1e68:	a7 5a       	subi	r26, 0xA7	; 167
    1e6a:	bf 4f       	sbci	r27, 0xFF	; 255
    1e6c:	fe 01       	movw	r30, r28
    1e6e:	e7 5a       	subi	r30, 0xA7	; 167
    1e70:	ff 4f       	sbci	r31, 0xFF	; 255
    1e72:	80 81       	ld	r24, Z
    1e74:	91 81       	ldd	r25, Z+1	; 0x01
    1e76:	01 97       	sbiw	r24, 0x01	; 1
    1e78:	11 96       	adiw	r26, 0x01	; 1
    1e7a:	9c 93       	st	X, r25
    1e7c:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e7e:	fe 01       	movw	r30, r28
    1e80:	e7 5a       	subi	r30, 0xA7	; 167
    1e82:	ff 4f       	sbci	r31, 0xFF	; 255
    1e84:	80 81       	ld	r24, Z
    1e86:	91 81       	ldd	r25, Z+1	; 0x01
    1e88:	00 97       	sbiw	r24, 0x00	; 0
    1e8a:	d1 f6       	brne	.-76     	; 0x1e40 <STEP_HCW_Vid+0x268>
    1e8c:	27 c0       	rjmp	.+78     	; 0x1edc <STEP_HCW_Vid+0x304>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e8e:	8e 01       	movw	r16, r28
    1e90:	07 5a       	subi	r16, 0xA7	; 167
    1e92:	1f 4f       	sbci	r17, 0xFF	; 255
    1e94:	fe 01       	movw	r30, r28
    1e96:	e5 5a       	subi	r30, 0xA5	; 165
    1e98:	ff 4f       	sbci	r31, 0xFF	; 255
    1e9a:	60 81       	ld	r22, Z
    1e9c:	71 81       	ldd	r23, Z+1	; 0x01
    1e9e:	82 81       	ldd	r24, Z+2	; 0x02
    1ea0:	93 81       	ldd	r25, Z+3	; 0x03
    1ea2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ea6:	dc 01       	movw	r26, r24
    1ea8:	cb 01       	movw	r24, r22
    1eaa:	f8 01       	movw	r30, r16
    1eac:	91 83       	std	Z+1, r25	; 0x01
    1eae:	80 83       	st	Z, r24
    1eb0:	de 01       	movw	r26, r28
    1eb2:	ab 5a       	subi	r26, 0xAB	; 171
    1eb4:	bf 4f       	sbci	r27, 0xFF	; 255
    1eb6:	fe 01       	movw	r30, r28
    1eb8:	e7 5a       	subi	r30, 0xA7	; 167
    1eba:	ff 4f       	sbci	r31, 0xFF	; 255
    1ebc:	80 81       	ld	r24, Z
    1ebe:	91 81       	ldd	r25, Z+1	; 0x01
    1ec0:	8d 93       	st	X+, r24
    1ec2:	9c 93       	st	X, r25
    1ec4:	fe 01       	movw	r30, r28
    1ec6:	eb 5a       	subi	r30, 0xAB	; 171
    1ec8:	ff 4f       	sbci	r31, 0xFF	; 255
    1eca:	80 81       	ld	r24, Z
    1ecc:	91 81       	ldd	r25, Z+1	; 0x01
    1ece:	01 97       	sbiw	r24, 0x01	; 1
    1ed0:	f1 f7       	brne	.-4      	; 0x1ece <STEP_HCW_Vid+0x2f6>
    1ed2:	fe 01       	movw	r30, r28
    1ed4:	eb 5a       	subi	r30, 0xAB	; 171
    1ed6:	ff 4f       	sbci	r31, 0xFF	; 255
    1ed8:	91 83       	std	Z+1, r25	; 0x01
    1eda:	80 83       	st	Z, r24
	_delay_ms(STEP_DELAY);
	DIO_VidSetPinValue(STEP_PORT, STEP_COIL_PINK, DIO_HIGH);
    1edc:	82 e0       	ldi	r24, 0x02	; 2
    1ede:	61 e0       	ldi	r22, 0x01	; 1
    1ee0:	41 e0       	ldi	r20, 0x01	; 1
    1ee2:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
    1ee6:	fe 01       	movw	r30, r28
    1ee8:	ef 5a       	subi	r30, 0xAF	; 175
    1eea:	ff 4f       	sbci	r31, 0xFF	; 255
    1eec:	80 e0       	ldi	r24, 0x00	; 0
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	a6 e9       	ldi	r26, 0x96	; 150
    1ef2:	b3 e4       	ldi	r27, 0x43	; 67
    1ef4:	80 83       	st	Z, r24
    1ef6:	91 83       	std	Z+1, r25	; 0x01
    1ef8:	a2 83       	std	Z+2, r26	; 0x02
    1efa:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1efc:	8e 01       	movw	r16, r28
    1efe:	03 5b       	subi	r16, 0xB3	; 179
    1f00:	1f 4f       	sbci	r17, 0xFF	; 255
    1f02:	fe 01       	movw	r30, r28
    1f04:	ef 5a       	subi	r30, 0xAF	; 175
    1f06:	ff 4f       	sbci	r31, 0xFF	; 255
    1f08:	60 81       	ld	r22, Z
    1f0a:	71 81       	ldd	r23, Z+1	; 0x01
    1f0c:	82 81       	ldd	r24, Z+2	; 0x02
    1f0e:	93 81       	ldd	r25, Z+3	; 0x03
    1f10:	20 e0       	ldi	r18, 0x00	; 0
    1f12:	30 e0       	ldi	r19, 0x00	; 0
    1f14:	4a ef       	ldi	r20, 0xFA	; 250
    1f16:	54 e4       	ldi	r21, 0x44	; 68
    1f18:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f1c:	dc 01       	movw	r26, r24
    1f1e:	cb 01       	movw	r24, r22
    1f20:	f8 01       	movw	r30, r16
    1f22:	80 83       	st	Z, r24
    1f24:	91 83       	std	Z+1, r25	; 0x01
    1f26:	a2 83       	std	Z+2, r26	; 0x02
    1f28:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1f2a:	fe 01       	movw	r30, r28
    1f2c:	e3 5b       	subi	r30, 0xB3	; 179
    1f2e:	ff 4f       	sbci	r31, 0xFF	; 255
    1f30:	60 81       	ld	r22, Z
    1f32:	71 81       	ldd	r23, Z+1	; 0x01
    1f34:	82 81       	ldd	r24, Z+2	; 0x02
    1f36:	93 81       	ldd	r25, Z+3	; 0x03
    1f38:	20 e0       	ldi	r18, 0x00	; 0
    1f3a:	30 e0       	ldi	r19, 0x00	; 0
    1f3c:	40 e8       	ldi	r20, 0x80	; 128
    1f3e:	5f e3       	ldi	r21, 0x3F	; 63
    1f40:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1f44:	88 23       	and	r24, r24
    1f46:	44 f4       	brge	.+16     	; 0x1f58 <STEP_HCW_Vid+0x380>
		__ticks = 1;
    1f48:	fe 01       	movw	r30, r28
    1f4a:	e5 5b       	subi	r30, 0xB5	; 181
    1f4c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f4e:	81 e0       	ldi	r24, 0x01	; 1
    1f50:	90 e0       	ldi	r25, 0x00	; 0
    1f52:	91 83       	std	Z+1, r25	; 0x01
    1f54:	80 83       	st	Z, r24
    1f56:	64 c0       	rjmp	.+200    	; 0x2020 <STEP_HCW_Vid+0x448>
	else if (__tmp > 65535)
    1f58:	fe 01       	movw	r30, r28
    1f5a:	e3 5b       	subi	r30, 0xB3	; 179
    1f5c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f5e:	60 81       	ld	r22, Z
    1f60:	71 81       	ldd	r23, Z+1	; 0x01
    1f62:	82 81       	ldd	r24, Z+2	; 0x02
    1f64:	93 81       	ldd	r25, Z+3	; 0x03
    1f66:	20 e0       	ldi	r18, 0x00	; 0
    1f68:	3f ef       	ldi	r19, 0xFF	; 255
    1f6a:	4f e7       	ldi	r20, 0x7F	; 127
    1f6c:	57 e4       	ldi	r21, 0x47	; 71
    1f6e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1f72:	18 16       	cp	r1, r24
    1f74:	0c f0       	brlt	.+2      	; 0x1f78 <STEP_HCW_Vid+0x3a0>
    1f76:	43 c0       	rjmp	.+134    	; 0x1ffe <STEP_HCW_Vid+0x426>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f78:	fe 01       	movw	r30, r28
    1f7a:	ef 5a       	subi	r30, 0xAF	; 175
    1f7c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f7e:	60 81       	ld	r22, Z
    1f80:	71 81       	ldd	r23, Z+1	; 0x01
    1f82:	82 81       	ldd	r24, Z+2	; 0x02
    1f84:	93 81       	ldd	r25, Z+3	; 0x03
    1f86:	20 e0       	ldi	r18, 0x00	; 0
    1f88:	30 e0       	ldi	r19, 0x00	; 0
    1f8a:	40 e2       	ldi	r20, 0x20	; 32
    1f8c:	51 e4       	ldi	r21, 0x41	; 65
    1f8e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f92:	dc 01       	movw	r26, r24
    1f94:	cb 01       	movw	r24, r22
    1f96:	8e 01       	movw	r16, r28
    1f98:	05 5b       	subi	r16, 0xB5	; 181
    1f9a:	1f 4f       	sbci	r17, 0xFF	; 255
    1f9c:	bc 01       	movw	r22, r24
    1f9e:	cd 01       	movw	r24, r26
    1fa0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fa4:	dc 01       	movw	r26, r24
    1fa6:	cb 01       	movw	r24, r22
    1fa8:	f8 01       	movw	r30, r16
    1faa:	91 83       	std	Z+1, r25	; 0x01
    1fac:	80 83       	st	Z, r24
    1fae:	1f c0       	rjmp	.+62     	; 0x1fee <STEP_HCW_Vid+0x416>
    1fb0:	fe 01       	movw	r30, r28
    1fb2:	e7 5b       	subi	r30, 0xB7	; 183
    1fb4:	ff 4f       	sbci	r31, 0xFF	; 255
    1fb6:	88 ec       	ldi	r24, 0xC8	; 200
    1fb8:	90 e0       	ldi	r25, 0x00	; 0
    1fba:	91 83       	std	Z+1, r25	; 0x01
    1fbc:	80 83       	st	Z, r24
    1fbe:	fe 01       	movw	r30, r28
    1fc0:	e7 5b       	subi	r30, 0xB7	; 183
    1fc2:	ff 4f       	sbci	r31, 0xFF	; 255
    1fc4:	80 81       	ld	r24, Z
    1fc6:	91 81       	ldd	r25, Z+1	; 0x01
    1fc8:	01 97       	sbiw	r24, 0x01	; 1
    1fca:	f1 f7       	brne	.-4      	; 0x1fc8 <STEP_HCW_Vid+0x3f0>
    1fcc:	fe 01       	movw	r30, r28
    1fce:	e7 5b       	subi	r30, 0xB7	; 183
    1fd0:	ff 4f       	sbci	r31, 0xFF	; 255
    1fd2:	91 83       	std	Z+1, r25	; 0x01
    1fd4:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1fd6:	de 01       	movw	r26, r28
    1fd8:	a5 5b       	subi	r26, 0xB5	; 181
    1fda:	bf 4f       	sbci	r27, 0xFF	; 255
    1fdc:	fe 01       	movw	r30, r28
    1fde:	e5 5b       	subi	r30, 0xB5	; 181
    1fe0:	ff 4f       	sbci	r31, 0xFF	; 255
    1fe2:	80 81       	ld	r24, Z
    1fe4:	91 81       	ldd	r25, Z+1	; 0x01
    1fe6:	01 97       	sbiw	r24, 0x01	; 1
    1fe8:	11 96       	adiw	r26, 0x01	; 1
    1fea:	9c 93       	st	X, r25
    1fec:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1fee:	fe 01       	movw	r30, r28
    1ff0:	e5 5b       	subi	r30, 0xB5	; 181
    1ff2:	ff 4f       	sbci	r31, 0xFF	; 255
    1ff4:	80 81       	ld	r24, Z
    1ff6:	91 81       	ldd	r25, Z+1	; 0x01
    1ff8:	00 97       	sbiw	r24, 0x00	; 0
    1ffa:	d1 f6       	brne	.-76     	; 0x1fb0 <STEP_HCW_Vid+0x3d8>
    1ffc:	27 c0       	rjmp	.+78     	; 0x204c <STEP_HCW_Vid+0x474>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ffe:	8e 01       	movw	r16, r28
    2000:	05 5b       	subi	r16, 0xB5	; 181
    2002:	1f 4f       	sbci	r17, 0xFF	; 255
    2004:	fe 01       	movw	r30, r28
    2006:	e3 5b       	subi	r30, 0xB3	; 179
    2008:	ff 4f       	sbci	r31, 0xFF	; 255
    200a:	60 81       	ld	r22, Z
    200c:	71 81       	ldd	r23, Z+1	; 0x01
    200e:	82 81       	ldd	r24, Z+2	; 0x02
    2010:	93 81       	ldd	r25, Z+3	; 0x03
    2012:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2016:	dc 01       	movw	r26, r24
    2018:	cb 01       	movw	r24, r22
    201a:	f8 01       	movw	r30, r16
    201c:	91 83       	std	Z+1, r25	; 0x01
    201e:	80 83       	st	Z, r24
    2020:	de 01       	movw	r26, r28
    2022:	a9 5b       	subi	r26, 0xB9	; 185
    2024:	bf 4f       	sbci	r27, 0xFF	; 255
    2026:	fe 01       	movw	r30, r28
    2028:	e5 5b       	subi	r30, 0xB5	; 181
    202a:	ff 4f       	sbci	r31, 0xFF	; 255
    202c:	80 81       	ld	r24, Z
    202e:	91 81       	ldd	r25, Z+1	; 0x01
    2030:	8d 93       	st	X+, r24
    2032:	9c 93       	st	X, r25
    2034:	fe 01       	movw	r30, r28
    2036:	e9 5b       	subi	r30, 0xB9	; 185
    2038:	ff 4f       	sbci	r31, 0xFF	; 255
    203a:	80 81       	ld	r24, Z
    203c:	91 81       	ldd	r25, Z+1	; 0x01
    203e:	01 97       	sbiw	r24, 0x01	; 1
    2040:	f1 f7       	brne	.-4      	; 0x203e <STEP_HCW_Vid+0x466>
    2042:	fe 01       	movw	r30, r28
    2044:	e9 5b       	subi	r30, 0xB9	; 185
    2046:	ff 4f       	sbci	r31, 0xFF	; 255
    2048:	91 83       	std	Z+1, r25	; 0x01
    204a:	80 83       	st	Z, r24
	_delay_ms(STEP_DELAY);
	DIO_VidSetPinValue(STEP_PORT, STEP_COIL_BLUE, DIO_LOW);
    204c:	82 e0       	ldi	r24, 0x02	; 2
    204e:	60 e0       	ldi	r22, 0x00	; 0
    2050:	40 e0       	ldi	r20, 0x00	; 0
    2052:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
    2056:	fe 01       	movw	r30, r28
    2058:	ed 5b       	subi	r30, 0xBD	; 189
    205a:	ff 4f       	sbci	r31, 0xFF	; 255
    205c:	80 e0       	ldi	r24, 0x00	; 0
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	a6 e9       	ldi	r26, 0x96	; 150
    2062:	b3 e4       	ldi	r27, 0x43	; 67
    2064:	80 83       	st	Z, r24
    2066:	91 83       	std	Z+1, r25	; 0x01
    2068:	a2 83       	std	Z+2, r26	; 0x02
    206a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    206c:	8e 01       	movw	r16, r28
    206e:	01 5c       	subi	r16, 0xC1	; 193
    2070:	1f 4f       	sbci	r17, 0xFF	; 255
    2072:	fe 01       	movw	r30, r28
    2074:	ed 5b       	subi	r30, 0xBD	; 189
    2076:	ff 4f       	sbci	r31, 0xFF	; 255
    2078:	60 81       	ld	r22, Z
    207a:	71 81       	ldd	r23, Z+1	; 0x01
    207c:	82 81       	ldd	r24, Z+2	; 0x02
    207e:	93 81       	ldd	r25, Z+3	; 0x03
    2080:	20 e0       	ldi	r18, 0x00	; 0
    2082:	30 e0       	ldi	r19, 0x00	; 0
    2084:	4a ef       	ldi	r20, 0xFA	; 250
    2086:	54 e4       	ldi	r21, 0x44	; 68
    2088:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    208c:	dc 01       	movw	r26, r24
    208e:	cb 01       	movw	r24, r22
    2090:	f8 01       	movw	r30, r16
    2092:	80 83       	st	Z, r24
    2094:	91 83       	std	Z+1, r25	; 0x01
    2096:	a2 83       	std	Z+2, r26	; 0x02
    2098:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    209a:	fe 01       	movw	r30, r28
    209c:	ff 96       	adiw	r30, 0x3f	; 63
    209e:	60 81       	ld	r22, Z
    20a0:	71 81       	ldd	r23, Z+1	; 0x01
    20a2:	82 81       	ldd	r24, Z+2	; 0x02
    20a4:	93 81       	ldd	r25, Z+3	; 0x03
    20a6:	20 e0       	ldi	r18, 0x00	; 0
    20a8:	30 e0       	ldi	r19, 0x00	; 0
    20aa:	40 e8       	ldi	r20, 0x80	; 128
    20ac:	5f e3       	ldi	r21, 0x3F	; 63
    20ae:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    20b2:	88 23       	and	r24, r24
    20b4:	2c f4       	brge	.+10     	; 0x20c0 <STEP_HCW_Vid+0x4e8>
		__ticks = 1;
    20b6:	81 e0       	ldi	r24, 0x01	; 1
    20b8:	90 e0       	ldi	r25, 0x00	; 0
    20ba:	9e af       	std	Y+62, r25	; 0x3e
    20bc:	8d af       	std	Y+61, r24	; 0x3d
    20be:	46 c0       	rjmp	.+140    	; 0x214c <STEP_HCW_Vid+0x574>
	else if (__tmp > 65535)
    20c0:	fe 01       	movw	r30, r28
    20c2:	ff 96       	adiw	r30, 0x3f	; 63
    20c4:	60 81       	ld	r22, Z
    20c6:	71 81       	ldd	r23, Z+1	; 0x01
    20c8:	82 81       	ldd	r24, Z+2	; 0x02
    20ca:	93 81       	ldd	r25, Z+3	; 0x03
    20cc:	20 e0       	ldi	r18, 0x00	; 0
    20ce:	3f ef       	ldi	r19, 0xFF	; 255
    20d0:	4f e7       	ldi	r20, 0x7F	; 127
    20d2:	57 e4       	ldi	r21, 0x47	; 71
    20d4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    20d8:	18 16       	cp	r1, r24
    20da:	64 f5       	brge	.+88     	; 0x2134 <STEP_HCW_Vid+0x55c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    20dc:	fe 01       	movw	r30, r28
    20de:	ed 5b       	subi	r30, 0xBD	; 189
    20e0:	ff 4f       	sbci	r31, 0xFF	; 255
    20e2:	60 81       	ld	r22, Z
    20e4:	71 81       	ldd	r23, Z+1	; 0x01
    20e6:	82 81       	ldd	r24, Z+2	; 0x02
    20e8:	93 81       	ldd	r25, Z+3	; 0x03
    20ea:	20 e0       	ldi	r18, 0x00	; 0
    20ec:	30 e0       	ldi	r19, 0x00	; 0
    20ee:	40 e2       	ldi	r20, 0x20	; 32
    20f0:	51 e4       	ldi	r21, 0x41	; 65
    20f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20f6:	dc 01       	movw	r26, r24
    20f8:	cb 01       	movw	r24, r22
    20fa:	bc 01       	movw	r22, r24
    20fc:	cd 01       	movw	r24, r26
    20fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2102:	dc 01       	movw	r26, r24
    2104:	cb 01       	movw	r24, r22
    2106:	9e af       	std	Y+62, r25	; 0x3e
    2108:	8d af       	std	Y+61, r24	; 0x3d
    210a:	0f c0       	rjmp	.+30     	; 0x212a <STEP_HCW_Vid+0x552>
    210c:	88 ec       	ldi	r24, 0xC8	; 200
    210e:	90 e0       	ldi	r25, 0x00	; 0
    2110:	9c af       	std	Y+60, r25	; 0x3c
    2112:	8b af       	std	Y+59, r24	; 0x3b
    2114:	8b ad       	ldd	r24, Y+59	; 0x3b
    2116:	9c ad       	ldd	r25, Y+60	; 0x3c
    2118:	01 97       	sbiw	r24, 0x01	; 1
    211a:	f1 f7       	brne	.-4      	; 0x2118 <STEP_HCW_Vid+0x540>
    211c:	9c af       	std	Y+60, r25	; 0x3c
    211e:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2120:	8d ad       	ldd	r24, Y+61	; 0x3d
    2122:	9e ad       	ldd	r25, Y+62	; 0x3e
    2124:	01 97       	sbiw	r24, 0x01	; 1
    2126:	9e af       	std	Y+62, r25	; 0x3e
    2128:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    212a:	8d ad       	ldd	r24, Y+61	; 0x3d
    212c:	9e ad       	ldd	r25, Y+62	; 0x3e
    212e:	00 97       	sbiw	r24, 0x00	; 0
    2130:	69 f7       	brne	.-38     	; 0x210c <STEP_HCW_Vid+0x534>
    2132:	16 c0       	rjmp	.+44     	; 0x2160 <STEP_HCW_Vid+0x588>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2134:	fe 01       	movw	r30, r28
    2136:	ff 96       	adiw	r30, 0x3f	; 63
    2138:	60 81       	ld	r22, Z
    213a:	71 81       	ldd	r23, Z+1	; 0x01
    213c:	82 81       	ldd	r24, Z+2	; 0x02
    213e:	93 81       	ldd	r25, Z+3	; 0x03
    2140:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2144:	dc 01       	movw	r26, r24
    2146:	cb 01       	movw	r24, r22
    2148:	9e af       	std	Y+62, r25	; 0x3e
    214a:	8d af       	std	Y+61, r24	; 0x3d
    214c:	8d ad       	ldd	r24, Y+61	; 0x3d
    214e:	9e ad       	ldd	r25, Y+62	; 0x3e
    2150:	9a af       	std	Y+58, r25	; 0x3a
    2152:	89 af       	std	Y+57, r24	; 0x39
    2154:	89 ad       	ldd	r24, Y+57	; 0x39
    2156:	9a ad       	ldd	r25, Y+58	; 0x3a
    2158:	01 97       	sbiw	r24, 0x01	; 1
    215a:	f1 f7       	brne	.-4      	; 0x2158 <STEP_HCW_Vid+0x580>
    215c:	9a af       	std	Y+58, r25	; 0x3a
    215e:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(STEP_DELAY);
	DIO_VidSetPinValue(STEP_PORT, STEP_COIL_YELLOW, DIO_HIGH);
    2160:	82 e0       	ldi	r24, 0x02	; 2
    2162:	62 e0       	ldi	r22, 0x02	; 2
    2164:	41 e0       	ldi	r20, 0x01	; 1
    2166:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
    216a:	80 e0       	ldi	r24, 0x00	; 0
    216c:	90 e0       	ldi	r25, 0x00	; 0
    216e:	a6 e9       	ldi	r26, 0x96	; 150
    2170:	b3 e4       	ldi	r27, 0x43	; 67
    2172:	8d ab       	std	Y+53, r24	; 0x35
    2174:	9e ab       	std	Y+54, r25	; 0x36
    2176:	af ab       	std	Y+55, r26	; 0x37
    2178:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    217a:	6d a9       	ldd	r22, Y+53	; 0x35
    217c:	7e a9       	ldd	r23, Y+54	; 0x36
    217e:	8f a9       	ldd	r24, Y+55	; 0x37
    2180:	98 ad       	ldd	r25, Y+56	; 0x38
    2182:	20 e0       	ldi	r18, 0x00	; 0
    2184:	30 e0       	ldi	r19, 0x00	; 0
    2186:	4a ef       	ldi	r20, 0xFA	; 250
    2188:	54 e4       	ldi	r21, 0x44	; 68
    218a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    218e:	dc 01       	movw	r26, r24
    2190:	cb 01       	movw	r24, r22
    2192:	89 ab       	std	Y+49, r24	; 0x31
    2194:	9a ab       	std	Y+50, r25	; 0x32
    2196:	ab ab       	std	Y+51, r26	; 0x33
    2198:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    219a:	69 a9       	ldd	r22, Y+49	; 0x31
    219c:	7a a9       	ldd	r23, Y+50	; 0x32
    219e:	8b a9       	ldd	r24, Y+51	; 0x33
    21a0:	9c a9       	ldd	r25, Y+52	; 0x34
    21a2:	20 e0       	ldi	r18, 0x00	; 0
    21a4:	30 e0       	ldi	r19, 0x00	; 0
    21a6:	40 e8       	ldi	r20, 0x80	; 128
    21a8:	5f e3       	ldi	r21, 0x3F	; 63
    21aa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    21ae:	88 23       	and	r24, r24
    21b0:	2c f4       	brge	.+10     	; 0x21bc <STEP_HCW_Vid+0x5e4>
		__ticks = 1;
    21b2:	81 e0       	ldi	r24, 0x01	; 1
    21b4:	90 e0       	ldi	r25, 0x00	; 0
    21b6:	98 ab       	std	Y+48, r25	; 0x30
    21b8:	8f a7       	std	Y+47, r24	; 0x2f
    21ba:	3f c0       	rjmp	.+126    	; 0x223a <STEP_HCW_Vid+0x662>
	else if (__tmp > 65535)
    21bc:	69 a9       	ldd	r22, Y+49	; 0x31
    21be:	7a a9       	ldd	r23, Y+50	; 0x32
    21c0:	8b a9       	ldd	r24, Y+51	; 0x33
    21c2:	9c a9       	ldd	r25, Y+52	; 0x34
    21c4:	20 e0       	ldi	r18, 0x00	; 0
    21c6:	3f ef       	ldi	r19, 0xFF	; 255
    21c8:	4f e7       	ldi	r20, 0x7F	; 127
    21ca:	57 e4       	ldi	r21, 0x47	; 71
    21cc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    21d0:	18 16       	cp	r1, r24
    21d2:	4c f5       	brge	.+82     	; 0x2226 <STEP_HCW_Vid+0x64e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    21d4:	6d a9       	ldd	r22, Y+53	; 0x35
    21d6:	7e a9       	ldd	r23, Y+54	; 0x36
    21d8:	8f a9       	ldd	r24, Y+55	; 0x37
    21da:	98 ad       	ldd	r25, Y+56	; 0x38
    21dc:	20 e0       	ldi	r18, 0x00	; 0
    21de:	30 e0       	ldi	r19, 0x00	; 0
    21e0:	40 e2       	ldi	r20, 0x20	; 32
    21e2:	51 e4       	ldi	r21, 0x41	; 65
    21e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21e8:	dc 01       	movw	r26, r24
    21ea:	cb 01       	movw	r24, r22
    21ec:	bc 01       	movw	r22, r24
    21ee:	cd 01       	movw	r24, r26
    21f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21f4:	dc 01       	movw	r26, r24
    21f6:	cb 01       	movw	r24, r22
    21f8:	98 ab       	std	Y+48, r25	; 0x30
    21fa:	8f a7       	std	Y+47, r24	; 0x2f
    21fc:	0f c0       	rjmp	.+30     	; 0x221c <STEP_HCW_Vid+0x644>
    21fe:	88 ec       	ldi	r24, 0xC8	; 200
    2200:	90 e0       	ldi	r25, 0x00	; 0
    2202:	9e a7       	std	Y+46, r25	; 0x2e
    2204:	8d a7       	std	Y+45, r24	; 0x2d
    2206:	8d a5       	ldd	r24, Y+45	; 0x2d
    2208:	9e a5       	ldd	r25, Y+46	; 0x2e
    220a:	01 97       	sbiw	r24, 0x01	; 1
    220c:	f1 f7       	brne	.-4      	; 0x220a <STEP_HCW_Vid+0x632>
    220e:	9e a7       	std	Y+46, r25	; 0x2e
    2210:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2212:	8f a5       	ldd	r24, Y+47	; 0x2f
    2214:	98 a9       	ldd	r25, Y+48	; 0x30
    2216:	01 97       	sbiw	r24, 0x01	; 1
    2218:	98 ab       	std	Y+48, r25	; 0x30
    221a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    221c:	8f a5       	ldd	r24, Y+47	; 0x2f
    221e:	98 a9       	ldd	r25, Y+48	; 0x30
    2220:	00 97       	sbiw	r24, 0x00	; 0
    2222:	69 f7       	brne	.-38     	; 0x21fe <STEP_HCW_Vid+0x626>
    2224:	14 c0       	rjmp	.+40     	; 0x224e <STEP_HCW_Vid+0x676>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2226:	69 a9       	ldd	r22, Y+49	; 0x31
    2228:	7a a9       	ldd	r23, Y+50	; 0x32
    222a:	8b a9       	ldd	r24, Y+51	; 0x33
    222c:	9c a9       	ldd	r25, Y+52	; 0x34
    222e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2232:	dc 01       	movw	r26, r24
    2234:	cb 01       	movw	r24, r22
    2236:	98 ab       	std	Y+48, r25	; 0x30
    2238:	8f a7       	std	Y+47, r24	; 0x2f
    223a:	8f a5       	ldd	r24, Y+47	; 0x2f
    223c:	98 a9       	ldd	r25, Y+48	; 0x30
    223e:	9c a7       	std	Y+44, r25	; 0x2c
    2240:	8b a7       	std	Y+43, r24	; 0x2b
    2242:	8b a5       	ldd	r24, Y+43	; 0x2b
    2244:	9c a5       	ldd	r25, Y+44	; 0x2c
    2246:	01 97       	sbiw	r24, 0x01	; 1
    2248:	f1 f7       	brne	.-4      	; 0x2246 <STEP_HCW_Vid+0x66e>
    224a:	9c a7       	std	Y+44, r25	; 0x2c
    224c:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(STEP_DELAY);
	DIO_VidSetPinValue(STEP_PORT, STEP_COIL_PINK, DIO_LOW);
    224e:	82 e0       	ldi	r24, 0x02	; 2
    2250:	61 e0       	ldi	r22, 0x01	; 1
    2252:	40 e0       	ldi	r20, 0x00	; 0
    2254:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
    2258:	80 e0       	ldi	r24, 0x00	; 0
    225a:	90 e0       	ldi	r25, 0x00	; 0
    225c:	a6 e9       	ldi	r26, 0x96	; 150
    225e:	b3 e4       	ldi	r27, 0x43	; 67
    2260:	8f a3       	std	Y+39, r24	; 0x27
    2262:	98 a7       	std	Y+40, r25	; 0x28
    2264:	a9 a7       	std	Y+41, r26	; 0x29
    2266:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2268:	6f a1       	ldd	r22, Y+39	; 0x27
    226a:	78 a5       	ldd	r23, Y+40	; 0x28
    226c:	89 a5       	ldd	r24, Y+41	; 0x29
    226e:	9a a5       	ldd	r25, Y+42	; 0x2a
    2270:	20 e0       	ldi	r18, 0x00	; 0
    2272:	30 e0       	ldi	r19, 0x00	; 0
    2274:	4a ef       	ldi	r20, 0xFA	; 250
    2276:	54 e4       	ldi	r21, 0x44	; 68
    2278:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    227c:	dc 01       	movw	r26, r24
    227e:	cb 01       	movw	r24, r22
    2280:	8b a3       	std	Y+35, r24	; 0x23
    2282:	9c a3       	std	Y+36, r25	; 0x24
    2284:	ad a3       	std	Y+37, r26	; 0x25
    2286:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2288:	6b a1       	ldd	r22, Y+35	; 0x23
    228a:	7c a1       	ldd	r23, Y+36	; 0x24
    228c:	8d a1       	ldd	r24, Y+37	; 0x25
    228e:	9e a1       	ldd	r25, Y+38	; 0x26
    2290:	20 e0       	ldi	r18, 0x00	; 0
    2292:	30 e0       	ldi	r19, 0x00	; 0
    2294:	40 e8       	ldi	r20, 0x80	; 128
    2296:	5f e3       	ldi	r21, 0x3F	; 63
    2298:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    229c:	88 23       	and	r24, r24
    229e:	2c f4       	brge	.+10     	; 0x22aa <STEP_HCW_Vid+0x6d2>
		__ticks = 1;
    22a0:	81 e0       	ldi	r24, 0x01	; 1
    22a2:	90 e0       	ldi	r25, 0x00	; 0
    22a4:	9a a3       	std	Y+34, r25	; 0x22
    22a6:	89 a3       	std	Y+33, r24	; 0x21
    22a8:	3f c0       	rjmp	.+126    	; 0x2328 <STEP_HCW_Vid+0x750>
	else if (__tmp > 65535)
    22aa:	6b a1       	ldd	r22, Y+35	; 0x23
    22ac:	7c a1       	ldd	r23, Y+36	; 0x24
    22ae:	8d a1       	ldd	r24, Y+37	; 0x25
    22b0:	9e a1       	ldd	r25, Y+38	; 0x26
    22b2:	20 e0       	ldi	r18, 0x00	; 0
    22b4:	3f ef       	ldi	r19, 0xFF	; 255
    22b6:	4f e7       	ldi	r20, 0x7F	; 127
    22b8:	57 e4       	ldi	r21, 0x47	; 71
    22ba:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    22be:	18 16       	cp	r1, r24
    22c0:	4c f5       	brge	.+82     	; 0x2314 <STEP_HCW_Vid+0x73c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    22c2:	6f a1       	ldd	r22, Y+39	; 0x27
    22c4:	78 a5       	ldd	r23, Y+40	; 0x28
    22c6:	89 a5       	ldd	r24, Y+41	; 0x29
    22c8:	9a a5       	ldd	r25, Y+42	; 0x2a
    22ca:	20 e0       	ldi	r18, 0x00	; 0
    22cc:	30 e0       	ldi	r19, 0x00	; 0
    22ce:	40 e2       	ldi	r20, 0x20	; 32
    22d0:	51 e4       	ldi	r21, 0x41	; 65
    22d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    22d6:	dc 01       	movw	r26, r24
    22d8:	cb 01       	movw	r24, r22
    22da:	bc 01       	movw	r22, r24
    22dc:	cd 01       	movw	r24, r26
    22de:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    22e2:	dc 01       	movw	r26, r24
    22e4:	cb 01       	movw	r24, r22
    22e6:	9a a3       	std	Y+34, r25	; 0x22
    22e8:	89 a3       	std	Y+33, r24	; 0x21
    22ea:	0f c0       	rjmp	.+30     	; 0x230a <STEP_HCW_Vid+0x732>
    22ec:	88 ec       	ldi	r24, 0xC8	; 200
    22ee:	90 e0       	ldi	r25, 0x00	; 0
    22f0:	98 a3       	std	Y+32, r25	; 0x20
    22f2:	8f 8f       	std	Y+31, r24	; 0x1f
    22f4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    22f6:	98 a1       	ldd	r25, Y+32	; 0x20
    22f8:	01 97       	sbiw	r24, 0x01	; 1
    22fa:	f1 f7       	brne	.-4      	; 0x22f8 <STEP_HCW_Vid+0x720>
    22fc:	98 a3       	std	Y+32, r25	; 0x20
    22fe:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2300:	89 a1       	ldd	r24, Y+33	; 0x21
    2302:	9a a1       	ldd	r25, Y+34	; 0x22
    2304:	01 97       	sbiw	r24, 0x01	; 1
    2306:	9a a3       	std	Y+34, r25	; 0x22
    2308:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    230a:	89 a1       	ldd	r24, Y+33	; 0x21
    230c:	9a a1       	ldd	r25, Y+34	; 0x22
    230e:	00 97       	sbiw	r24, 0x00	; 0
    2310:	69 f7       	brne	.-38     	; 0x22ec <STEP_HCW_Vid+0x714>
    2312:	14 c0       	rjmp	.+40     	; 0x233c <STEP_HCW_Vid+0x764>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2314:	6b a1       	ldd	r22, Y+35	; 0x23
    2316:	7c a1       	ldd	r23, Y+36	; 0x24
    2318:	8d a1       	ldd	r24, Y+37	; 0x25
    231a:	9e a1       	ldd	r25, Y+38	; 0x26
    231c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2320:	dc 01       	movw	r26, r24
    2322:	cb 01       	movw	r24, r22
    2324:	9a a3       	std	Y+34, r25	; 0x22
    2326:	89 a3       	std	Y+33, r24	; 0x21
    2328:	89 a1       	ldd	r24, Y+33	; 0x21
    232a:	9a a1       	ldd	r25, Y+34	; 0x22
    232c:	9e 8f       	std	Y+30, r25	; 0x1e
    232e:	8d 8f       	std	Y+29, r24	; 0x1d
    2330:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2332:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2334:	01 97       	sbiw	r24, 0x01	; 1
    2336:	f1 f7       	brne	.-4      	; 0x2334 <STEP_HCW_Vid+0x75c>
    2338:	9e 8f       	std	Y+30, r25	; 0x1e
    233a:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(STEP_DELAY);
	DIO_VidSetPinValue(STEP_PORT, STEP_COIL_ORANGE, DIO_HIGH);
    233c:	82 e0       	ldi	r24, 0x02	; 2
    233e:	63 e0       	ldi	r22, 0x03	; 3
    2340:	41 e0       	ldi	r20, 0x01	; 1
    2342:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
    2346:	80 e0       	ldi	r24, 0x00	; 0
    2348:	90 e0       	ldi	r25, 0x00	; 0
    234a:	a6 e9       	ldi	r26, 0x96	; 150
    234c:	b3 e4       	ldi	r27, 0x43	; 67
    234e:	89 8f       	std	Y+25, r24	; 0x19
    2350:	9a 8f       	std	Y+26, r25	; 0x1a
    2352:	ab 8f       	std	Y+27, r26	; 0x1b
    2354:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2356:	69 8d       	ldd	r22, Y+25	; 0x19
    2358:	7a 8d       	ldd	r23, Y+26	; 0x1a
    235a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    235c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    235e:	20 e0       	ldi	r18, 0x00	; 0
    2360:	30 e0       	ldi	r19, 0x00	; 0
    2362:	4a ef       	ldi	r20, 0xFA	; 250
    2364:	54 e4       	ldi	r21, 0x44	; 68
    2366:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    236a:	dc 01       	movw	r26, r24
    236c:	cb 01       	movw	r24, r22
    236e:	8d 8b       	std	Y+21, r24	; 0x15
    2370:	9e 8b       	std	Y+22, r25	; 0x16
    2372:	af 8b       	std	Y+23, r26	; 0x17
    2374:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2376:	6d 89       	ldd	r22, Y+21	; 0x15
    2378:	7e 89       	ldd	r23, Y+22	; 0x16
    237a:	8f 89       	ldd	r24, Y+23	; 0x17
    237c:	98 8d       	ldd	r25, Y+24	; 0x18
    237e:	20 e0       	ldi	r18, 0x00	; 0
    2380:	30 e0       	ldi	r19, 0x00	; 0
    2382:	40 e8       	ldi	r20, 0x80	; 128
    2384:	5f e3       	ldi	r21, 0x3F	; 63
    2386:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    238a:	88 23       	and	r24, r24
    238c:	2c f4       	brge	.+10     	; 0x2398 <STEP_HCW_Vid+0x7c0>
		__ticks = 1;
    238e:	81 e0       	ldi	r24, 0x01	; 1
    2390:	90 e0       	ldi	r25, 0x00	; 0
    2392:	9c 8b       	std	Y+20, r25	; 0x14
    2394:	8b 8b       	std	Y+19, r24	; 0x13
    2396:	3f c0       	rjmp	.+126    	; 0x2416 <STEP_HCW_Vid+0x83e>
	else if (__tmp > 65535)
    2398:	6d 89       	ldd	r22, Y+21	; 0x15
    239a:	7e 89       	ldd	r23, Y+22	; 0x16
    239c:	8f 89       	ldd	r24, Y+23	; 0x17
    239e:	98 8d       	ldd	r25, Y+24	; 0x18
    23a0:	20 e0       	ldi	r18, 0x00	; 0
    23a2:	3f ef       	ldi	r19, 0xFF	; 255
    23a4:	4f e7       	ldi	r20, 0x7F	; 127
    23a6:	57 e4       	ldi	r21, 0x47	; 71
    23a8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    23ac:	18 16       	cp	r1, r24
    23ae:	4c f5       	brge	.+82     	; 0x2402 <STEP_HCW_Vid+0x82a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    23b0:	69 8d       	ldd	r22, Y+25	; 0x19
    23b2:	7a 8d       	ldd	r23, Y+26	; 0x1a
    23b4:	8b 8d       	ldd	r24, Y+27	; 0x1b
    23b6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    23b8:	20 e0       	ldi	r18, 0x00	; 0
    23ba:	30 e0       	ldi	r19, 0x00	; 0
    23bc:	40 e2       	ldi	r20, 0x20	; 32
    23be:	51 e4       	ldi	r21, 0x41	; 65
    23c0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23c4:	dc 01       	movw	r26, r24
    23c6:	cb 01       	movw	r24, r22
    23c8:	bc 01       	movw	r22, r24
    23ca:	cd 01       	movw	r24, r26
    23cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23d0:	dc 01       	movw	r26, r24
    23d2:	cb 01       	movw	r24, r22
    23d4:	9c 8b       	std	Y+20, r25	; 0x14
    23d6:	8b 8b       	std	Y+19, r24	; 0x13
    23d8:	0f c0       	rjmp	.+30     	; 0x23f8 <STEP_HCW_Vid+0x820>
    23da:	88 ec       	ldi	r24, 0xC8	; 200
    23dc:	90 e0       	ldi	r25, 0x00	; 0
    23de:	9a 8b       	std	Y+18, r25	; 0x12
    23e0:	89 8b       	std	Y+17, r24	; 0x11
    23e2:	89 89       	ldd	r24, Y+17	; 0x11
    23e4:	9a 89       	ldd	r25, Y+18	; 0x12
    23e6:	01 97       	sbiw	r24, 0x01	; 1
    23e8:	f1 f7       	brne	.-4      	; 0x23e6 <STEP_HCW_Vid+0x80e>
    23ea:	9a 8b       	std	Y+18, r25	; 0x12
    23ec:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    23ee:	8b 89       	ldd	r24, Y+19	; 0x13
    23f0:	9c 89       	ldd	r25, Y+20	; 0x14
    23f2:	01 97       	sbiw	r24, 0x01	; 1
    23f4:	9c 8b       	std	Y+20, r25	; 0x14
    23f6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    23f8:	8b 89       	ldd	r24, Y+19	; 0x13
    23fa:	9c 89       	ldd	r25, Y+20	; 0x14
    23fc:	00 97       	sbiw	r24, 0x00	; 0
    23fe:	69 f7       	brne	.-38     	; 0x23da <STEP_HCW_Vid+0x802>
    2400:	14 c0       	rjmp	.+40     	; 0x242a <STEP_HCW_Vid+0x852>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2402:	6d 89       	ldd	r22, Y+21	; 0x15
    2404:	7e 89       	ldd	r23, Y+22	; 0x16
    2406:	8f 89       	ldd	r24, Y+23	; 0x17
    2408:	98 8d       	ldd	r25, Y+24	; 0x18
    240a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    240e:	dc 01       	movw	r26, r24
    2410:	cb 01       	movw	r24, r22
    2412:	9c 8b       	std	Y+20, r25	; 0x14
    2414:	8b 8b       	std	Y+19, r24	; 0x13
    2416:	8b 89       	ldd	r24, Y+19	; 0x13
    2418:	9c 89       	ldd	r25, Y+20	; 0x14
    241a:	98 8b       	std	Y+16, r25	; 0x10
    241c:	8f 87       	std	Y+15, r24	; 0x0f
    241e:	8f 85       	ldd	r24, Y+15	; 0x0f
    2420:	98 89       	ldd	r25, Y+16	; 0x10
    2422:	01 97       	sbiw	r24, 0x01	; 1
    2424:	f1 f7       	brne	.-4      	; 0x2422 <STEP_HCW_Vid+0x84a>
    2426:	98 8b       	std	Y+16, r25	; 0x10
    2428:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(STEP_DELAY);
	DIO_VidSetPinValue(STEP_PORT, STEP_COIL_YELLOW, DIO_LOW);
    242a:	82 e0       	ldi	r24, 0x02	; 2
    242c:	62 e0       	ldi	r22, 0x02	; 2
    242e:	40 e0       	ldi	r20, 0x00	; 0
    2430:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
    2434:	80 e0       	ldi	r24, 0x00	; 0
    2436:	90 e0       	ldi	r25, 0x00	; 0
    2438:	a6 e9       	ldi	r26, 0x96	; 150
    243a:	b3 e4       	ldi	r27, 0x43	; 67
    243c:	8b 87       	std	Y+11, r24	; 0x0b
    243e:	9c 87       	std	Y+12, r25	; 0x0c
    2440:	ad 87       	std	Y+13, r26	; 0x0d
    2442:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2444:	6b 85       	ldd	r22, Y+11	; 0x0b
    2446:	7c 85       	ldd	r23, Y+12	; 0x0c
    2448:	8d 85       	ldd	r24, Y+13	; 0x0d
    244a:	9e 85       	ldd	r25, Y+14	; 0x0e
    244c:	20 e0       	ldi	r18, 0x00	; 0
    244e:	30 e0       	ldi	r19, 0x00	; 0
    2450:	4a ef       	ldi	r20, 0xFA	; 250
    2452:	54 e4       	ldi	r21, 0x44	; 68
    2454:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2458:	dc 01       	movw	r26, r24
    245a:	cb 01       	movw	r24, r22
    245c:	8f 83       	std	Y+7, r24	; 0x07
    245e:	98 87       	std	Y+8, r25	; 0x08
    2460:	a9 87       	std	Y+9, r26	; 0x09
    2462:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2464:	6f 81       	ldd	r22, Y+7	; 0x07
    2466:	78 85       	ldd	r23, Y+8	; 0x08
    2468:	89 85       	ldd	r24, Y+9	; 0x09
    246a:	9a 85       	ldd	r25, Y+10	; 0x0a
    246c:	20 e0       	ldi	r18, 0x00	; 0
    246e:	30 e0       	ldi	r19, 0x00	; 0
    2470:	40 e8       	ldi	r20, 0x80	; 128
    2472:	5f e3       	ldi	r21, 0x3F	; 63
    2474:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2478:	88 23       	and	r24, r24
    247a:	2c f4       	brge	.+10     	; 0x2486 <STEP_HCW_Vid+0x8ae>
		__ticks = 1;
    247c:	81 e0       	ldi	r24, 0x01	; 1
    247e:	90 e0       	ldi	r25, 0x00	; 0
    2480:	9e 83       	std	Y+6, r25	; 0x06
    2482:	8d 83       	std	Y+5, r24	; 0x05
    2484:	3f c0       	rjmp	.+126    	; 0x2504 <STEP_HCW_Vid+0x92c>
	else if (__tmp > 65535)
    2486:	6f 81       	ldd	r22, Y+7	; 0x07
    2488:	78 85       	ldd	r23, Y+8	; 0x08
    248a:	89 85       	ldd	r24, Y+9	; 0x09
    248c:	9a 85       	ldd	r25, Y+10	; 0x0a
    248e:	20 e0       	ldi	r18, 0x00	; 0
    2490:	3f ef       	ldi	r19, 0xFF	; 255
    2492:	4f e7       	ldi	r20, 0x7F	; 127
    2494:	57 e4       	ldi	r21, 0x47	; 71
    2496:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    249a:	18 16       	cp	r1, r24
    249c:	4c f5       	brge	.+82     	; 0x24f0 <STEP_HCW_Vid+0x918>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    249e:	6b 85       	ldd	r22, Y+11	; 0x0b
    24a0:	7c 85       	ldd	r23, Y+12	; 0x0c
    24a2:	8d 85       	ldd	r24, Y+13	; 0x0d
    24a4:	9e 85       	ldd	r25, Y+14	; 0x0e
    24a6:	20 e0       	ldi	r18, 0x00	; 0
    24a8:	30 e0       	ldi	r19, 0x00	; 0
    24aa:	40 e2       	ldi	r20, 0x20	; 32
    24ac:	51 e4       	ldi	r21, 0x41	; 65
    24ae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    24b2:	dc 01       	movw	r26, r24
    24b4:	cb 01       	movw	r24, r22
    24b6:	bc 01       	movw	r22, r24
    24b8:	cd 01       	movw	r24, r26
    24ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24be:	dc 01       	movw	r26, r24
    24c0:	cb 01       	movw	r24, r22
    24c2:	9e 83       	std	Y+6, r25	; 0x06
    24c4:	8d 83       	std	Y+5, r24	; 0x05
    24c6:	0f c0       	rjmp	.+30     	; 0x24e6 <STEP_HCW_Vid+0x90e>
    24c8:	88 ec       	ldi	r24, 0xC8	; 200
    24ca:	90 e0       	ldi	r25, 0x00	; 0
    24cc:	9c 83       	std	Y+4, r25	; 0x04
    24ce:	8b 83       	std	Y+3, r24	; 0x03
    24d0:	8b 81       	ldd	r24, Y+3	; 0x03
    24d2:	9c 81       	ldd	r25, Y+4	; 0x04
    24d4:	01 97       	sbiw	r24, 0x01	; 1
    24d6:	f1 f7       	brne	.-4      	; 0x24d4 <STEP_HCW_Vid+0x8fc>
    24d8:	9c 83       	std	Y+4, r25	; 0x04
    24da:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    24dc:	8d 81       	ldd	r24, Y+5	; 0x05
    24de:	9e 81       	ldd	r25, Y+6	; 0x06
    24e0:	01 97       	sbiw	r24, 0x01	; 1
    24e2:	9e 83       	std	Y+6, r25	; 0x06
    24e4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    24e6:	8d 81       	ldd	r24, Y+5	; 0x05
    24e8:	9e 81       	ldd	r25, Y+6	; 0x06
    24ea:	00 97       	sbiw	r24, 0x00	; 0
    24ec:	69 f7       	brne	.-38     	; 0x24c8 <STEP_HCW_Vid+0x8f0>
    24ee:	14 c0       	rjmp	.+40     	; 0x2518 <STEP_HCW_Vid+0x940>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    24f0:	6f 81       	ldd	r22, Y+7	; 0x07
    24f2:	78 85       	ldd	r23, Y+8	; 0x08
    24f4:	89 85       	ldd	r24, Y+9	; 0x09
    24f6:	9a 85       	ldd	r25, Y+10	; 0x0a
    24f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24fc:	dc 01       	movw	r26, r24
    24fe:	cb 01       	movw	r24, r22
    2500:	9e 83       	std	Y+6, r25	; 0x06
    2502:	8d 83       	std	Y+5, r24	; 0x05
    2504:	8d 81       	ldd	r24, Y+5	; 0x05
    2506:	9e 81       	ldd	r25, Y+6	; 0x06
    2508:	9a 83       	std	Y+2, r25	; 0x02
    250a:	89 83       	std	Y+1, r24	; 0x01
    250c:	89 81       	ldd	r24, Y+1	; 0x01
    250e:	9a 81       	ldd	r25, Y+2	; 0x02
    2510:	01 97       	sbiw	r24, 0x01	; 1
    2512:	f1 f7       	brne	.-4      	; 0x2510 <STEP_HCW_Vid+0x938>
    2514:	9a 83       	std	Y+2, r25	; 0x02
    2516:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(STEP_DELAY);
}
    2518:	c0 59       	subi	r28, 0x90	; 144
    251a:	df 4f       	sbci	r29, 0xFF	; 255
    251c:	0f b6       	in	r0, 0x3f	; 63
    251e:	f8 94       	cli
    2520:	de bf       	out	0x3e, r29	; 62
    2522:	0f be       	out	0x3f, r0	; 63
    2524:	cd bf       	out	0x3d, r28	; 61
    2526:	cf 91       	pop	r28
    2528:	df 91       	pop	r29
    252a:	1f 91       	pop	r17
    252c:	0f 91       	pop	r16
    252e:	08 95       	ret

00002530 <KPD_VidInit>:

u8 KPD_U8ROW_PINS [4] ={KPD_R1_PIN,KPD_R2_PIN,KPD_R3_PIN,KPD_R4_PIN};
u8 KPD_U8COL_PINS [4] ={KPD_C1_PIN,KPD_C2_PIN,KPD_C3_PIN,KPD_C4_PIN};

void KPD_VidInit(void)
{
    2530:	df 93       	push	r29
    2532:	cf 93       	push	r28
    2534:	cd b7       	in	r28, 0x3d	; 61
    2536:	de b7       	in	r29, 0x3e	; 62
	DIO_VidSetPortDirection(KPD_PORT,0x0f);
    2538:	82 e0       	ldi	r24, 0x02	; 2
    253a:	6f e0       	ldi	r22, 0x0F	; 15
    253c:	0e 94 c3 0b 	call	0x1786	; 0x1786 <DIO_VidSetPortDirection>
	DIO_VidSetPortValue(KPD_PORT , 0xff);
    2540:	82 e0       	ldi	r24, 0x02	; 2
    2542:	6f ef       	ldi	r22, 0xFF	; 255
    2544:	0e 94 04 0c 	call	0x1808	; 0x1808 <DIO_VidSetPortValue>
}
    2548:	cf 91       	pop	r28
    254a:	df 91       	pop	r29
    254c:	08 95       	ret

0000254e <KPD_U8PressedKey>:

u8 KPD_U8PressedKey(void)
{
    254e:	df 93       	push	r29
    2550:	cf 93       	push	r28
    2552:	cd b7       	in	r28, 0x3d	; 61
    2554:	de b7       	in	r29, 0x3e	; 62
    2556:	63 97       	sbiw	r28, 0x13	; 19
    2558:	0f b6       	in	r0, 0x3f	; 63
    255a:	f8 94       	cli
    255c:	de bf       	out	0x3e, r29	; 62
    255e:	0f be       	out	0x3f, r0	; 63
    2560:	cd bf       	out	0x3d, r28	; 61
	u8 Local_u8CtrR = 0;
    2562:	1b 8a       	std	Y+19, r1	; 0x13
	u8 Local_u8CtrC = 0;
    2564:	1a 8a       	std	Y+18, r1	; 0x12
	u8 Local_u8Pressed = 0;
    2566:	19 8a       	std	Y+17, r1	; 0x11
	u8 Local_u8_retVal = KPD_CHECK;
    2568:	8f ef       	ldi	r24, 0xFF	; 255
    256a:	88 8b       	std	Y+16, r24	; 0x10
	u8 Local_u8Flag = 0;
    256c:	1f 86       	std	Y+15, r1	; 0x0f

	for(Local_u8CtrR = 0; Local_u8CtrR < 4; Local_u8CtrR++)
    256e:	1b 8a       	std	Y+19, r1	; 0x13
    2570:	c7 c0       	rjmp	.+398    	; 0x2700 <KPD_U8PressedKey+0x1b2>
	{
		DIO_VidSetPinValue(KPD_PORT, Local_u8CtrR, DIO_LOW);
    2572:	82 e0       	ldi	r24, 0x02	; 2
    2574:	6b 89       	ldd	r22, Y+19	; 0x13
    2576:	40 e0       	ldi	r20, 0x00	; 0
    2578:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
		for(Local_u8CtrC = 0;Local_u8CtrC < 4; Local_u8CtrC++)
    257c:	1a 8a       	std	Y+18, r1	; 0x12
    257e:	aa c0       	rjmp	.+340    	; 0x26d4 <KPD_U8PressedKey+0x186>
		{
			Local_u8Pressed = DIO_8uGetPinValue(KPD_PORT, KPD_U8COL_PINS[Local_u8CtrC]);
    2580:	8a 89       	ldd	r24, Y+18	; 0x12
    2582:	88 2f       	mov	r24, r24
    2584:	90 e0       	ldi	r25, 0x00	; 0
    2586:	fc 01       	movw	r30, r24
    2588:	ec 57       	subi	r30, 0x7C	; 124
    258a:	ff 4f       	sbci	r31, 0xFF	; 255
    258c:	90 81       	ld	r25, Z
    258e:	82 e0       	ldi	r24, 0x02	; 2
    2590:	69 2f       	mov	r22, r25
    2592:	0e 94 45 0c 	call	0x188a	; 0x188a <DIO_8uGetPinValue>
    2596:	89 8b       	std	Y+17, r24	; 0x11
			if(Local_u8Pressed == DIO_LOW)
    2598:	89 89       	ldd	r24, Y+17	; 0x11
    259a:	88 23       	and	r24, r24
    259c:	09 f0       	breq	.+2      	; 0x25a0 <KPD_U8PressedKey+0x52>
    259e:	97 c0       	rjmp	.+302    	; 0x26ce <KPD_U8PressedKey+0x180>
    25a0:	80 e0       	ldi	r24, 0x00	; 0
    25a2:	90 e0       	ldi	r25, 0x00	; 0
    25a4:	a0 ea       	ldi	r26, 0xA0	; 160
    25a6:	b1 e4       	ldi	r27, 0x41	; 65
    25a8:	8b 87       	std	Y+11, r24	; 0x0b
    25aa:	9c 87       	std	Y+12, r25	; 0x0c
    25ac:	ad 87       	std	Y+13, r26	; 0x0d
    25ae:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    25b0:	6b 85       	ldd	r22, Y+11	; 0x0b
    25b2:	7c 85       	ldd	r23, Y+12	; 0x0c
    25b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    25b6:	9e 85       	ldd	r25, Y+14	; 0x0e
    25b8:	20 e0       	ldi	r18, 0x00	; 0
    25ba:	30 e0       	ldi	r19, 0x00	; 0
    25bc:	4a ef       	ldi	r20, 0xFA	; 250
    25be:	54 e4       	ldi	r21, 0x44	; 68
    25c0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    25c4:	dc 01       	movw	r26, r24
    25c6:	cb 01       	movw	r24, r22
    25c8:	8f 83       	std	Y+7, r24	; 0x07
    25ca:	98 87       	std	Y+8, r25	; 0x08
    25cc:	a9 87       	std	Y+9, r26	; 0x09
    25ce:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    25d0:	6f 81       	ldd	r22, Y+7	; 0x07
    25d2:	78 85       	ldd	r23, Y+8	; 0x08
    25d4:	89 85       	ldd	r24, Y+9	; 0x09
    25d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    25d8:	20 e0       	ldi	r18, 0x00	; 0
    25da:	30 e0       	ldi	r19, 0x00	; 0
    25dc:	40 e8       	ldi	r20, 0x80	; 128
    25de:	5f e3       	ldi	r21, 0x3F	; 63
    25e0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    25e4:	88 23       	and	r24, r24
    25e6:	2c f4       	brge	.+10     	; 0x25f2 <KPD_U8PressedKey+0xa4>
		__ticks = 1;
    25e8:	81 e0       	ldi	r24, 0x01	; 1
    25ea:	90 e0       	ldi	r25, 0x00	; 0
    25ec:	9e 83       	std	Y+6, r25	; 0x06
    25ee:	8d 83       	std	Y+5, r24	; 0x05
    25f0:	3f c0       	rjmp	.+126    	; 0x2670 <KPD_U8PressedKey+0x122>
	else if (__tmp > 65535)
    25f2:	6f 81       	ldd	r22, Y+7	; 0x07
    25f4:	78 85       	ldd	r23, Y+8	; 0x08
    25f6:	89 85       	ldd	r24, Y+9	; 0x09
    25f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    25fa:	20 e0       	ldi	r18, 0x00	; 0
    25fc:	3f ef       	ldi	r19, 0xFF	; 255
    25fe:	4f e7       	ldi	r20, 0x7F	; 127
    2600:	57 e4       	ldi	r21, 0x47	; 71
    2602:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2606:	18 16       	cp	r1, r24
    2608:	4c f5       	brge	.+82     	; 0x265c <KPD_U8PressedKey+0x10e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    260a:	6b 85       	ldd	r22, Y+11	; 0x0b
    260c:	7c 85       	ldd	r23, Y+12	; 0x0c
    260e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2610:	9e 85       	ldd	r25, Y+14	; 0x0e
    2612:	20 e0       	ldi	r18, 0x00	; 0
    2614:	30 e0       	ldi	r19, 0x00	; 0
    2616:	40 e2       	ldi	r20, 0x20	; 32
    2618:	51 e4       	ldi	r21, 0x41	; 65
    261a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    261e:	dc 01       	movw	r26, r24
    2620:	cb 01       	movw	r24, r22
    2622:	bc 01       	movw	r22, r24
    2624:	cd 01       	movw	r24, r26
    2626:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    262a:	dc 01       	movw	r26, r24
    262c:	cb 01       	movw	r24, r22
    262e:	9e 83       	std	Y+6, r25	; 0x06
    2630:	8d 83       	std	Y+5, r24	; 0x05
    2632:	0f c0       	rjmp	.+30     	; 0x2652 <KPD_U8PressedKey+0x104>
    2634:	88 ec       	ldi	r24, 0xC8	; 200
    2636:	90 e0       	ldi	r25, 0x00	; 0
    2638:	9c 83       	std	Y+4, r25	; 0x04
    263a:	8b 83       	std	Y+3, r24	; 0x03
    263c:	8b 81       	ldd	r24, Y+3	; 0x03
    263e:	9c 81       	ldd	r25, Y+4	; 0x04
    2640:	01 97       	sbiw	r24, 0x01	; 1
    2642:	f1 f7       	brne	.-4      	; 0x2640 <KPD_U8PressedKey+0xf2>
    2644:	9c 83       	std	Y+4, r25	; 0x04
    2646:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2648:	8d 81       	ldd	r24, Y+5	; 0x05
    264a:	9e 81       	ldd	r25, Y+6	; 0x06
    264c:	01 97       	sbiw	r24, 0x01	; 1
    264e:	9e 83       	std	Y+6, r25	; 0x06
    2650:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2652:	8d 81       	ldd	r24, Y+5	; 0x05
    2654:	9e 81       	ldd	r25, Y+6	; 0x06
    2656:	00 97       	sbiw	r24, 0x00	; 0
    2658:	69 f7       	brne	.-38     	; 0x2634 <KPD_U8PressedKey+0xe6>
    265a:	21 c0       	rjmp	.+66     	; 0x269e <KPD_U8PressedKey+0x150>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    265c:	6f 81       	ldd	r22, Y+7	; 0x07
    265e:	78 85       	ldd	r23, Y+8	; 0x08
    2660:	89 85       	ldd	r24, Y+9	; 0x09
    2662:	9a 85       	ldd	r25, Y+10	; 0x0a
    2664:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2668:	dc 01       	movw	r26, r24
    266a:	cb 01       	movw	r24, r22
    266c:	9e 83       	std	Y+6, r25	; 0x06
    266e:	8d 83       	std	Y+5, r24	; 0x05
    2670:	8d 81       	ldd	r24, Y+5	; 0x05
    2672:	9e 81       	ldd	r25, Y+6	; 0x06
    2674:	9a 83       	std	Y+2, r25	; 0x02
    2676:	89 83       	std	Y+1, r24	; 0x01
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	9a 81       	ldd	r25, Y+2	; 0x02
    267c:	01 97       	sbiw	r24, 0x01	; 1
    267e:	f1 f7       	brne	.-4      	; 0x267c <KPD_U8PressedKey+0x12e>
    2680:	9a 83       	std	Y+2, r25	; 0x02
    2682:	89 83       	std	Y+1, r24	; 0x01
    2684:	0c c0       	rjmp	.+24     	; 0x269e <KPD_U8PressedKey+0x150>
			{
				_delay_ms(20);
				while(Local_u8Pressed == DIO_LOW)
				{
					Local_u8Pressed = DIO_8uGetPinValue(KPD_PORT, KPD_U8COL_PINS[Local_u8CtrC]);
    2686:	8a 89       	ldd	r24, Y+18	; 0x12
    2688:	88 2f       	mov	r24, r24
    268a:	90 e0       	ldi	r25, 0x00	; 0
    268c:	fc 01       	movw	r30, r24
    268e:	ec 57       	subi	r30, 0x7C	; 124
    2690:	ff 4f       	sbci	r31, 0xFF	; 255
    2692:	90 81       	ld	r25, Z
    2694:	82 e0       	ldi	r24, 0x02	; 2
    2696:	69 2f       	mov	r22, r25
    2698:	0e 94 45 0c 	call	0x188a	; 0x188a <DIO_8uGetPinValue>
    269c:	89 8b       	std	Y+17, r24	; 0x11
		{
			Local_u8Pressed = DIO_8uGetPinValue(KPD_PORT, KPD_U8COL_PINS[Local_u8CtrC]);
			if(Local_u8Pressed == DIO_LOW)
			{
				_delay_ms(20);
				while(Local_u8Pressed == DIO_LOW)
    269e:	89 89       	ldd	r24, Y+17	; 0x11
    26a0:	88 23       	and	r24, r24
    26a2:	89 f3       	breq	.-30     	; 0x2686 <KPD_U8PressedKey+0x138>
				{
					Local_u8Pressed = DIO_8uGetPinValue(KPD_PORT, KPD_U8COL_PINS[Local_u8CtrC]);
				}
				Local_u8_retVal = KPD_U8KEYS[Local_u8CtrR][Local_u8CtrC];
    26a4:	8b 89       	ldd	r24, Y+19	; 0x13
    26a6:	48 2f       	mov	r20, r24
    26a8:	50 e0       	ldi	r21, 0x00	; 0
    26aa:	8a 89       	ldd	r24, Y+18	; 0x12
    26ac:	28 2f       	mov	r18, r24
    26ae:	30 e0       	ldi	r19, 0x00	; 0
    26b0:	ca 01       	movw	r24, r20
    26b2:	88 0f       	add	r24, r24
    26b4:	99 1f       	adc	r25, r25
    26b6:	88 0f       	add	r24, r24
    26b8:	99 1f       	adc	r25, r25
    26ba:	82 0f       	add	r24, r18
    26bc:	93 1f       	adc	r25, r19
    26be:	fc 01       	movw	r30, r24
    26c0:	e0 59       	subi	r30, 0x90	; 144
    26c2:	ff 4f       	sbci	r31, 0xFF	; 255
    26c4:	80 81       	ld	r24, Z
    26c6:	88 8b       	std	Y+16, r24	; 0x10
				Local_u8Flag = 1;
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	8f 87       	std	Y+15, r24	; 0x0f
    26cc:	07 c0       	rjmp	.+14     	; 0x26dc <KPD_U8PressedKey+0x18e>
	u8 Local_u8Flag = 0;

	for(Local_u8CtrR = 0; Local_u8CtrR < 4; Local_u8CtrR++)
	{
		DIO_VidSetPinValue(KPD_PORT, Local_u8CtrR, DIO_LOW);
		for(Local_u8CtrC = 0;Local_u8CtrC < 4; Local_u8CtrC++)
    26ce:	8a 89       	ldd	r24, Y+18	; 0x12
    26d0:	8f 5f       	subi	r24, 0xFF	; 255
    26d2:	8a 8b       	std	Y+18, r24	; 0x12
    26d4:	8a 89       	ldd	r24, Y+18	; 0x12
    26d6:	84 30       	cpi	r24, 0x04	; 4
    26d8:	08 f4       	brcc	.+2      	; 0x26dc <KPD_U8PressedKey+0x18e>
    26da:	52 cf       	rjmp	.-348    	; 0x2580 <KPD_U8PressedKey+0x32>
				Local_u8_retVal = KPD_U8KEYS[Local_u8CtrR][Local_u8CtrC];
				Local_u8Flag = 1;
				break;
			}
		}
		DIO_VidSetPinValue(KPD_PORT,KPD_U8ROW_PINS[Local_u8CtrR],DIO_HIGH);
    26dc:	8b 89       	ldd	r24, Y+19	; 0x13
    26de:	88 2f       	mov	r24, r24
    26e0:	90 e0       	ldi	r25, 0x00	; 0
    26e2:	fc 01       	movw	r30, r24
    26e4:	e0 58       	subi	r30, 0x80	; 128
    26e6:	ff 4f       	sbci	r31, 0xFF	; 255
    26e8:	90 81       	ld	r25, Z
    26ea:	82 e0       	ldi	r24, 0x02	; 2
    26ec:	69 2f       	mov	r22, r25
    26ee:	41 e0       	ldi	r20, 0x01	; 1
    26f0:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
		if(Local_u8Flag == 1)
    26f4:	8f 85       	ldd	r24, Y+15	; 0x0f
    26f6:	81 30       	cpi	r24, 0x01	; 1
    26f8:	39 f0       	breq	.+14     	; 0x2708 <KPD_U8PressedKey+0x1ba>
	u8 Local_u8CtrC = 0;
	u8 Local_u8Pressed = 0;
	u8 Local_u8_retVal = KPD_CHECK;
	u8 Local_u8Flag = 0;

	for(Local_u8CtrR = 0; Local_u8CtrR < 4; Local_u8CtrR++)
    26fa:	8b 89       	ldd	r24, Y+19	; 0x13
    26fc:	8f 5f       	subi	r24, 0xFF	; 255
    26fe:	8b 8b       	std	Y+19, r24	; 0x13
    2700:	8b 89       	ldd	r24, Y+19	; 0x13
    2702:	84 30       	cpi	r24, 0x04	; 4
    2704:	08 f4       	brcc	.+2      	; 0x2708 <KPD_U8PressedKey+0x1ba>
    2706:	35 cf       	rjmp	.-406    	; 0x2572 <KPD_U8PressedKey+0x24>
		if(Local_u8Flag == 1)
		{
			break;
		}
	}
	return (Local_u8_retVal);
    2708:	88 89       	ldd	r24, Y+16	; 0x10
}
    270a:	63 96       	adiw	r28, 0x13	; 19
    270c:	0f b6       	in	r0, 0x3f	; 63
    270e:	f8 94       	cli
    2710:	de bf       	out	0x3e, r29	; 62
    2712:	0f be       	out	0x3f, r0	; 63
    2714:	cd bf       	out	0x3d, r28	; 61
    2716:	cf 91       	pop	r28
    2718:	df 91       	pop	r29
    271a:	08 95       	ret

0000271c <Timer1_VidTimer1FPWM>:
#include <avr/io.h>
#include "../../LIB/BIT_MATH.h"
#include "../../LIB/STD_TYPES.h"

void Timer1_VidTimer1FPWM(void)
{
    271c:	df 93       	push	r29
    271e:	cf 93       	push	r28
    2720:	cd b7       	in	r28, 0x3d	; 61
    2722:	de b7       	in	r29, 0x3e	; 62
	/* Fast PWM */
	CLEAR_BIT(TCCR1A,WGM01);
    2724:	af e4       	ldi	r26, 0x4F	; 79
    2726:	b0 e0       	ldi	r27, 0x00	; 0
    2728:	ef e4       	ldi	r30, 0x4F	; 79
    272a:	f0 e0       	ldi	r31, 0x00	; 0
    272c:	80 81       	ld	r24, Z
    272e:	87 7f       	andi	r24, 0xF7	; 247
    2730:	8c 93       	st	X, r24
	SET_BIT(TCCR1A,WGM11);
    2732:	af e4       	ldi	r26, 0x4F	; 79
    2734:	b0 e0       	ldi	r27, 0x00	; 0
    2736:	ef e4       	ldi	r30, 0x4F	; 79
    2738:	f0 e0       	ldi	r31, 0x00	; 0
    273a:	80 81       	ld	r24, Z
    273c:	82 60       	ori	r24, 0x02	; 2
    273e:	8c 93       	st	X, r24
	SET_BIT(TCCR1B,WGM12);
    2740:	ae e4       	ldi	r26, 0x4E	; 78
    2742:	b0 e0       	ldi	r27, 0x00	; 0
    2744:	ee e4       	ldi	r30, 0x4E	; 78
    2746:	f0 e0       	ldi	r31, 0x00	; 0
    2748:	80 81       	ld	r24, Z
    274a:	88 60       	ori	r24, 0x08	; 8
    274c:	8c 93       	st	X, r24
	SET_BIT(TCCR1B,WGM13);
    274e:	ae e4       	ldi	r26, 0x4E	; 78
    2750:	b0 e0       	ldi	r27, 0x00	; 0
    2752:	ee e4       	ldi	r30, 0x4E	; 78
    2754:	f0 e0       	ldi	r31, 0x00	; 0
    2756:	80 81       	ld	r24, Z
    2758:	80 61       	ori	r24, 0x10	; 16
    275a:	8c 93       	st	X, r24
	/**/
	CLEAR_BIT(TCCR1A,COM1A0);
    275c:	af e4       	ldi	r26, 0x4F	; 79
    275e:	b0 e0       	ldi	r27, 0x00	; 0
    2760:	ef e4       	ldi	r30, 0x4F	; 79
    2762:	f0 e0       	ldi	r31, 0x00	; 0
    2764:	80 81       	ld	r24, Z
    2766:	8f 7b       	andi	r24, 0xBF	; 191
    2768:	8c 93       	st	X, r24
	SET_BIT(TCCR1A,COM1A1);
    276a:	af e4       	ldi	r26, 0x4F	; 79
    276c:	b0 e0       	ldi	r27, 0x00	; 0
    276e:	ef e4       	ldi	r30, 0x4F	; 79
    2770:	f0 e0       	ldi	r31, 0x00	; 0
    2772:	80 81       	ld	r24, Z
    2774:	80 68       	ori	r24, 0x80	; 128
    2776:	8c 93       	st	X, r24

	/*Time OVF*/
	ICR1=19999;
    2778:	e6 e4       	ldi	r30, 0x46	; 70
    277a:	f0 e0       	ldi	r31, 0x00	; 0
    277c:	8f e1       	ldi	r24, 0x1F	; 31
    277e:	9e e4       	ldi	r25, 0x4E	; 78
    2780:	91 83       	std	Z+1, r25	; 0x01
    2782:	80 83       	st	Z, r24

	/*CLK / 8 */
	CLEAR_BIT(TCCR1B,CS10);
    2784:	ae e4       	ldi	r26, 0x4E	; 78
    2786:	b0 e0       	ldi	r27, 0x00	; 0
    2788:	ee e4       	ldi	r30, 0x4E	; 78
    278a:	f0 e0       	ldi	r31, 0x00	; 0
    278c:	80 81       	ld	r24, Z
    278e:	8e 7f       	andi	r24, 0xFE	; 254
    2790:	8c 93       	st	X, r24
	SET_BIT(TCCR1B,CS11);
    2792:	ae e4       	ldi	r26, 0x4E	; 78
    2794:	b0 e0       	ldi	r27, 0x00	; 0
    2796:	ee e4       	ldi	r30, 0x4E	; 78
    2798:	f0 e0       	ldi	r31, 0x00	; 0
    279a:	80 81       	ld	r24, Z
    279c:	82 60       	ori	r24, 0x02	; 2
    279e:	8c 93       	st	X, r24
	CLEAR_BIT(TCCR1B,CS12);
    27a0:	ae e4       	ldi	r26, 0x4E	; 78
    27a2:	b0 e0       	ldi	r27, 0x00	; 0
    27a4:	ee e4       	ldi	r30, 0x4E	; 78
    27a6:	f0 e0       	ldi	r31, 0x00	; 0
    27a8:	80 81       	ld	r24, Z
    27aa:	8b 7f       	andi	r24, 0xFB	; 251
    27ac:	8c 93       	st	X, r24


}
    27ae:	cf 91       	pop	r28
    27b0:	df 91       	pop	r29
    27b2:	08 95       	ret

000027b4 <Servo_VidServoAngle>:


void Servo_VidServoAngle(u8 Copy_u8Angle)
{
    27b4:	df 93       	push	r29
    27b6:	cf 93       	push	r28
    27b8:	0f 92       	push	r0
    27ba:	cd b7       	in	r28, 0x3d	; 61
    27bc:	de b7       	in	r29, 0x3e	; 62
    27be:	89 83       	std	Y+1, r24	; 0x01
	else if(Copy_u8Angle ==180)
	{
		OCR1A =2000;
	}
	*/
	OCR1A = ((50*Copy_u8Angle)+8991)/9;
    27c0:	ea e4       	ldi	r30, 0x4A	; 74
    27c2:	f0 e0       	ldi	r31, 0x00	; 0
    27c4:	89 81       	ldd	r24, Y+1	; 0x01
    27c6:	28 2f       	mov	r18, r24
    27c8:	30 e0       	ldi	r19, 0x00	; 0
    27ca:	82 e3       	ldi	r24, 0x32	; 50
    27cc:	90 e0       	ldi	r25, 0x00	; 0
    27ce:	ac 01       	movw	r20, r24
    27d0:	24 9f       	mul	r18, r20
    27d2:	c0 01       	movw	r24, r0
    27d4:	25 9f       	mul	r18, r21
    27d6:	90 0d       	add	r25, r0
    27d8:	34 9f       	mul	r19, r20
    27da:	90 0d       	add	r25, r0
    27dc:	11 24       	eor	r1, r1
    27de:	81 5e       	subi	r24, 0xE1	; 225
    27e0:	9c 4d       	sbci	r25, 0xDC	; 220
    27e2:	29 e0       	ldi	r18, 0x09	; 9
    27e4:	30 e0       	ldi	r19, 0x00	; 0
    27e6:	b9 01       	movw	r22, r18
    27e8:	0e 94 23 2c 	call	0x5846	; 0x5846 <__divmodhi4>
    27ec:	cb 01       	movw	r24, r22
    27ee:	91 83       	std	Z+1, r25	; 0x01
    27f0:	80 83       	st	Z, r24
}
    27f2:	0f 90       	pop	r0
    27f4:	cf 91       	pop	r28
    27f6:	df 91       	pop	r29
    27f8:	08 95       	ret

000027fa <LCD_VidSendCMD>:
#include "../../LIB/STD_TYPES.h"
#include "../../MCAL/DIO/DIO.h"


void LCD_VidSendCMD(u8 Copy_u8CMD)
{
    27fa:	df 93       	push	r29
    27fc:	cf 93       	push	r28
    27fe:	cd b7       	in	r28, 0x3d	; 61
    2800:	de b7       	in	r29, 0x3e	; 62
    2802:	2f 97       	sbiw	r28, 0x0f	; 15
    2804:	0f b6       	in	r0, 0x3f	; 63
    2806:	f8 94       	cli
    2808:	de bf       	out	0x3e, r29	; 62
    280a:	0f be       	out	0x3f, r0	; 63
    280c:	cd bf       	out	0x3d, r28	; 61
    280e:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_VidSetPinValue(LCD_CMD_PORT , RS ,DIO_LOW);
    2810:	81 e0       	ldi	r24, 0x01	; 1
    2812:	65 e0       	ldi	r22, 0x05	; 5
    2814:	40 e0       	ldi	r20, 0x00	; 0
    2816:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>

	DIO_VidSetPinValue(LCD_CMD_PORT , RW ,DIO_LOW);
    281a:	81 e0       	ldi	r24, 0x01	; 1
    281c:	66 e0       	ldi	r22, 0x06	; 6
    281e:	40 e0       	ldi	r20, 0x00	; 0
    2820:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>

	DIO_VidSetPortValue(LCD_DATA_PORT,Copy_u8CMD);
    2824:	80 e0       	ldi	r24, 0x00	; 0
    2826:	6f 85       	ldd	r22, Y+15	; 0x0f
    2828:	0e 94 04 0c 	call	0x1808	; 0x1808 <DIO_VidSetPortValue>

	DIO_VidSetPinValue(LCD_CMD_PORT ,EN ,DIO_HIGH);
    282c:	81 e0       	ldi	r24, 0x01	; 1
    282e:	67 e0       	ldi	r22, 0x07	; 7
    2830:	41 e0       	ldi	r20, 0x01	; 1
    2832:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
    2836:	80 e0       	ldi	r24, 0x00	; 0
    2838:	90 e0       	ldi	r25, 0x00	; 0
    283a:	a0 e8       	ldi	r26, 0x80	; 128
    283c:	bf e3       	ldi	r27, 0x3F	; 63
    283e:	8b 87       	std	Y+11, r24	; 0x0b
    2840:	9c 87       	std	Y+12, r25	; 0x0c
    2842:	ad 87       	std	Y+13, r26	; 0x0d
    2844:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2846:	6b 85       	ldd	r22, Y+11	; 0x0b
    2848:	7c 85       	ldd	r23, Y+12	; 0x0c
    284a:	8d 85       	ldd	r24, Y+13	; 0x0d
    284c:	9e 85       	ldd	r25, Y+14	; 0x0e
    284e:	20 e0       	ldi	r18, 0x00	; 0
    2850:	30 e0       	ldi	r19, 0x00	; 0
    2852:	4a ef       	ldi	r20, 0xFA	; 250
    2854:	54 e4       	ldi	r21, 0x44	; 68
    2856:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    285a:	dc 01       	movw	r26, r24
    285c:	cb 01       	movw	r24, r22
    285e:	8f 83       	std	Y+7, r24	; 0x07
    2860:	98 87       	std	Y+8, r25	; 0x08
    2862:	a9 87       	std	Y+9, r26	; 0x09
    2864:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2866:	6f 81       	ldd	r22, Y+7	; 0x07
    2868:	78 85       	ldd	r23, Y+8	; 0x08
    286a:	89 85       	ldd	r24, Y+9	; 0x09
    286c:	9a 85       	ldd	r25, Y+10	; 0x0a
    286e:	20 e0       	ldi	r18, 0x00	; 0
    2870:	30 e0       	ldi	r19, 0x00	; 0
    2872:	40 e8       	ldi	r20, 0x80	; 128
    2874:	5f e3       	ldi	r21, 0x3F	; 63
    2876:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    287a:	88 23       	and	r24, r24
    287c:	2c f4       	brge	.+10     	; 0x2888 <LCD_VidSendCMD+0x8e>
		__ticks = 1;
    287e:	81 e0       	ldi	r24, 0x01	; 1
    2880:	90 e0       	ldi	r25, 0x00	; 0
    2882:	9e 83       	std	Y+6, r25	; 0x06
    2884:	8d 83       	std	Y+5, r24	; 0x05
    2886:	3f c0       	rjmp	.+126    	; 0x2906 <LCD_VidSendCMD+0x10c>
	else if (__tmp > 65535)
    2888:	6f 81       	ldd	r22, Y+7	; 0x07
    288a:	78 85       	ldd	r23, Y+8	; 0x08
    288c:	89 85       	ldd	r24, Y+9	; 0x09
    288e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2890:	20 e0       	ldi	r18, 0x00	; 0
    2892:	3f ef       	ldi	r19, 0xFF	; 255
    2894:	4f e7       	ldi	r20, 0x7F	; 127
    2896:	57 e4       	ldi	r21, 0x47	; 71
    2898:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    289c:	18 16       	cp	r1, r24
    289e:	4c f5       	brge	.+82     	; 0x28f2 <LCD_VidSendCMD+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    28a0:	6b 85       	ldd	r22, Y+11	; 0x0b
    28a2:	7c 85       	ldd	r23, Y+12	; 0x0c
    28a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    28a6:	9e 85       	ldd	r25, Y+14	; 0x0e
    28a8:	20 e0       	ldi	r18, 0x00	; 0
    28aa:	30 e0       	ldi	r19, 0x00	; 0
    28ac:	40 e2       	ldi	r20, 0x20	; 32
    28ae:	51 e4       	ldi	r21, 0x41	; 65
    28b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    28b4:	dc 01       	movw	r26, r24
    28b6:	cb 01       	movw	r24, r22
    28b8:	bc 01       	movw	r22, r24
    28ba:	cd 01       	movw	r24, r26
    28bc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    28c0:	dc 01       	movw	r26, r24
    28c2:	cb 01       	movw	r24, r22
    28c4:	9e 83       	std	Y+6, r25	; 0x06
    28c6:	8d 83       	std	Y+5, r24	; 0x05
    28c8:	0f c0       	rjmp	.+30     	; 0x28e8 <LCD_VidSendCMD+0xee>
    28ca:	88 ec       	ldi	r24, 0xC8	; 200
    28cc:	90 e0       	ldi	r25, 0x00	; 0
    28ce:	9c 83       	std	Y+4, r25	; 0x04
    28d0:	8b 83       	std	Y+3, r24	; 0x03
    28d2:	8b 81       	ldd	r24, Y+3	; 0x03
    28d4:	9c 81       	ldd	r25, Y+4	; 0x04
    28d6:	01 97       	sbiw	r24, 0x01	; 1
    28d8:	f1 f7       	brne	.-4      	; 0x28d6 <LCD_VidSendCMD+0xdc>
    28da:	9c 83       	std	Y+4, r25	; 0x04
    28dc:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    28de:	8d 81       	ldd	r24, Y+5	; 0x05
    28e0:	9e 81       	ldd	r25, Y+6	; 0x06
    28e2:	01 97       	sbiw	r24, 0x01	; 1
    28e4:	9e 83       	std	Y+6, r25	; 0x06
    28e6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    28e8:	8d 81       	ldd	r24, Y+5	; 0x05
    28ea:	9e 81       	ldd	r25, Y+6	; 0x06
    28ec:	00 97       	sbiw	r24, 0x00	; 0
    28ee:	69 f7       	brne	.-38     	; 0x28ca <LCD_VidSendCMD+0xd0>
    28f0:	14 c0       	rjmp	.+40     	; 0x291a <LCD_VidSendCMD+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    28f2:	6f 81       	ldd	r22, Y+7	; 0x07
    28f4:	78 85       	ldd	r23, Y+8	; 0x08
    28f6:	89 85       	ldd	r24, Y+9	; 0x09
    28f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    28fa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    28fe:	dc 01       	movw	r26, r24
    2900:	cb 01       	movw	r24, r22
    2902:	9e 83       	std	Y+6, r25	; 0x06
    2904:	8d 83       	std	Y+5, r24	; 0x05
    2906:	8d 81       	ldd	r24, Y+5	; 0x05
    2908:	9e 81       	ldd	r25, Y+6	; 0x06
    290a:	9a 83       	std	Y+2, r25	; 0x02
    290c:	89 83       	std	Y+1, r24	; 0x01
    290e:	89 81       	ldd	r24, Y+1	; 0x01
    2910:	9a 81       	ldd	r25, Y+2	; 0x02
    2912:	01 97       	sbiw	r24, 0x01	; 1
    2914:	f1 f7       	brne	.-4      	; 0x2912 <LCD_VidSendCMD+0x118>
    2916:	9a 83       	std	Y+2, r25	; 0x02
    2918:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
	DIO_VidSetPinValue(LCD_CMD_PORT ,EN ,DIO_LOW);
    291a:	81 e0       	ldi	r24, 0x01	; 1
    291c:	67 e0       	ldi	r22, 0x07	; 7
    291e:	40 e0       	ldi	r20, 0x00	; 0
    2920:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
}
    2924:	2f 96       	adiw	r28, 0x0f	; 15
    2926:	0f b6       	in	r0, 0x3f	; 63
    2928:	f8 94       	cli
    292a:	de bf       	out	0x3e, r29	; 62
    292c:	0f be       	out	0x3f, r0	; 63
    292e:	cd bf       	out	0x3d, r28	; 61
    2930:	cf 91       	pop	r28
    2932:	df 91       	pop	r29
    2934:	08 95       	ret

00002936 <LCD_VidSendChar>:

void LCD_VidSendChar(u8 Copy_u8Char)
{
    2936:	df 93       	push	r29
    2938:	cf 93       	push	r28
    293a:	cd b7       	in	r28, 0x3d	; 61
    293c:	de b7       	in	r29, 0x3e	; 62
    293e:	2f 97       	sbiw	r28, 0x0f	; 15
    2940:	0f b6       	in	r0, 0x3f	; 63
    2942:	f8 94       	cli
    2944:	de bf       	out	0x3e, r29	; 62
    2946:	0f be       	out	0x3f, r0	; 63
    2948:	cd bf       	out	0x3d, r28	; 61
    294a:	8f 87       	std	Y+15, r24	; 0x0f
	DIO_VidSetPinValue(LCD_CMD_PORT , RS ,DIO_HIGH);
    294c:	81 e0       	ldi	r24, 0x01	; 1
    294e:	65 e0       	ldi	r22, 0x05	; 5
    2950:	41 e0       	ldi	r20, 0x01	; 1
    2952:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>

	DIO_VidSetPinValue(LCD_CMD_PORT , RW ,DIO_LOW);
    2956:	81 e0       	ldi	r24, 0x01	; 1
    2958:	66 e0       	ldi	r22, 0x06	; 6
    295a:	40 e0       	ldi	r20, 0x00	; 0
    295c:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>

	DIO_VidSetPortValue(LCD_DATA_PORT,Copy_u8Char);
    2960:	80 e0       	ldi	r24, 0x00	; 0
    2962:	6f 85       	ldd	r22, Y+15	; 0x0f
    2964:	0e 94 04 0c 	call	0x1808	; 0x1808 <DIO_VidSetPortValue>

	DIO_VidSetPinValue(LCD_CMD_PORT ,EN ,DIO_HIGH);
    2968:	81 e0       	ldi	r24, 0x01	; 1
    296a:	67 e0       	ldi	r22, 0x07	; 7
    296c:	41 e0       	ldi	r20, 0x01	; 1
    296e:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
    2972:	80 e0       	ldi	r24, 0x00	; 0
    2974:	90 e0       	ldi	r25, 0x00	; 0
    2976:	a0 e8       	ldi	r26, 0x80	; 128
    2978:	bf e3       	ldi	r27, 0x3F	; 63
    297a:	8b 87       	std	Y+11, r24	; 0x0b
    297c:	9c 87       	std	Y+12, r25	; 0x0c
    297e:	ad 87       	std	Y+13, r26	; 0x0d
    2980:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2982:	6b 85       	ldd	r22, Y+11	; 0x0b
    2984:	7c 85       	ldd	r23, Y+12	; 0x0c
    2986:	8d 85       	ldd	r24, Y+13	; 0x0d
    2988:	9e 85       	ldd	r25, Y+14	; 0x0e
    298a:	20 e0       	ldi	r18, 0x00	; 0
    298c:	30 e0       	ldi	r19, 0x00	; 0
    298e:	4a ef       	ldi	r20, 0xFA	; 250
    2990:	54 e4       	ldi	r21, 0x44	; 68
    2992:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2996:	dc 01       	movw	r26, r24
    2998:	cb 01       	movw	r24, r22
    299a:	8f 83       	std	Y+7, r24	; 0x07
    299c:	98 87       	std	Y+8, r25	; 0x08
    299e:	a9 87       	std	Y+9, r26	; 0x09
    29a0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    29a2:	6f 81       	ldd	r22, Y+7	; 0x07
    29a4:	78 85       	ldd	r23, Y+8	; 0x08
    29a6:	89 85       	ldd	r24, Y+9	; 0x09
    29a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    29aa:	20 e0       	ldi	r18, 0x00	; 0
    29ac:	30 e0       	ldi	r19, 0x00	; 0
    29ae:	40 e8       	ldi	r20, 0x80	; 128
    29b0:	5f e3       	ldi	r21, 0x3F	; 63
    29b2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    29b6:	88 23       	and	r24, r24
    29b8:	2c f4       	brge	.+10     	; 0x29c4 <LCD_VidSendChar+0x8e>
		__ticks = 1;
    29ba:	81 e0       	ldi	r24, 0x01	; 1
    29bc:	90 e0       	ldi	r25, 0x00	; 0
    29be:	9e 83       	std	Y+6, r25	; 0x06
    29c0:	8d 83       	std	Y+5, r24	; 0x05
    29c2:	3f c0       	rjmp	.+126    	; 0x2a42 <LCD_VidSendChar+0x10c>
	else if (__tmp > 65535)
    29c4:	6f 81       	ldd	r22, Y+7	; 0x07
    29c6:	78 85       	ldd	r23, Y+8	; 0x08
    29c8:	89 85       	ldd	r24, Y+9	; 0x09
    29ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    29cc:	20 e0       	ldi	r18, 0x00	; 0
    29ce:	3f ef       	ldi	r19, 0xFF	; 255
    29d0:	4f e7       	ldi	r20, 0x7F	; 127
    29d2:	57 e4       	ldi	r21, 0x47	; 71
    29d4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    29d8:	18 16       	cp	r1, r24
    29da:	4c f5       	brge	.+82     	; 0x2a2e <LCD_VidSendChar+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    29dc:	6b 85       	ldd	r22, Y+11	; 0x0b
    29de:	7c 85       	ldd	r23, Y+12	; 0x0c
    29e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    29e2:	9e 85       	ldd	r25, Y+14	; 0x0e
    29e4:	20 e0       	ldi	r18, 0x00	; 0
    29e6:	30 e0       	ldi	r19, 0x00	; 0
    29e8:	40 e2       	ldi	r20, 0x20	; 32
    29ea:	51 e4       	ldi	r21, 0x41	; 65
    29ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    29f0:	dc 01       	movw	r26, r24
    29f2:	cb 01       	movw	r24, r22
    29f4:	bc 01       	movw	r22, r24
    29f6:	cd 01       	movw	r24, r26
    29f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    29fc:	dc 01       	movw	r26, r24
    29fe:	cb 01       	movw	r24, r22
    2a00:	9e 83       	std	Y+6, r25	; 0x06
    2a02:	8d 83       	std	Y+5, r24	; 0x05
    2a04:	0f c0       	rjmp	.+30     	; 0x2a24 <LCD_VidSendChar+0xee>
    2a06:	88 ec       	ldi	r24, 0xC8	; 200
    2a08:	90 e0       	ldi	r25, 0x00	; 0
    2a0a:	9c 83       	std	Y+4, r25	; 0x04
    2a0c:	8b 83       	std	Y+3, r24	; 0x03
    2a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a10:	9c 81       	ldd	r25, Y+4	; 0x04
    2a12:	01 97       	sbiw	r24, 0x01	; 1
    2a14:	f1 f7       	brne	.-4      	; 0x2a12 <LCD_VidSendChar+0xdc>
    2a16:	9c 83       	std	Y+4, r25	; 0x04
    2a18:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a1a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a1c:	9e 81       	ldd	r25, Y+6	; 0x06
    2a1e:	01 97       	sbiw	r24, 0x01	; 1
    2a20:	9e 83       	std	Y+6, r25	; 0x06
    2a22:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a24:	8d 81       	ldd	r24, Y+5	; 0x05
    2a26:	9e 81       	ldd	r25, Y+6	; 0x06
    2a28:	00 97       	sbiw	r24, 0x00	; 0
    2a2a:	69 f7       	brne	.-38     	; 0x2a06 <LCD_VidSendChar+0xd0>
    2a2c:	14 c0       	rjmp	.+40     	; 0x2a56 <LCD_VidSendChar+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2a2e:	6f 81       	ldd	r22, Y+7	; 0x07
    2a30:	78 85       	ldd	r23, Y+8	; 0x08
    2a32:	89 85       	ldd	r24, Y+9	; 0x09
    2a34:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a36:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a3a:	dc 01       	movw	r26, r24
    2a3c:	cb 01       	movw	r24, r22
    2a3e:	9e 83       	std	Y+6, r25	; 0x06
    2a40:	8d 83       	std	Y+5, r24	; 0x05
    2a42:	8d 81       	ldd	r24, Y+5	; 0x05
    2a44:	9e 81       	ldd	r25, Y+6	; 0x06
    2a46:	9a 83       	std	Y+2, r25	; 0x02
    2a48:	89 83       	std	Y+1, r24	; 0x01
    2a4a:	89 81       	ldd	r24, Y+1	; 0x01
    2a4c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a4e:	01 97       	sbiw	r24, 0x01	; 1
    2a50:	f1 f7       	brne	.-4      	; 0x2a4e <LCD_VidSendChar+0x118>
    2a52:	9a 83       	std	Y+2, r25	; 0x02
    2a54:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
	DIO_VidSetPinValue(LCD_CMD_PORT ,EN ,DIO_LOW);
    2a56:	81 e0       	ldi	r24, 0x01	; 1
    2a58:	67 e0       	ldi	r22, 0x07	; 7
    2a5a:	40 e0       	ldi	r20, 0x00	; 0
    2a5c:	0e 94 c3 0a 	call	0x1586	; 0x1586 <DIO_VidSetPinValue>
}
    2a60:	2f 96       	adiw	r28, 0x0f	; 15
    2a62:	0f b6       	in	r0, 0x3f	; 63
    2a64:	f8 94       	cli
    2a66:	de bf       	out	0x3e, r29	; 62
    2a68:	0f be       	out	0x3f, r0	; 63
    2a6a:	cd bf       	out	0x3d, r28	; 61
    2a6c:	cf 91       	pop	r28
    2a6e:	df 91       	pop	r29
    2a70:	08 95       	ret

00002a72 <LCD_VidInitialize>:

void LCD_VidInitialize(void)
{
    2a72:	df 93       	push	r29
    2a74:	cf 93       	push	r28
    2a76:	cd b7       	in	r28, 0x3d	; 61
    2a78:	de b7       	in	r29, 0x3e	; 62
    2a7a:	e8 97       	sbiw	r28, 0x38	; 56
    2a7c:	0f b6       	in	r0, 0x3f	; 63
    2a7e:	f8 94       	cli
    2a80:	de bf       	out	0x3e, r29	; 62
    2a82:	0f be       	out	0x3f, r0	; 63
    2a84:	cd bf       	out	0x3d, r28	; 61
	DIO_VidSetPortDirection(LCD_DATA_PORT,0xff);
    2a86:	80 e0       	ldi	r24, 0x00	; 0
    2a88:	6f ef       	ldi	r22, 0xFF	; 255
    2a8a:	0e 94 c3 0b 	call	0x1786	; 0x1786 <DIO_VidSetPortDirection>
	DIO_VidSetPinDirection(LCD_CMD_PORT,RS,DIO_OUT);
    2a8e:	81 e0       	ldi	r24, 0x01	; 1
    2a90:	65 e0       	ldi	r22, 0x05	; 5
    2a92:	41 e0       	ldi	r20, 0x01	; 1
    2a94:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>
	DIO_VidSetPinDirection(LCD_CMD_PORT,RW,DIO_OUT);
    2a98:	81 e0       	ldi	r24, 0x01	; 1
    2a9a:	66 e0       	ldi	r22, 0x06	; 6
    2a9c:	41 e0       	ldi	r20, 0x01	; 1
    2a9e:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>
	DIO_VidSetPinDirection(LCD_CMD_PORT,EN,DIO_OUT);
    2aa2:	81 e0       	ldi	r24, 0x01	; 1
    2aa4:	67 e0       	ldi	r22, 0x07	; 7
    2aa6:	41 e0       	ldi	r20, 0x01	; 1
    2aa8:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>
    2aac:	80 e0       	ldi	r24, 0x00	; 0
    2aae:	90 e0       	ldi	r25, 0x00	; 0
    2ab0:	ac e0       	ldi	r26, 0x0C	; 12
    2ab2:	b2 e4       	ldi	r27, 0x42	; 66
    2ab4:	8d ab       	std	Y+53, r24	; 0x35
    2ab6:	9e ab       	std	Y+54, r25	; 0x36
    2ab8:	af ab       	std	Y+55, r26	; 0x37
    2aba:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2abc:	6d a9       	ldd	r22, Y+53	; 0x35
    2abe:	7e a9       	ldd	r23, Y+54	; 0x36
    2ac0:	8f a9       	ldd	r24, Y+55	; 0x37
    2ac2:	98 ad       	ldd	r25, Y+56	; 0x38
    2ac4:	20 e0       	ldi	r18, 0x00	; 0
    2ac6:	30 e0       	ldi	r19, 0x00	; 0
    2ac8:	4a ef       	ldi	r20, 0xFA	; 250
    2aca:	54 e4       	ldi	r21, 0x44	; 68
    2acc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2ad0:	dc 01       	movw	r26, r24
    2ad2:	cb 01       	movw	r24, r22
    2ad4:	89 ab       	std	Y+49, r24	; 0x31
    2ad6:	9a ab       	std	Y+50, r25	; 0x32
    2ad8:	ab ab       	std	Y+51, r26	; 0x33
    2ada:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    2adc:	69 a9       	ldd	r22, Y+49	; 0x31
    2ade:	7a a9       	ldd	r23, Y+50	; 0x32
    2ae0:	8b a9       	ldd	r24, Y+51	; 0x33
    2ae2:	9c a9       	ldd	r25, Y+52	; 0x34
    2ae4:	20 e0       	ldi	r18, 0x00	; 0
    2ae6:	30 e0       	ldi	r19, 0x00	; 0
    2ae8:	40 e8       	ldi	r20, 0x80	; 128
    2aea:	5f e3       	ldi	r21, 0x3F	; 63
    2aec:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2af0:	88 23       	and	r24, r24
    2af2:	2c f4       	brge	.+10     	; 0x2afe <LCD_VidInitialize+0x8c>
		__ticks = 1;
    2af4:	81 e0       	ldi	r24, 0x01	; 1
    2af6:	90 e0       	ldi	r25, 0x00	; 0
    2af8:	98 ab       	std	Y+48, r25	; 0x30
    2afa:	8f a7       	std	Y+47, r24	; 0x2f
    2afc:	3f c0       	rjmp	.+126    	; 0x2b7c <LCD_VidInitialize+0x10a>
	else if (__tmp > 65535)
    2afe:	69 a9       	ldd	r22, Y+49	; 0x31
    2b00:	7a a9       	ldd	r23, Y+50	; 0x32
    2b02:	8b a9       	ldd	r24, Y+51	; 0x33
    2b04:	9c a9       	ldd	r25, Y+52	; 0x34
    2b06:	20 e0       	ldi	r18, 0x00	; 0
    2b08:	3f ef       	ldi	r19, 0xFF	; 255
    2b0a:	4f e7       	ldi	r20, 0x7F	; 127
    2b0c:	57 e4       	ldi	r21, 0x47	; 71
    2b0e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2b12:	18 16       	cp	r1, r24
    2b14:	4c f5       	brge	.+82     	; 0x2b68 <LCD_VidInitialize+0xf6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2b16:	6d a9       	ldd	r22, Y+53	; 0x35
    2b18:	7e a9       	ldd	r23, Y+54	; 0x36
    2b1a:	8f a9       	ldd	r24, Y+55	; 0x37
    2b1c:	98 ad       	ldd	r25, Y+56	; 0x38
    2b1e:	20 e0       	ldi	r18, 0x00	; 0
    2b20:	30 e0       	ldi	r19, 0x00	; 0
    2b22:	40 e2       	ldi	r20, 0x20	; 32
    2b24:	51 e4       	ldi	r21, 0x41	; 65
    2b26:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b2a:	dc 01       	movw	r26, r24
    2b2c:	cb 01       	movw	r24, r22
    2b2e:	bc 01       	movw	r22, r24
    2b30:	cd 01       	movw	r24, r26
    2b32:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b36:	dc 01       	movw	r26, r24
    2b38:	cb 01       	movw	r24, r22
    2b3a:	98 ab       	std	Y+48, r25	; 0x30
    2b3c:	8f a7       	std	Y+47, r24	; 0x2f
    2b3e:	0f c0       	rjmp	.+30     	; 0x2b5e <LCD_VidInitialize+0xec>
    2b40:	88 ec       	ldi	r24, 0xC8	; 200
    2b42:	90 e0       	ldi	r25, 0x00	; 0
    2b44:	9e a7       	std	Y+46, r25	; 0x2e
    2b46:	8d a7       	std	Y+45, r24	; 0x2d
    2b48:	8d a5       	ldd	r24, Y+45	; 0x2d
    2b4a:	9e a5       	ldd	r25, Y+46	; 0x2e
    2b4c:	01 97       	sbiw	r24, 0x01	; 1
    2b4e:	f1 f7       	brne	.-4      	; 0x2b4c <LCD_VidInitialize+0xda>
    2b50:	9e a7       	std	Y+46, r25	; 0x2e
    2b52:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2b54:	8f a5       	ldd	r24, Y+47	; 0x2f
    2b56:	98 a9       	ldd	r25, Y+48	; 0x30
    2b58:	01 97       	sbiw	r24, 0x01	; 1
    2b5a:	98 ab       	std	Y+48, r25	; 0x30
    2b5c:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2b5e:	8f a5       	ldd	r24, Y+47	; 0x2f
    2b60:	98 a9       	ldd	r25, Y+48	; 0x30
    2b62:	00 97       	sbiw	r24, 0x00	; 0
    2b64:	69 f7       	brne	.-38     	; 0x2b40 <LCD_VidInitialize+0xce>
    2b66:	14 c0       	rjmp	.+40     	; 0x2b90 <LCD_VidInitialize+0x11e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2b68:	69 a9       	ldd	r22, Y+49	; 0x31
    2b6a:	7a a9       	ldd	r23, Y+50	; 0x32
    2b6c:	8b a9       	ldd	r24, Y+51	; 0x33
    2b6e:	9c a9       	ldd	r25, Y+52	; 0x34
    2b70:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b74:	dc 01       	movw	r26, r24
    2b76:	cb 01       	movw	r24, r22
    2b78:	98 ab       	std	Y+48, r25	; 0x30
    2b7a:	8f a7       	std	Y+47, r24	; 0x2f
    2b7c:	8f a5       	ldd	r24, Y+47	; 0x2f
    2b7e:	98 a9       	ldd	r25, Y+48	; 0x30
    2b80:	9c a7       	std	Y+44, r25	; 0x2c
    2b82:	8b a7       	std	Y+43, r24	; 0x2b
    2b84:	8b a5       	ldd	r24, Y+43	; 0x2b
    2b86:	9c a5       	ldd	r25, Y+44	; 0x2c
    2b88:	01 97       	sbiw	r24, 0x01	; 1
    2b8a:	f1 f7       	brne	.-4      	; 0x2b88 <LCD_VidInitialize+0x116>
    2b8c:	9c a7       	std	Y+44, r25	; 0x2c
    2b8e:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(35);

	LCD_VidSendCMD(FUN_SET);
    2b90:	88 e3       	ldi	r24, 0x38	; 56
    2b92:	0e 94 fd 13 	call	0x27fa	; 0x27fa <LCD_VidSendCMD>
    2b96:	80 e0       	ldi	r24, 0x00	; 0
    2b98:	90 e0       	ldi	r25, 0x00	; 0
    2b9a:	a0 e8       	ldi	r26, 0x80	; 128
    2b9c:	bf e3       	ldi	r27, 0x3F	; 63
    2b9e:	8f a3       	std	Y+39, r24	; 0x27
    2ba0:	98 a7       	std	Y+40, r25	; 0x28
    2ba2:	a9 a7       	std	Y+41, r26	; 0x29
    2ba4:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2ba6:	6f a1       	ldd	r22, Y+39	; 0x27
    2ba8:	78 a5       	ldd	r23, Y+40	; 0x28
    2baa:	89 a5       	ldd	r24, Y+41	; 0x29
    2bac:	9a a5       	ldd	r25, Y+42	; 0x2a
    2bae:	20 e0       	ldi	r18, 0x00	; 0
    2bb0:	30 e0       	ldi	r19, 0x00	; 0
    2bb2:	4a ef       	ldi	r20, 0xFA	; 250
    2bb4:	54 e4       	ldi	r21, 0x44	; 68
    2bb6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2bba:	dc 01       	movw	r26, r24
    2bbc:	cb 01       	movw	r24, r22
    2bbe:	8b a3       	std	Y+35, r24	; 0x23
    2bc0:	9c a3       	std	Y+36, r25	; 0x24
    2bc2:	ad a3       	std	Y+37, r26	; 0x25
    2bc4:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    2bc6:	6b a1       	ldd	r22, Y+35	; 0x23
    2bc8:	7c a1       	ldd	r23, Y+36	; 0x24
    2bca:	8d a1       	ldd	r24, Y+37	; 0x25
    2bcc:	9e a1       	ldd	r25, Y+38	; 0x26
    2bce:	20 e0       	ldi	r18, 0x00	; 0
    2bd0:	30 e0       	ldi	r19, 0x00	; 0
    2bd2:	40 e8       	ldi	r20, 0x80	; 128
    2bd4:	5f e3       	ldi	r21, 0x3F	; 63
    2bd6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2bda:	88 23       	and	r24, r24
    2bdc:	2c f4       	brge	.+10     	; 0x2be8 <LCD_VidInitialize+0x176>
		__ticks = 1;
    2bde:	81 e0       	ldi	r24, 0x01	; 1
    2be0:	90 e0       	ldi	r25, 0x00	; 0
    2be2:	9a a3       	std	Y+34, r25	; 0x22
    2be4:	89 a3       	std	Y+33, r24	; 0x21
    2be6:	3f c0       	rjmp	.+126    	; 0x2c66 <LCD_VidInitialize+0x1f4>
	else if (__tmp > 65535)
    2be8:	6b a1       	ldd	r22, Y+35	; 0x23
    2bea:	7c a1       	ldd	r23, Y+36	; 0x24
    2bec:	8d a1       	ldd	r24, Y+37	; 0x25
    2bee:	9e a1       	ldd	r25, Y+38	; 0x26
    2bf0:	20 e0       	ldi	r18, 0x00	; 0
    2bf2:	3f ef       	ldi	r19, 0xFF	; 255
    2bf4:	4f e7       	ldi	r20, 0x7F	; 127
    2bf6:	57 e4       	ldi	r21, 0x47	; 71
    2bf8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2bfc:	18 16       	cp	r1, r24
    2bfe:	4c f5       	brge	.+82     	; 0x2c52 <LCD_VidInitialize+0x1e0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2c00:	6f a1       	ldd	r22, Y+39	; 0x27
    2c02:	78 a5       	ldd	r23, Y+40	; 0x28
    2c04:	89 a5       	ldd	r24, Y+41	; 0x29
    2c06:	9a a5       	ldd	r25, Y+42	; 0x2a
    2c08:	20 e0       	ldi	r18, 0x00	; 0
    2c0a:	30 e0       	ldi	r19, 0x00	; 0
    2c0c:	40 e2       	ldi	r20, 0x20	; 32
    2c0e:	51 e4       	ldi	r21, 0x41	; 65
    2c10:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2c14:	dc 01       	movw	r26, r24
    2c16:	cb 01       	movw	r24, r22
    2c18:	bc 01       	movw	r22, r24
    2c1a:	cd 01       	movw	r24, r26
    2c1c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2c20:	dc 01       	movw	r26, r24
    2c22:	cb 01       	movw	r24, r22
    2c24:	9a a3       	std	Y+34, r25	; 0x22
    2c26:	89 a3       	std	Y+33, r24	; 0x21
    2c28:	0f c0       	rjmp	.+30     	; 0x2c48 <LCD_VidInitialize+0x1d6>
    2c2a:	88 ec       	ldi	r24, 0xC8	; 200
    2c2c:	90 e0       	ldi	r25, 0x00	; 0
    2c2e:	98 a3       	std	Y+32, r25	; 0x20
    2c30:	8f 8f       	std	Y+31, r24	; 0x1f
    2c32:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2c34:	98 a1       	ldd	r25, Y+32	; 0x20
    2c36:	01 97       	sbiw	r24, 0x01	; 1
    2c38:	f1 f7       	brne	.-4      	; 0x2c36 <LCD_VidInitialize+0x1c4>
    2c3a:	98 a3       	std	Y+32, r25	; 0x20
    2c3c:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2c3e:	89 a1       	ldd	r24, Y+33	; 0x21
    2c40:	9a a1       	ldd	r25, Y+34	; 0x22
    2c42:	01 97       	sbiw	r24, 0x01	; 1
    2c44:	9a a3       	std	Y+34, r25	; 0x22
    2c46:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2c48:	89 a1       	ldd	r24, Y+33	; 0x21
    2c4a:	9a a1       	ldd	r25, Y+34	; 0x22
    2c4c:	00 97       	sbiw	r24, 0x00	; 0
    2c4e:	69 f7       	brne	.-38     	; 0x2c2a <LCD_VidInitialize+0x1b8>
    2c50:	14 c0       	rjmp	.+40     	; 0x2c7a <LCD_VidInitialize+0x208>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2c52:	6b a1       	ldd	r22, Y+35	; 0x23
    2c54:	7c a1       	ldd	r23, Y+36	; 0x24
    2c56:	8d a1       	ldd	r24, Y+37	; 0x25
    2c58:	9e a1       	ldd	r25, Y+38	; 0x26
    2c5a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2c5e:	dc 01       	movw	r26, r24
    2c60:	cb 01       	movw	r24, r22
    2c62:	9a a3       	std	Y+34, r25	; 0x22
    2c64:	89 a3       	std	Y+33, r24	; 0x21
    2c66:	89 a1       	ldd	r24, Y+33	; 0x21
    2c68:	9a a1       	ldd	r25, Y+34	; 0x22
    2c6a:	9e 8f       	std	Y+30, r25	; 0x1e
    2c6c:	8d 8f       	std	Y+29, r24	; 0x1d
    2c6e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2c70:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2c72:	01 97       	sbiw	r24, 0x01	; 1
    2c74:	f1 f7       	brne	.-4      	; 0x2c72 <LCD_VidInitialize+0x200>
    2c76:	9e 8f       	std	Y+30, r25	; 0x1e
    2c78:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);

	LCD_VidSendCMD(LCD_ON_OFF);
    2c7a:	8f e0       	ldi	r24, 0x0F	; 15
    2c7c:	0e 94 fd 13 	call	0x27fa	; 0x27fa <LCD_VidSendCMD>
    2c80:	80 e0       	ldi	r24, 0x00	; 0
    2c82:	90 e0       	ldi	r25, 0x00	; 0
    2c84:	a0 e8       	ldi	r26, 0x80	; 128
    2c86:	bf e3       	ldi	r27, 0x3F	; 63
    2c88:	89 8f       	std	Y+25, r24	; 0x19
    2c8a:	9a 8f       	std	Y+26, r25	; 0x1a
    2c8c:	ab 8f       	std	Y+27, r26	; 0x1b
    2c8e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2c90:	69 8d       	ldd	r22, Y+25	; 0x19
    2c92:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2c94:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2c96:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2c98:	20 e0       	ldi	r18, 0x00	; 0
    2c9a:	30 e0       	ldi	r19, 0x00	; 0
    2c9c:	4a ef       	ldi	r20, 0xFA	; 250
    2c9e:	54 e4       	ldi	r21, 0x44	; 68
    2ca0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2ca4:	dc 01       	movw	r26, r24
    2ca6:	cb 01       	movw	r24, r22
    2ca8:	8d 8b       	std	Y+21, r24	; 0x15
    2caa:	9e 8b       	std	Y+22, r25	; 0x16
    2cac:	af 8b       	std	Y+23, r26	; 0x17
    2cae:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    2cb0:	6d 89       	ldd	r22, Y+21	; 0x15
    2cb2:	7e 89       	ldd	r23, Y+22	; 0x16
    2cb4:	8f 89       	ldd	r24, Y+23	; 0x17
    2cb6:	98 8d       	ldd	r25, Y+24	; 0x18
    2cb8:	20 e0       	ldi	r18, 0x00	; 0
    2cba:	30 e0       	ldi	r19, 0x00	; 0
    2cbc:	40 e8       	ldi	r20, 0x80	; 128
    2cbe:	5f e3       	ldi	r21, 0x3F	; 63
    2cc0:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2cc4:	88 23       	and	r24, r24
    2cc6:	2c f4       	brge	.+10     	; 0x2cd2 <LCD_VidInitialize+0x260>
		__ticks = 1;
    2cc8:	81 e0       	ldi	r24, 0x01	; 1
    2cca:	90 e0       	ldi	r25, 0x00	; 0
    2ccc:	9c 8b       	std	Y+20, r25	; 0x14
    2cce:	8b 8b       	std	Y+19, r24	; 0x13
    2cd0:	3f c0       	rjmp	.+126    	; 0x2d50 <LCD_VidInitialize+0x2de>
	else if (__tmp > 65535)
    2cd2:	6d 89       	ldd	r22, Y+21	; 0x15
    2cd4:	7e 89       	ldd	r23, Y+22	; 0x16
    2cd6:	8f 89       	ldd	r24, Y+23	; 0x17
    2cd8:	98 8d       	ldd	r25, Y+24	; 0x18
    2cda:	20 e0       	ldi	r18, 0x00	; 0
    2cdc:	3f ef       	ldi	r19, 0xFF	; 255
    2cde:	4f e7       	ldi	r20, 0x7F	; 127
    2ce0:	57 e4       	ldi	r21, 0x47	; 71
    2ce2:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2ce6:	18 16       	cp	r1, r24
    2ce8:	4c f5       	brge	.+82     	; 0x2d3c <LCD_VidInitialize+0x2ca>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2cea:	69 8d       	ldd	r22, Y+25	; 0x19
    2cec:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2cee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2cf0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2cf2:	20 e0       	ldi	r18, 0x00	; 0
    2cf4:	30 e0       	ldi	r19, 0x00	; 0
    2cf6:	40 e2       	ldi	r20, 0x20	; 32
    2cf8:	51 e4       	ldi	r21, 0x41	; 65
    2cfa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2cfe:	dc 01       	movw	r26, r24
    2d00:	cb 01       	movw	r24, r22
    2d02:	bc 01       	movw	r22, r24
    2d04:	cd 01       	movw	r24, r26
    2d06:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2d0a:	dc 01       	movw	r26, r24
    2d0c:	cb 01       	movw	r24, r22
    2d0e:	9c 8b       	std	Y+20, r25	; 0x14
    2d10:	8b 8b       	std	Y+19, r24	; 0x13
    2d12:	0f c0       	rjmp	.+30     	; 0x2d32 <LCD_VidInitialize+0x2c0>
    2d14:	88 ec       	ldi	r24, 0xC8	; 200
    2d16:	90 e0       	ldi	r25, 0x00	; 0
    2d18:	9a 8b       	std	Y+18, r25	; 0x12
    2d1a:	89 8b       	std	Y+17, r24	; 0x11
    2d1c:	89 89       	ldd	r24, Y+17	; 0x11
    2d1e:	9a 89       	ldd	r25, Y+18	; 0x12
    2d20:	01 97       	sbiw	r24, 0x01	; 1
    2d22:	f1 f7       	brne	.-4      	; 0x2d20 <LCD_VidInitialize+0x2ae>
    2d24:	9a 8b       	std	Y+18, r25	; 0x12
    2d26:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2d28:	8b 89       	ldd	r24, Y+19	; 0x13
    2d2a:	9c 89       	ldd	r25, Y+20	; 0x14
    2d2c:	01 97       	sbiw	r24, 0x01	; 1
    2d2e:	9c 8b       	std	Y+20, r25	; 0x14
    2d30:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2d32:	8b 89       	ldd	r24, Y+19	; 0x13
    2d34:	9c 89       	ldd	r25, Y+20	; 0x14
    2d36:	00 97       	sbiw	r24, 0x00	; 0
    2d38:	69 f7       	brne	.-38     	; 0x2d14 <LCD_VidInitialize+0x2a2>
    2d3a:	14 c0       	rjmp	.+40     	; 0x2d64 <LCD_VidInitialize+0x2f2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2d3c:	6d 89       	ldd	r22, Y+21	; 0x15
    2d3e:	7e 89       	ldd	r23, Y+22	; 0x16
    2d40:	8f 89       	ldd	r24, Y+23	; 0x17
    2d42:	98 8d       	ldd	r25, Y+24	; 0x18
    2d44:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2d48:	dc 01       	movw	r26, r24
    2d4a:	cb 01       	movw	r24, r22
    2d4c:	9c 8b       	std	Y+20, r25	; 0x14
    2d4e:	8b 8b       	std	Y+19, r24	; 0x13
    2d50:	8b 89       	ldd	r24, Y+19	; 0x13
    2d52:	9c 89       	ldd	r25, Y+20	; 0x14
    2d54:	98 8b       	std	Y+16, r25	; 0x10
    2d56:	8f 87       	std	Y+15, r24	; 0x0f
    2d58:	8f 85       	ldd	r24, Y+15	; 0x0f
    2d5a:	98 89       	ldd	r25, Y+16	; 0x10
    2d5c:	01 97       	sbiw	r24, 0x01	; 1
    2d5e:	f1 f7       	brne	.-4      	; 0x2d5c <LCD_VidInitialize+0x2ea>
    2d60:	98 8b       	std	Y+16, r25	; 0x10
    2d62:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(1);

	LCD_VidSendCMD(LCD_CLEAER);
    2d64:	81 e0       	ldi	r24, 0x01	; 1
    2d66:	0e 94 fd 13 	call	0x27fa	; 0x27fa <LCD_VidSendCMD>
    2d6a:	80 e0       	ldi	r24, 0x00	; 0
    2d6c:	90 e0       	ldi	r25, 0x00	; 0
    2d6e:	a0 e0       	ldi	r26, 0x00	; 0
    2d70:	b0 e4       	ldi	r27, 0x40	; 64
    2d72:	8b 87       	std	Y+11, r24	; 0x0b
    2d74:	9c 87       	std	Y+12, r25	; 0x0c
    2d76:	ad 87       	std	Y+13, r26	; 0x0d
    2d78:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2d7a:	6b 85       	ldd	r22, Y+11	; 0x0b
    2d7c:	7c 85       	ldd	r23, Y+12	; 0x0c
    2d7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2d80:	9e 85       	ldd	r25, Y+14	; 0x0e
    2d82:	20 e0       	ldi	r18, 0x00	; 0
    2d84:	30 e0       	ldi	r19, 0x00	; 0
    2d86:	4a ef       	ldi	r20, 0xFA	; 250
    2d88:	54 e4       	ldi	r21, 0x44	; 68
    2d8a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2d8e:	dc 01       	movw	r26, r24
    2d90:	cb 01       	movw	r24, r22
    2d92:	8f 83       	std	Y+7, r24	; 0x07
    2d94:	98 87       	std	Y+8, r25	; 0x08
    2d96:	a9 87       	std	Y+9, r26	; 0x09
    2d98:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2d9a:	6f 81       	ldd	r22, Y+7	; 0x07
    2d9c:	78 85       	ldd	r23, Y+8	; 0x08
    2d9e:	89 85       	ldd	r24, Y+9	; 0x09
    2da0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2da2:	20 e0       	ldi	r18, 0x00	; 0
    2da4:	30 e0       	ldi	r19, 0x00	; 0
    2da6:	40 e8       	ldi	r20, 0x80	; 128
    2da8:	5f e3       	ldi	r21, 0x3F	; 63
    2daa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2dae:	88 23       	and	r24, r24
    2db0:	2c f4       	brge	.+10     	; 0x2dbc <LCD_VidInitialize+0x34a>
		__ticks = 1;
    2db2:	81 e0       	ldi	r24, 0x01	; 1
    2db4:	90 e0       	ldi	r25, 0x00	; 0
    2db6:	9e 83       	std	Y+6, r25	; 0x06
    2db8:	8d 83       	std	Y+5, r24	; 0x05
    2dba:	3f c0       	rjmp	.+126    	; 0x2e3a <LCD_VidInitialize+0x3c8>
	else if (__tmp > 65535)
    2dbc:	6f 81       	ldd	r22, Y+7	; 0x07
    2dbe:	78 85       	ldd	r23, Y+8	; 0x08
    2dc0:	89 85       	ldd	r24, Y+9	; 0x09
    2dc2:	9a 85       	ldd	r25, Y+10	; 0x0a
    2dc4:	20 e0       	ldi	r18, 0x00	; 0
    2dc6:	3f ef       	ldi	r19, 0xFF	; 255
    2dc8:	4f e7       	ldi	r20, 0x7F	; 127
    2dca:	57 e4       	ldi	r21, 0x47	; 71
    2dcc:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2dd0:	18 16       	cp	r1, r24
    2dd2:	4c f5       	brge	.+82     	; 0x2e26 <LCD_VidInitialize+0x3b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2dd4:	6b 85       	ldd	r22, Y+11	; 0x0b
    2dd6:	7c 85       	ldd	r23, Y+12	; 0x0c
    2dd8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2dda:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ddc:	20 e0       	ldi	r18, 0x00	; 0
    2dde:	30 e0       	ldi	r19, 0x00	; 0
    2de0:	40 e2       	ldi	r20, 0x20	; 32
    2de2:	51 e4       	ldi	r21, 0x41	; 65
    2de4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2de8:	dc 01       	movw	r26, r24
    2dea:	cb 01       	movw	r24, r22
    2dec:	bc 01       	movw	r22, r24
    2dee:	cd 01       	movw	r24, r26
    2df0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2df4:	dc 01       	movw	r26, r24
    2df6:	cb 01       	movw	r24, r22
    2df8:	9e 83       	std	Y+6, r25	; 0x06
    2dfa:	8d 83       	std	Y+5, r24	; 0x05
    2dfc:	0f c0       	rjmp	.+30     	; 0x2e1c <LCD_VidInitialize+0x3aa>
    2dfe:	88 ec       	ldi	r24, 0xC8	; 200
    2e00:	90 e0       	ldi	r25, 0x00	; 0
    2e02:	9c 83       	std	Y+4, r25	; 0x04
    2e04:	8b 83       	std	Y+3, r24	; 0x03
    2e06:	8b 81       	ldd	r24, Y+3	; 0x03
    2e08:	9c 81       	ldd	r25, Y+4	; 0x04
    2e0a:	01 97       	sbiw	r24, 0x01	; 1
    2e0c:	f1 f7       	brne	.-4      	; 0x2e0a <LCD_VidInitialize+0x398>
    2e0e:	9c 83       	std	Y+4, r25	; 0x04
    2e10:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e12:	8d 81       	ldd	r24, Y+5	; 0x05
    2e14:	9e 81       	ldd	r25, Y+6	; 0x06
    2e16:	01 97       	sbiw	r24, 0x01	; 1
    2e18:	9e 83       	std	Y+6, r25	; 0x06
    2e1a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e1c:	8d 81       	ldd	r24, Y+5	; 0x05
    2e1e:	9e 81       	ldd	r25, Y+6	; 0x06
    2e20:	00 97       	sbiw	r24, 0x00	; 0
    2e22:	69 f7       	brne	.-38     	; 0x2dfe <LCD_VidInitialize+0x38c>
    2e24:	14 c0       	rjmp	.+40     	; 0x2e4e <LCD_VidInitialize+0x3dc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2e26:	6f 81       	ldd	r22, Y+7	; 0x07
    2e28:	78 85       	ldd	r23, Y+8	; 0x08
    2e2a:	89 85       	ldd	r24, Y+9	; 0x09
    2e2c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2e2e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2e32:	dc 01       	movw	r26, r24
    2e34:	cb 01       	movw	r24, r22
    2e36:	9e 83       	std	Y+6, r25	; 0x06
    2e38:	8d 83       	std	Y+5, r24	; 0x05
    2e3a:	8d 81       	ldd	r24, Y+5	; 0x05
    2e3c:	9e 81       	ldd	r25, Y+6	; 0x06
    2e3e:	9a 83       	std	Y+2, r25	; 0x02
    2e40:	89 83       	std	Y+1, r24	; 0x01
    2e42:	89 81       	ldd	r24, Y+1	; 0x01
    2e44:	9a 81       	ldd	r25, Y+2	; 0x02
    2e46:	01 97       	sbiw	r24, 0x01	; 1
    2e48:	f1 f7       	brne	.-4      	; 0x2e46 <LCD_VidInitialize+0x3d4>
    2e4a:	9a 83       	std	Y+2, r25	; 0x02
    2e4c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);

}
    2e4e:	e8 96       	adiw	r28, 0x38	; 56
    2e50:	0f b6       	in	r0, 0x3f	; 63
    2e52:	f8 94       	cli
    2e54:	de bf       	out	0x3e, r29	; 62
    2e56:	0f be       	out	0x3f, r0	; 63
    2e58:	cd bf       	out	0x3d, r28	; 61
    2e5a:	cf 91       	pop	r28
    2e5c:	df 91       	pop	r29
    2e5e:	08 95       	ret

00002e60 <LCD_VidSendString>:

void LCD_VidSendString(u8 *Copy_u8String)
{
    2e60:	df 93       	push	r29
    2e62:	cf 93       	push	r28
    2e64:	00 d0       	rcall	.+0      	; 0x2e66 <LCD_VidSendString+0x6>
    2e66:	cd b7       	in	r28, 0x3d	; 61
    2e68:	de b7       	in	r29, 0x3e	; 62
    2e6a:	9a 83       	std	Y+2, r25	; 0x02
    2e6c:	89 83       	std	Y+1, r24	; 0x01
    2e6e:	0b c0       	rjmp	.+22     	; 0x2e86 <LCD_VidSendString+0x26>
	while(*Copy_u8String)
	{
		LCD_VidSendChar(*Copy_u8String++);
    2e70:	e9 81       	ldd	r30, Y+1	; 0x01
    2e72:	fa 81       	ldd	r31, Y+2	; 0x02
    2e74:	20 81       	ld	r18, Z
    2e76:	89 81       	ldd	r24, Y+1	; 0x01
    2e78:	9a 81       	ldd	r25, Y+2	; 0x02
    2e7a:	01 96       	adiw	r24, 0x01	; 1
    2e7c:	9a 83       	std	Y+2, r25	; 0x02
    2e7e:	89 83       	std	Y+1, r24	; 0x01
    2e80:	82 2f       	mov	r24, r18
    2e82:	0e 94 9b 14 	call	0x2936	; 0x2936 <LCD_VidSendChar>

}

void LCD_VidSendString(u8 *Copy_u8String)
{
	while(*Copy_u8String)
    2e86:	e9 81       	ldd	r30, Y+1	; 0x01
    2e88:	fa 81       	ldd	r31, Y+2	; 0x02
    2e8a:	80 81       	ld	r24, Z
    2e8c:	88 23       	and	r24, r24
    2e8e:	81 f7       	brne	.-32     	; 0x2e70 <LCD_VidSendString+0x10>
	{
		LCD_VidSendChar(*Copy_u8String++);
	}
}
    2e90:	0f 90       	pop	r0
    2e92:	0f 90       	pop	r0
    2e94:	cf 91       	pop	r28
    2e96:	df 91       	pop	r29
    2e98:	08 95       	ret

00002e9a <LCD_VidSendLocation>:

void LCD_VidSendLocation(u8 Copy_u8LineNumber ,u8 Copy_u8CharNumber )
{
    2e9a:	df 93       	push	r29
    2e9c:	cf 93       	push	r28
    2e9e:	00 d0       	rcall	.+0      	; 0x2ea0 <LCD_VidSendLocation+0x6>
    2ea0:	00 d0       	rcall	.+0      	; 0x2ea2 <LCD_VidSendLocation+0x8>
    2ea2:	cd b7       	in	r28, 0x3d	; 61
    2ea4:	de b7       	in	r29, 0x3e	; 62
    2ea6:	89 83       	std	Y+1, r24	; 0x01
    2ea8:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8LineNumber)
    2eaa:	89 81       	ldd	r24, Y+1	; 0x01
    2eac:	28 2f       	mov	r18, r24
    2eae:	30 e0       	ldi	r19, 0x00	; 0
    2eb0:	3c 83       	std	Y+4, r19	; 0x04
    2eb2:	2b 83       	std	Y+3, r18	; 0x03
    2eb4:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb6:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb8:	00 97       	sbiw	r24, 0x00	; 0
    2eba:	31 f0       	breq	.+12     	; 0x2ec8 <LCD_VidSendLocation+0x2e>
    2ebc:	2b 81       	ldd	r18, Y+3	; 0x03
    2ebe:	3c 81       	ldd	r19, Y+4	; 0x04
    2ec0:	21 30       	cpi	r18, 0x01	; 1
    2ec2:	31 05       	cpc	r19, r1
    2ec4:	31 f0       	breq	.+12     	; 0x2ed2 <LCD_VidSendLocation+0x38>
    2ec6:	09 c0       	rjmp	.+18     	; 0x2eda <LCD_VidSendLocation+0x40>
	{
		case LINE_1 :
			LCD_VidSendCMD(0x80+Copy_u8CharNumber);
    2ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eca:	80 58       	subi	r24, 0x80	; 128
    2ecc:	0e 94 fd 13 	call	0x27fa	; 0x27fa <LCD_VidSendCMD>
    2ed0:	04 c0       	rjmp	.+8      	; 0x2eda <LCD_VidSendLocation+0x40>
		break ;
		case LINE_2 :
			LCD_VidSendCMD(0xC0+Copy_u8CharNumber);
    2ed2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ed4:	80 54       	subi	r24, 0x40	; 64
    2ed6:	0e 94 fd 13 	call	0x27fa	; 0x27fa <LCD_VidSendCMD>
		break ;
	}
}
    2eda:	0f 90       	pop	r0
    2edc:	0f 90       	pop	r0
    2ede:	0f 90       	pop	r0
    2ee0:	0f 90       	pop	r0
    2ee2:	cf 91       	pop	r28
    2ee4:	df 91       	pop	r29
    2ee6:	08 95       	ret

00002ee8 <LCD_VidSendCustomChar>:


void LCD_VidSendCustomChar(u8 *Copy_u8Char ,u8 Copy_u8CharNumber , u8 Copy_u8LineNumber)
{
    2ee8:	df 93       	push	r29
    2eea:	cf 93       	push	r28
    2eec:	00 d0       	rcall	.+0      	; 0x2eee <LCD_VidSendCustomChar+0x6>
    2eee:	00 d0       	rcall	.+0      	; 0x2ef0 <LCD_VidSendCustomChar+0x8>
    2ef0:	0f 92       	push	r0
    2ef2:	cd b7       	in	r28, 0x3d	; 61
    2ef4:	de b7       	in	r29, 0x3e	; 62
    2ef6:	9b 83       	std	Y+3, r25	; 0x03
    2ef8:	8a 83       	std	Y+2, r24	; 0x02
    2efa:	6c 83       	std	Y+4, r22	; 0x04
    2efc:	4d 83       	std	Y+5, r20	; 0x05
	u8 L_counter =0;
    2efe:	19 82       	std	Y+1, r1	; 0x01
	LCD_VidSendCMD(0x40+(Copy_u8CharNumber*8));
    2f00:	8c 81       	ldd	r24, Y+4	; 0x04
    2f02:	88 2f       	mov	r24, r24
    2f04:	90 e0       	ldi	r25, 0x00	; 0
    2f06:	08 96       	adiw	r24, 0x08	; 8
    2f08:	88 0f       	add	r24, r24
    2f0a:	99 1f       	adc	r25, r25
    2f0c:	88 0f       	add	r24, r24
    2f0e:	99 1f       	adc	r25, r25
    2f10:	88 0f       	add	r24, r24
    2f12:	99 1f       	adc	r25, r25
    2f14:	0e 94 fd 13 	call	0x27fa	; 0x27fa <LCD_VidSendCMD>
	for(L_counter = 0 ; L_counter < 8 ; L_counter++)
    2f18:	19 82       	std	Y+1, r1	; 0x01
    2f1a:	0e c0       	rjmp	.+28     	; 0x2f38 <LCD_VidSendCustomChar+0x50>
	{
		LCD_VidSendChar(Copy_u8Char[L_counter]);
    2f1c:	89 81       	ldd	r24, Y+1	; 0x01
    2f1e:	28 2f       	mov	r18, r24
    2f20:	30 e0       	ldi	r19, 0x00	; 0
    2f22:	8a 81       	ldd	r24, Y+2	; 0x02
    2f24:	9b 81       	ldd	r25, Y+3	; 0x03
    2f26:	fc 01       	movw	r30, r24
    2f28:	e2 0f       	add	r30, r18
    2f2a:	f3 1f       	adc	r31, r19
    2f2c:	80 81       	ld	r24, Z
    2f2e:	0e 94 9b 14 	call	0x2936	; 0x2936 <LCD_VidSendChar>

void LCD_VidSendCustomChar(u8 *Copy_u8Char ,u8 Copy_u8CharNumber , u8 Copy_u8LineNumber)
{
	u8 L_counter =0;
	LCD_VidSendCMD(0x40+(Copy_u8CharNumber*8));
	for(L_counter = 0 ; L_counter < 8 ; L_counter++)
    2f32:	89 81       	ldd	r24, Y+1	; 0x01
    2f34:	8f 5f       	subi	r24, 0xFF	; 255
    2f36:	89 83       	std	Y+1, r24	; 0x01
    2f38:	89 81       	ldd	r24, Y+1	; 0x01
    2f3a:	88 30       	cpi	r24, 0x08	; 8
    2f3c:	78 f3       	brcs	.-34     	; 0x2f1c <LCD_VidSendCustomChar+0x34>
	{
		LCD_VidSendChar(Copy_u8Char[L_counter]);
	}

	LCD_VidSendLocation(Copy_u8LineNumber,Copy_u8CharNumber);
    2f3e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f40:	6c 81       	ldd	r22, Y+4	; 0x04
    2f42:	0e 94 4d 17 	call	0x2e9a	; 0x2e9a <LCD_VidSendLocation>
	LCD_VidSendChar(Copy_u8CharNumber);
    2f46:	8c 81       	ldd	r24, Y+4	; 0x04
    2f48:	0e 94 9b 14 	call	0x2936	; 0x2936 <LCD_VidSendChar>
}
    2f4c:	0f 90       	pop	r0
    2f4e:	0f 90       	pop	r0
    2f50:	0f 90       	pop	r0
    2f52:	0f 90       	pop	r0
    2f54:	0f 90       	pop	r0
    2f56:	cf 91       	pop	r28
    2f58:	df 91       	pop	r29
    2f5a:	08 95       	ret

00002f5c <LCD_VidSendNumber>:

void LCD_VidSendNumber(u8 Copy_u8Num)
{
    2f5c:	df 93       	push	r29
    2f5e:	cf 93       	push	r28
    2f60:	00 d0       	rcall	.+0      	; 0x2f62 <LCD_VidSendNumber+0x6>
    2f62:	00 d0       	rcall	.+0      	; 0x2f64 <LCD_VidSendNumber+0x8>
    2f64:	cd b7       	in	r28, 0x3d	; 61
    2f66:	de b7       	in	r29, 0x3e	; 62
    2f68:	8c 83       	std	Y+4, r24	; 0x04
	u8 L_string[3];
	sprintf(&L_string,"%d",Copy_u8Num);
    2f6a:	8c 81       	ldd	r24, Y+4	; 0x04
    2f6c:	28 2f       	mov	r18, r24
    2f6e:	30 e0       	ldi	r19, 0x00	; 0
    2f70:	00 d0       	rcall	.+0      	; 0x2f72 <LCD_VidSendNumber+0x16>
    2f72:	00 d0       	rcall	.+0      	; 0x2f74 <LCD_VidSendNumber+0x18>
    2f74:	00 d0       	rcall	.+0      	; 0x2f76 <LCD_VidSendNumber+0x1a>
    2f76:	ed b7       	in	r30, 0x3d	; 61
    2f78:	fe b7       	in	r31, 0x3e	; 62
    2f7a:	31 96       	adiw	r30, 0x01	; 1
    2f7c:	ce 01       	movw	r24, r28
    2f7e:	01 96       	adiw	r24, 0x01	; 1
    2f80:	91 83       	std	Z+1, r25	; 0x01
    2f82:	80 83       	st	Z, r24
    2f84:	80 e6       	ldi	r24, 0x60	; 96
    2f86:	90 e0       	ldi	r25, 0x00	; 0
    2f88:	93 83       	std	Z+3, r25	; 0x03
    2f8a:	82 83       	std	Z+2, r24	; 0x02
    2f8c:	35 83       	std	Z+5, r19	; 0x05
    2f8e:	24 83       	std	Z+4, r18	; 0x04
    2f90:	0e 94 a0 2c 	call	0x5940	; 0x5940 <sprintf>
    2f94:	8d b7       	in	r24, 0x3d	; 61
    2f96:	9e b7       	in	r25, 0x3e	; 62
    2f98:	06 96       	adiw	r24, 0x06	; 6
    2f9a:	0f b6       	in	r0, 0x3f	; 63
    2f9c:	f8 94       	cli
    2f9e:	9e bf       	out	0x3e, r25	; 62
    2fa0:	0f be       	out	0x3f, r0	; 63
    2fa2:	8d bf       	out	0x3d, r24	; 61
	LCD_VidSendString(L_string);
    2fa4:	ce 01       	movw	r24, r28
    2fa6:	01 96       	adiw	r24, 0x01	; 1
    2fa8:	0e 94 30 17 	call	0x2e60	; 0x2e60 <LCD_VidSendString>
}
    2fac:	0f 90       	pop	r0
    2fae:	0f 90       	pop	r0
    2fb0:	0f 90       	pop	r0
    2fb2:	0f 90       	pop	r0
    2fb4:	cf 91       	pop	r28
    2fb6:	df 91       	pop	r29
    2fb8:	08 95       	ret

00002fba <LCD_VidSendNumberU16>:

void LCD_VidSendNumberU16(uint16 Copy_u16Num)
{
    2fba:	df 93       	push	r29
    2fbc:	cf 93       	push	r28
    2fbe:	cd b7       	in	r28, 0x3d	; 61
    2fc0:	de b7       	in	r29, 0x3e	; 62
    2fc2:	27 97       	sbiw	r28, 0x07	; 7
    2fc4:	0f b6       	in	r0, 0x3f	; 63
    2fc6:	f8 94       	cli
    2fc8:	de bf       	out	0x3e, r29	; 62
    2fca:	0f be       	out	0x3f, r0	; 63
    2fcc:	cd bf       	out	0x3d, r28	; 61
    2fce:	9f 83       	std	Y+7, r25	; 0x07
    2fd0:	8e 83       	std	Y+6, r24	; 0x06
	u8 L_string[5];
	sprintf(&L_string,"%d",Copy_u16Num);
    2fd2:	00 d0       	rcall	.+0      	; 0x2fd4 <LCD_VidSendNumberU16+0x1a>
    2fd4:	00 d0       	rcall	.+0      	; 0x2fd6 <LCD_VidSendNumberU16+0x1c>
    2fd6:	00 d0       	rcall	.+0      	; 0x2fd8 <LCD_VidSendNumberU16+0x1e>
    2fd8:	ed b7       	in	r30, 0x3d	; 61
    2fda:	fe b7       	in	r31, 0x3e	; 62
    2fdc:	31 96       	adiw	r30, 0x01	; 1
    2fde:	ce 01       	movw	r24, r28
    2fe0:	01 96       	adiw	r24, 0x01	; 1
    2fe2:	91 83       	std	Z+1, r25	; 0x01
    2fe4:	80 83       	st	Z, r24
    2fe6:	80 e6       	ldi	r24, 0x60	; 96
    2fe8:	90 e0       	ldi	r25, 0x00	; 0
    2fea:	93 83       	std	Z+3, r25	; 0x03
    2fec:	82 83       	std	Z+2, r24	; 0x02
    2fee:	8e 81       	ldd	r24, Y+6	; 0x06
    2ff0:	9f 81       	ldd	r25, Y+7	; 0x07
    2ff2:	95 83       	std	Z+5, r25	; 0x05
    2ff4:	84 83       	std	Z+4, r24	; 0x04
    2ff6:	0e 94 a0 2c 	call	0x5940	; 0x5940 <sprintf>
    2ffa:	8d b7       	in	r24, 0x3d	; 61
    2ffc:	9e b7       	in	r25, 0x3e	; 62
    2ffe:	06 96       	adiw	r24, 0x06	; 6
    3000:	0f b6       	in	r0, 0x3f	; 63
    3002:	f8 94       	cli
    3004:	9e bf       	out	0x3e, r25	; 62
    3006:	0f be       	out	0x3f, r0	; 63
    3008:	8d bf       	out	0x3d, r24	; 61
	LCD_VidSendString(L_string);
    300a:	ce 01       	movw	r24, r28
    300c:	01 96       	adiw	r24, 0x01	; 1
    300e:	0e 94 30 17 	call	0x2e60	; 0x2e60 <LCD_VidSendString>
}
    3012:	27 96       	adiw	r28, 0x07	; 7
    3014:	0f b6       	in	r0, 0x3f	; 63
    3016:	f8 94       	cli
    3018:	de bf       	out	0x3e, r29	; 62
    301a:	0f be       	out	0x3f, r0	; 63
    301c:	cd bf       	out	0x3d, r28	; 61
    301e:	cf 91       	pop	r28
    3020:	df 91       	pop	r29
    3022:	08 95       	ret

00003024 <LCD_CLEAR>:



void LCD_CLEAR(void)
{
    3024:	df 93       	push	r29
    3026:	cf 93       	push	r28
    3028:	cd b7       	in	r28, 0x3d	; 61
    302a:	de b7       	in	r29, 0x3e	; 62
    302c:	2e 97       	sbiw	r28, 0x0e	; 14
    302e:	0f b6       	in	r0, 0x3f	; 63
    3030:	f8 94       	cli
    3032:	de bf       	out	0x3e, r29	; 62
    3034:	0f be       	out	0x3f, r0	; 63
    3036:	cd bf       	out	0x3d, r28	; 61
	LCD_VidSendCMD(LCD_CLEAER);
    3038:	81 e0       	ldi	r24, 0x01	; 1
    303a:	0e 94 fd 13 	call	0x27fa	; 0x27fa <LCD_VidSendCMD>
    303e:	80 e0       	ldi	r24, 0x00	; 0
    3040:	90 e0       	ldi	r25, 0x00	; 0
    3042:	a0 e8       	ldi	r26, 0x80	; 128
    3044:	bf e3       	ldi	r27, 0x3F	; 63
    3046:	8b 87       	std	Y+11, r24	; 0x0b
    3048:	9c 87       	std	Y+12, r25	; 0x0c
    304a:	ad 87       	std	Y+13, r26	; 0x0d
    304c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    304e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3050:	7c 85       	ldd	r23, Y+12	; 0x0c
    3052:	8d 85       	ldd	r24, Y+13	; 0x0d
    3054:	9e 85       	ldd	r25, Y+14	; 0x0e
    3056:	20 e0       	ldi	r18, 0x00	; 0
    3058:	30 e0       	ldi	r19, 0x00	; 0
    305a:	4a ef       	ldi	r20, 0xFA	; 250
    305c:	54 e4       	ldi	r21, 0x44	; 68
    305e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3062:	dc 01       	movw	r26, r24
    3064:	cb 01       	movw	r24, r22
    3066:	8f 83       	std	Y+7, r24	; 0x07
    3068:	98 87       	std	Y+8, r25	; 0x08
    306a:	a9 87       	std	Y+9, r26	; 0x09
    306c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    306e:	6f 81       	ldd	r22, Y+7	; 0x07
    3070:	78 85       	ldd	r23, Y+8	; 0x08
    3072:	89 85       	ldd	r24, Y+9	; 0x09
    3074:	9a 85       	ldd	r25, Y+10	; 0x0a
    3076:	20 e0       	ldi	r18, 0x00	; 0
    3078:	30 e0       	ldi	r19, 0x00	; 0
    307a:	40 e8       	ldi	r20, 0x80	; 128
    307c:	5f e3       	ldi	r21, 0x3F	; 63
    307e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3082:	88 23       	and	r24, r24
    3084:	2c f4       	brge	.+10     	; 0x3090 <LCD_CLEAR+0x6c>
		__ticks = 1;
    3086:	81 e0       	ldi	r24, 0x01	; 1
    3088:	90 e0       	ldi	r25, 0x00	; 0
    308a:	9e 83       	std	Y+6, r25	; 0x06
    308c:	8d 83       	std	Y+5, r24	; 0x05
    308e:	3f c0       	rjmp	.+126    	; 0x310e <LCD_CLEAR+0xea>
	else if (__tmp > 65535)
    3090:	6f 81       	ldd	r22, Y+7	; 0x07
    3092:	78 85       	ldd	r23, Y+8	; 0x08
    3094:	89 85       	ldd	r24, Y+9	; 0x09
    3096:	9a 85       	ldd	r25, Y+10	; 0x0a
    3098:	20 e0       	ldi	r18, 0x00	; 0
    309a:	3f ef       	ldi	r19, 0xFF	; 255
    309c:	4f e7       	ldi	r20, 0x7F	; 127
    309e:	57 e4       	ldi	r21, 0x47	; 71
    30a0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    30a4:	18 16       	cp	r1, r24
    30a6:	4c f5       	brge	.+82     	; 0x30fa <LCD_CLEAR+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    30a8:	6b 85       	ldd	r22, Y+11	; 0x0b
    30aa:	7c 85       	ldd	r23, Y+12	; 0x0c
    30ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    30ae:	9e 85       	ldd	r25, Y+14	; 0x0e
    30b0:	20 e0       	ldi	r18, 0x00	; 0
    30b2:	30 e0       	ldi	r19, 0x00	; 0
    30b4:	40 e2       	ldi	r20, 0x20	; 32
    30b6:	51 e4       	ldi	r21, 0x41	; 65
    30b8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    30bc:	dc 01       	movw	r26, r24
    30be:	cb 01       	movw	r24, r22
    30c0:	bc 01       	movw	r22, r24
    30c2:	cd 01       	movw	r24, r26
    30c4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    30c8:	dc 01       	movw	r26, r24
    30ca:	cb 01       	movw	r24, r22
    30cc:	9e 83       	std	Y+6, r25	; 0x06
    30ce:	8d 83       	std	Y+5, r24	; 0x05
    30d0:	0f c0       	rjmp	.+30     	; 0x30f0 <LCD_CLEAR+0xcc>
    30d2:	88 ec       	ldi	r24, 0xC8	; 200
    30d4:	90 e0       	ldi	r25, 0x00	; 0
    30d6:	9c 83       	std	Y+4, r25	; 0x04
    30d8:	8b 83       	std	Y+3, r24	; 0x03
    30da:	8b 81       	ldd	r24, Y+3	; 0x03
    30dc:	9c 81       	ldd	r25, Y+4	; 0x04
    30de:	01 97       	sbiw	r24, 0x01	; 1
    30e0:	f1 f7       	brne	.-4      	; 0x30de <LCD_CLEAR+0xba>
    30e2:	9c 83       	std	Y+4, r25	; 0x04
    30e4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    30e6:	8d 81       	ldd	r24, Y+5	; 0x05
    30e8:	9e 81       	ldd	r25, Y+6	; 0x06
    30ea:	01 97       	sbiw	r24, 0x01	; 1
    30ec:	9e 83       	std	Y+6, r25	; 0x06
    30ee:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    30f0:	8d 81       	ldd	r24, Y+5	; 0x05
    30f2:	9e 81       	ldd	r25, Y+6	; 0x06
    30f4:	00 97       	sbiw	r24, 0x00	; 0
    30f6:	69 f7       	brne	.-38     	; 0x30d2 <LCD_CLEAR+0xae>
    30f8:	14 c0       	rjmp	.+40     	; 0x3122 <LCD_CLEAR+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    30fa:	6f 81       	ldd	r22, Y+7	; 0x07
    30fc:	78 85       	ldd	r23, Y+8	; 0x08
    30fe:	89 85       	ldd	r24, Y+9	; 0x09
    3100:	9a 85       	ldd	r25, Y+10	; 0x0a
    3102:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3106:	dc 01       	movw	r26, r24
    3108:	cb 01       	movw	r24, r22
    310a:	9e 83       	std	Y+6, r25	; 0x06
    310c:	8d 83       	std	Y+5, r24	; 0x05
    310e:	8d 81       	ldd	r24, Y+5	; 0x05
    3110:	9e 81       	ldd	r25, Y+6	; 0x06
    3112:	9a 83       	std	Y+2, r25	; 0x02
    3114:	89 83       	std	Y+1, r24	; 0x01
    3116:	89 81       	ldd	r24, Y+1	; 0x01
    3118:	9a 81       	ldd	r25, Y+2	; 0x02
    311a:	01 97       	sbiw	r24, 0x01	; 1
    311c:	f1 f7       	brne	.-4      	; 0x311a <LCD_CLEAR+0xf6>
    311e:	9a 83       	std	Y+2, r25	; 0x02
    3120:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
}
    3122:	2e 96       	adiw	r28, 0x0e	; 14
    3124:	0f b6       	in	r0, 0x3f	; 63
    3126:	f8 94       	cli
    3128:	de bf       	out	0x3e, r29	; 62
    312a:	0f be       	out	0x3f, r0	; 63
    312c:	cd bf       	out	0x3d, r28	; 61
    312e:	cf 91       	pop	r28
    3130:	df 91       	pop	r29
    3132:	08 95       	ret

00003134 <Segment_VidWriteNumber>:

 u8 arr_number[] = {0xFC,0x60,0xDA,0xF2,0x66,0xB6,0xBE,0xE0,0xFE,0xF6};


void Segment_VidWriteNumber(u8 Copy_u8Port , u8 Copy_u8Number)
{
    3134:	df 93       	push	r29
    3136:	cf 93       	push	r28
    3138:	00 d0       	rcall	.+0      	; 0x313a <Segment_VidWriteNumber+0x6>
    313a:	cd b7       	in	r28, 0x3d	; 61
    313c:	de b7       	in	r29, 0x3e	; 62
    313e:	89 83       	std	Y+1, r24	; 0x01
    3140:	6a 83       	std	Y+2, r22	; 0x02
	DIO_VidSetPortDirection(Copy_u8Port , 0xff);
    3142:	89 81       	ldd	r24, Y+1	; 0x01
    3144:	6f ef       	ldi	r22, 0xFF	; 255
    3146:	0e 94 c3 0b 	call	0x1786	; 0x1786 <DIO_VidSetPortDirection>
	DIO_VidSetPortValue(Copy_u8Port , arr_number[Copy_u8Number]);
    314a:	8a 81       	ldd	r24, Y+2	; 0x02
    314c:	88 2f       	mov	r24, r24
    314e:	90 e0       	ldi	r25, 0x00	; 0
    3150:	fc 01       	movw	r30, r24
    3152:	e8 57       	subi	r30, 0x78	; 120
    3154:	ff 4f       	sbci	r31, 0xFF	; 255
    3156:	90 81       	ld	r25, Z
    3158:	89 81       	ldd	r24, Y+1	; 0x01
    315a:	69 2f       	mov	r22, r25
    315c:	0e 94 04 0c 	call	0x1808	; 0x1808 <DIO_VidSetPortValue>
}
    3160:	0f 90       	pop	r0
    3162:	0f 90       	pop	r0
    3164:	cf 91       	pop	r28
    3166:	df 91       	pop	r29
    3168:	08 95       	ret

0000316a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    316a:	df 93       	push	r29
    316c:	cf 93       	push	r28
    316e:	cd b7       	in	r28, 0x3d	; 61
    3170:	de b7       	in	r29, 0x3e	; 62
    3172:	27 97       	sbiw	r28, 0x07	; 7
    3174:	0f b6       	in	r0, 0x3f	; 63
    3176:	f8 94       	cli
    3178:	de bf       	out	0x3e, r29	; 62
    317a:	0f be       	out	0x3f, r0	; 63
    317c:	cd bf       	out	0x3d, r28	; 61
    317e:	9d 83       	std	Y+5, r25	; 0x05
    3180:	8c 83       	std	Y+4, r24	; 0x04
    3182:	6e 83       	std	Y+6, r22	; 0x06
    3184:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    3186:	8a e1       	ldi	r24, 0x1A	; 26
    3188:	90 e0       	ldi	r25, 0x00	; 0
    318a:	0e 94 8d 1b 	call	0x371a	; 0x371a <pvPortMalloc>
    318e:	9a 83       	std	Y+2, r25	; 0x02
    3190:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    3192:	89 81       	ldd	r24, Y+1	; 0x01
    3194:	9a 81       	ldd	r25, Y+2	; 0x02
    3196:	00 97       	sbiw	r24, 0x00	; 0
    3198:	09 f4       	brne	.+2      	; 0x319c <xCoRoutineCreate+0x32>
    319a:	6f c0       	rjmp	.+222    	; 0x327a <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    319c:	80 91 a6 00 	lds	r24, 0x00A6
    31a0:	90 91 a7 00 	lds	r25, 0x00A7
    31a4:	00 97       	sbiw	r24, 0x00	; 0
    31a6:	41 f4       	brne	.+16     	; 0x31b8 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    31a8:	89 81       	ldd	r24, Y+1	; 0x01
    31aa:	9a 81       	ldd	r25, Y+2	; 0x02
    31ac:	90 93 a7 00 	sts	0x00A7, r25
    31b0:	80 93 a6 00 	sts	0x00A6, r24
			prvInitialiseCoRoutineLists();
    31b4:	0e 94 1c 1b 	call	0x3638	; 0x3638 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    31b8:	8e 81       	ldd	r24, Y+6	; 0x06
    31ba:	82 30       	cpi	r24, 0x02	; 2
    31bc:	10 f0       	brcs	.+4      	; 0x31c2 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    31be:	81 e0       	ldi	r24, 0x01	; 1
    31c0:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    31c2:	e9 81       	ldd	r30, Y+1	; 0x01
    31c4:	fa 81       	ldd	r31, Y+2	; 0x02
    31c6:	11 8e       	std	Z+25, r1	; 0x19
    31c8:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    31ca:	e9 81       	ldd	r30, Y+1	; 0x01
    31cc:	fa 81       	ldd	r31, Y+2	; 0x02
    31ce:	8e 81       	ldd	r24, Y+6	; 0x06
    31d0:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    31d2:	e9 81       	ldd	r30, Y+1	; 0x01
    31d4:	fa 81       	ldd	r31, Y+2	; 0x02
    31d6:	8f 81       	ldd	r24, Y+7	; 0x07
    31d8:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    31da:	e9 81       	ldd	r30, Y+1	; 0x01
    31dc:	fa 81       	ldd	r31, Y+2	; 0x02
    31de:	8c 81       	ldd	r24, Y+4	; 0x04
    31e0:	9d 81       	ldd	r25, Y+5	; 0x05
    31e2:	91 83       	std	Z+1, r25	; 0x01
    31e4:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    31e6:	89 81       	ldd	r24, Y+1	; 0x01
    31e8:	9a 81       	ldd	r25, Y+2	; 0x02
    31ea:	02 96       	adiw	r24, 0x02	; 2
    31ec:	0e 94 23 1c 	call	0x3846	; 0x3846 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    31f0:	89 81       	ldd	r24, Y+1	; 0x01
    31f2:	9a 81       	ldd	r25, Y+2	; 0x02
    31f4:	0c 96       	adiw	r24, 0x0c	; 12
    31f6:	0e 94 23 1c 	call	0x3846	; 0x3846 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    31fa:	e9 81       	ldd	r30, Y+1	; 0x01
    31fc:	fa 81       	ldd	r31, Y+2	; 0x02
    31fe:	89 81       	ldd	r24, Y+1	; 0x01
    3200:	9a 81       	ldd	r25, Y+2	; 0x02
    3202:	91 87       	std	Z+9, r25	; 0x09
    3204:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    3206:	e9 81       	ldd	r30, Y+1	; 0x01
    3208:	fa 81       	ldd	r31, Y+2	; 0x02
    320a:	89 81       	ldd	r24, Y+1	; 0x01
    320c:	9a 81       	ldd	r25, Y+2	; 0x02
    320e:	93 8b       	std	Z+19, r25	; 0x13
    3210:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    3212:	8e 81       	ldd	r24, Y+6	; 0x06
    3214:	28 2f       	mov	r18, r24
    3216:	30 e0       	ldi	r19, 0x00	; 0
    3218:	85 e0       	ldi	r24, 0x05	; 5
    321a:	90 e0       	ldi	r25, 0x00	; 0
    321c:	82 1b       	sub	r24, r18
    321e:	93 0b       	sbc	r25, r19
    3220:	e9 81       	ldd	r30, Y+1	; 0x01
    3222:	fa 81       	ldd	r31, Y+2	; 0x02
    3224:	95 87       	std	Z+13, r25	; 0x0d
    3226:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    3228:	e9 81       	ldd	r30, Y+1	; 0x01
    322a:	fa 81       	ldd	r31, Y+2	; 0x02
    322c:	96 89       	ldd	r25, Z+22	; 0x16
    322e:	80 91 a8 00 	lds	r24, 0x00A8
    3232:	89 17       	cp	r24, r25
    3234:	28 f4       	brcc	.+10     	; 0x3240 <xCoRoutineCreate+0xd6>
    3236:	e9 81       	ldd	r30, Y+1	; 0x01
    3238:	fa 81       	ldd	r31, Y+2	; 0x02
    323a:	86 89       	ldd	r24, Z+22	; 0x16
    323c:	80 93 a8 00 	sts	0x00A8, r24
    3240:	e9 81       	ldd	r30, Y+1	; 0x01
    3242:	fa 81       	ldd	r31, Y+2	; 0x02
    3244:	86 89       	ldd	r24, Z+22	; 0x16
    3246:	28 2f       	mov	r18, r24
    3248:	30 e0       	ldi	r19, 0x00	; 0
    324a:	c9 01       	movw	r24, r18
    324c:	88 0f       	add	r24, r24
    324e:	99 1f       	adc	r25, r25
    3250:	88 0f       	add	r24, r24
    3252:	99 1f       	adc	r25, r25
    3254:	88 0f       	add	r24, r24
    3256:	99 1f       	adc	r25, r25
    3258:	82 0f       	add	r24, r18
    325a:	93 1f       	adc	r25, r19
    325c:	ac 01       	movw	r20, r24
    325e:	41 55       	subi	r20, 0x51	; 81
    3260:	5f 4f       	sbci	r21, 0xFF	; 255
    3262:	89 81       	ldd	r24, Y+1	; 0x01
    3264:	9a 81       	ldd	r25, Y+2	; 0x02
    3266:	9c 01       	movw	r18, r24
    3268:	2e 5f       	subi	r18, 0xFE	; 254
    326a:	3f 4f       	sbci	r19, 0xFF	; 255
    326c:	ca 01       	movw	r24, r20
    326e:	b9 01       	movw	r22, r18
    3270:	0e 94 33 1c 	call	0x3866	; 0x3866 <vListInsertEnd>

		xReturn = pdPASS;
    3274:	81 e0       	ldi	r24, 0x01	; 1
    3276:	8b 83       	std	Y+3, r24	; 0x03
    3278:	02 c0       	rjmp	.+4      	; 0x327e <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    327a:	8f ef       	ldi	r24, 0xFF	; 255
    327c:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    327e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3280:	27 96       	adiw	r28, 0x07	; 7
    3282:	0f b6       	in	r0, 0x3f	; 63
    3284:	f8 94       	cli
    3286:	de bf       	out	0x3e, r29	; 62
    3288:	0f be       	out	0x3f, r0	; 63
    328a:	cd bf       	out	0x3d, r28	; 61
    328c:	cf 91       	pop	r28
    328e:	df 91       	pop	r29
    3290:	08 95       	ret

00003292 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    3292:	df 93       	push	r29
    3294:	cf 93       	push	r28
    3296:	00 d0       	rcall	.+0      	; 0x3298 <vCoRoutineAddToDelayedList+0x6>
    3298:	00 d0       	rcall	.+0      	; 0x329a <vCoRoutineAddToDelayedList+0x8>
    329a:	00 d0       	rcall	.+0      	; 0x329c <vCoRoutineAddToDelayedList+0xa>
    329c:	cd b7       	in	r28, 0x3d	; 61
    329e:	de b7       	in	r29, 0x3e	; 62
    32a0:	9c 83       	std	Y+4, r25	; 0x04
    32a2:	8b 83       	std	Y+3, r24	; 0x03
    32a4:	7e 83       	std	Y+6, r23	; 0x06
    32a6:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    32a8:	20 91 a9 00 	lds	r18, 0x00A9
    32ac:	30 91 aa 00 	lds	r19, 0x00AA
    32b0:	8b 81       	ldd	r24, Y+3	; 0x03
    32b2:	9c 81       	ldd	r25, Y+4	; 0x04
    32b4:	82 0f       	add	r24, r18
    32b6:	93 1f       	adc	r25, r19
    32b8:	9a 83       	std	Y+2, r25	; 0x02
    32ba:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    32bc:	80 91 a6 00 	lds	r24, 0x00A6
    32c0:	90 91 a7 00 	lds	r25, 0x00A7
    32c4:	02 96       	adiw	r24, 0x02	; 2
    32c6:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    32ca:	e0 91 a6 00 	lds	r30, 0x00A6
    32ce:	f0 91 a7 00 	lds	r31, 0x00A7
    32d2:	89 81       	ldd	r24, Y+1	; 0x01
    32d4:	9a 81       	ldd	r25, Y+2	; 0x02
    32d6:	93 83       	std	Z+3, r25	; 0x03
    32d8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    32da:	20 91 a9 00 	lds	r18, 0x00A9
    32de:	30 91 aa 00 	lds	r19, 0x00AA
    32e2:	89 81       	ldd	r24, Y+1	; 0x01
    32e4:	9a 81       	ldd	r25, Y+2	; 0x02
    32e6:	82 17       	cp	r24, r18
    32e8:	93 07       	cpc	r25, r19
    32ea:	70 f4       	brcc	.+28     	; 0x3308 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    32ec:	80 91 d5 00 	lds	r24, 0x00D5
    32f0:	90 91 d6 00 	lds	r25, 0x00D6
    32f4:	20 91 a6 00 	lds	r18, 0x00A6
    32f8:	30 91 a7 00 	lds	r19, 0x00A7
    32fc:	2e 5f       	subi	r18, 0xFE	; 254
    32fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3300:	b9 01       	movw	r22, r18
    3302:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <vListInsert>
    3306:	0d c0       	rjmp	.+26     	; 0x3322 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    3308:	80 91 d3 00 	lds	r24, 0x00D3
    330c:	90 91 d4 00 	lds	r25, 0x00D4
    3310:	20 91 a6 00 	lds	r18, 0x00A6
    3314:	30 91 a7 00 	lds	r19, 0x00A7
    3318:	2e 5f       	subi	r18, 0xFE	; 254
    331a:	3f 4f       	sbci	r19, 0xFF	; 255
    331c:	b9 01       	movw	r22, r18
    331e:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <vListInsert>
	}

	if( pxEventList )
    3322:	8d 81       	ldd	r24, Y+5	; 0x05
    3324:	9e 81       	ldd	r25, Y+6	; 0x06
    3326:	00 97       	sbiw	r24, 0x00	; 0
    3328:	61 f0       	breq	.+24     	; 0x3342 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    332a:	80 91 a6 00 	lds	r24, 0x00A6
    332e:	90 91 a7 00 	lds	r25, 0x00A7
    3332:	9c 01       	movw	r18, r24
    3334:	24 5f       	subi	r18, 0xF4	; 244
    3336:	3f 4f       	sbci	r19, 0xFF	; 255
    3338:	8d 81       	ldd	r24, Y+5	; 0x05
    333a:	9e 81       	ldd	r25, Y+6	; 0x06
    333c:	b9 01       	movw	r22, r18
    333e:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <vListInsert>
	}
}
    3342:	26 96       	adiw	r28, 0x06	; 6
    3344:	0f b6       	in	r0, 0x3f	; 63
    3346:	f8 94       	cli
    3348:	de bf       	out	0x3e, r29	; 62
    334a:	0f be       	out	0x3f, r0	; 63
    334c:	cd bf       	out	0x3d, r28	; 61
    334e:	cf 91       	pop	r28
    3350:	df 91       	pop	r29
    3352:	08 95       	ret

00003354 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    3354:	df 93       	push	r29
    3356:	cf 93       	push	r28
    3358:	00 d0       	rcall	.+0      	; 0x335a <prvCheckPendingReadyList+0x6>
    335a:	cd b7       	in	r28, 0x3d	; 61
    335c:	de b7       	in	r29, 0x3e	; 62
    335e:	3a c0       	rjmp	.+116    	; 0x33d4 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    3360:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    3362:	e0 91 dc 00 	lds	r30, 0x00DC
    3366:	f0 91 dd 00 	lds	r31, 0x00DD
    336a:	86 81       	ldd	r24, Z+6	; 0x06
    336c:	97 81       	ldd	r25, Z+7	; 0x07
    336e:	9a 83       	std	Y+2, r25	; 0x02
    3370:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    3372:	89 81       	ldd	r24, Y+1	; 0x01
    3374:	9a 81       	ldd	r25, Y+2	; 0x02
    3376:	0c 96       	adiw	r24, 0x0c	; 12
    3378:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    337c:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    337e:	89 81       	ldd	r24, Y+1	; 0x01
    3380:	9a 81       	ldd	r25, Y+2	; 0x02
    3382:	02 96       	adiw	r24, 0x02	; 2
    3384:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    3388:	e9 81       	ldd	r30, Y+1	; 0x01
    338a:	fa 81       	ldd	r31, Y+2	; 0x02
    338c:	96 89       	ldd	r25, Z+22	; 0x16
    338e:	80 91 a8 00 	lds	r24, 0x00A8
    3392:	89 17       	cp	r24, r25
    3394:	28 f4       	brcc	.+10     	; 0x33a0 <prvCheckPendingReadyList+0x4c>
    3396:	e9 81       	ldd	r30, Y+1	; 0x01
    3398:	fa 81       	ldd	r31, Y+2	; 0x02
    339a:	86 89       	ldd	r24, Z+22	; 0x16
    339c:	80 93 a8 00 	sts	0x00A8, r24
    33a0:	e9 81       	ldd	r30, Y+1	; 0x01
    33a2:	fa 81       	ldd	r31, Y+2	; 0x02
    33a4:	86 89       	ldd	r24, Z+22	; 0x16
    33a6:	28 2f       	mov	r18, r24
    33a8:	30 e0       	ldi	r19, 0x00	; 0
    33aa:	c9 01       	movw	r24, r18
    33ac:	88 0f       	add	r24, r24
    33ae:	99 1f       	adc	r25, r25
    33b0:	88 0f       	add	r24, r24
    33b2:	99 1f       	adc	r25, r25
    33b4:	88 0f       	add	r24, r24
    33b6:	99 1f       	adc	r25, r25
    33b8:	82 0f       	add	r24, r18
    33ba:	93 1f       	adc	r25, r19
    33bc:	ac 01       	movw	r20, r24
    33be:	41 55       	subi	r20, 0x51	; 81
    33c0:	5f 4f       	sbci	r21, 0xFF	; 255
    33c2:	89 81       	ldd	r24, Y+1	; 0x01
    33c4:	9a 81       	ldd	r25, Y+2	; 0x02
    33c6:	9c 01       	movw	r18, r24
    33c8:	2e 5f       	subi	r18, 0xFE	; 254
    33ca:	3f 4f       	sbci	r19, 0xFF	; 255
    33cc:	ca 01       	movw	r24, r20
    33ce:	b9 01       	movw	r22, r18
    33d0:	0e 94 33 1c 	call	0x3866	; 0x3866 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    33d4:	80 91 d7 00 	lds	r24, 0x00D7
    33d8:	88 23       	and	r24, r24
    33da:	09 f0       	breq	.+2      	; 0x33de <prvCheckPendingReadyList+0x8a>
    33dc:	c1 cf       	rjmp	.-126    	; 0x3360 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    33de:	0f 90       	pop	r0
    33e0:	0f 90       	pop	r0
    33e2:	cf 91       	pop	r28
    33e4:	df 91       	pop	r29
    33e6:	08 95       	ret

000033e8 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    33e8:	df 93       	push	r29
    33ea:	cf 93       	push	r28
    33ec:	00 d0       	rcall	.+0      	; 0x33ee <prvCheckDelayedList+0x6>
    33ee:	00 d0       	rcall	.+0      	; 0x33f0 <prvCheckDelayedList+0x8>
    33f0:	cd b7       	in	r28, 0x3d	; 61
    33f2:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    33f4:	0e 94 59 27 	call	0x4eb2	; 0x4eb2 <xTaskGetTickCount>
    33f8:	20 91 ab 00 	lds	r18, 0x00AB
    33fc:	30 91 ac 00 	lds	r19, 0x00AC
    3400:	82 1b       	sub	r24, r18
    3402:	93 0b       	sbc	r25, r19
    3404:	90 93 ae 00 	sts	0x00AE, r25
    3408:	80 93 ad 00 	sts	0x00AD, r24
    340c:	85 c0       	rjmp	.+266    	; 0x3518 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    340e:	80 91 a9 00 	lds	r24, 0x00A9
    3412:	90 91 aa 00 	lds	r25, 0x00AA
    3416:	01 96       	adiw	r24, 0x01	; 1
    3418:	90 93 aa 00 	sts	0x00AA, r25
    341c:	80 93 a9 00 	sts	0x00A9, r24
		xPassedTicks--;
    3420:	80 91 ad 00 	lds	r24, 0x00AD
    3424:	90 91 ae 00 	lds	r25, 0x00AE
    3428:	01 97       	sbiw	r24, 0x01	; 1
    342a:	90 93 ae 00 	sts	0x00AE, r25
    342e:	80 93 ad 00 	sts	0x00AD, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    3432:	80 91 a9 00 	lds	r24, 0x00A9
    3436:	90 91 aa 00 	lds	r25, 0x00AA
    343a:	00 97       	sbiw	r24, 0x00	; 0
    343c:	09 f0       	breq	.+2      	; 0x3440 <prvCheckDelayedList+0x58>
    343e:	64 c0       	rjmp	.+200    	; 0x3508 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    3440:	80 91 d3 00 	lds	r24, 0x00D3
    3444:	90 91 d4 00 	lds	r25, 0x00D4
    3448:	9a 83       	std	Y+2, r25	; 0x02
    344a:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    344c:	80 91 d5 00 	lds	r24, 0x00D5
    3450:	90 91 d6 00 	lds	r25, 0x00D6
    3454:	90 93 d4 00 	sts	0x00D4, r25
    3458:	80 93 d3 00 	sts	0x00D3, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    345c:	89 81       	ldd	r24, Y+1	; 0x01
    345e:	9a 81       	ldd	r25, Y+2	; 0x02
    3460:	90 93 d6 00 	sts	0x00D6, r25
    3464:	80 93 d5 00 	sts	0x00D5, r24
    3468:	4f c0       	rjmp	.+158    	; 0x3508 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    346a:	e0 91 d3 00 	lds	r30, 0x00D3
    346e:	f0 91 d4 00 	lds	r31, 0x00D4
    3472:	05 80       	ldd	r0, Z+5	; 0x05
    3474:	f6 81       	ldd	r31, Z+6	; 0x06
    3476:	e0 2d       	mov	r30, r0
    3478:	86 81       	ldd	r24, Z+6	; 0x06
    347a:	97 81       	ldd	r25, Z+7	; 0x07
    347c:	9c 83       	std	Y+4, r25	; 0x04
    347e:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    3480:	eb 81       	ldd	r30, Y+3	; 0x03
    3482:	fc 81       	ldd	r31, Y+4	; 0x04
    3484:	22 81       	ldd	r18, Z+2	; 0x02
    3486:	33 81       	ldd	r19, Z+3	; 0x03
    3488:	80 91 a9 00 	lds	r24, 0x00A9
    348c:	90 91 aa 00 	lds	r25, 0x00AA
    3490:	82 17       	cp	r24, r18
    3492:	93 07       	cpc	r25, r19
    3494:	08 f4       	brcc	.+2      	; 0x3498 <prvCheckDelayedList+0xb0>
    3496:	40 c0       	rjmp	.+128    	; 0x3518 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    3498:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    349a:	8b 81       	ldd	r24, Y+3	; 0x03
    349c:	9c 81       	ldd	r25, Y+4	; 0x04
    349e:	02 96       	adiw	r24, 0x02	; 2
    34a0:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    34a4:	eb 81       	ldd	r30, Y+3	; 0x03
    34a6:	fc 81       	ldd	r31, Y+4	; 0x04
    34a8:	84 89       	ldd	r24, Z+20	; 0x14
    34aa:	95 89       	ldd	r25, Z+21	; 0x15
    34ac:	00 97       	sbiw	r24, 0x00	; 0
    34ae:	29 f0       	breq	.+10     	; 0x34ba <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    34b0:	8b 81       	ldd	r24, Y+3	; 0x03
    34b2:	9c 81       	ldd	r25, Y+4	; 0x04
    34b4:	0c 96       	adiw	r24, 0x0c	; 12
    34b6:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    34ba:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    34bc:	eb 81       	ldd	r30, Y+3	; 0x03
    34be:	fc 81       	ldd	r31, Y+4	; 0x04
    34c0:	96 89       	ldd	r25, Z+22	; 0x16
    34c2:	80 91 a8 00 	lds	r24, 0x00A8
    34c6:	89 17       	cp	r24, r25
    34c8:	28 f4       	brcc	.+10     	; 0x34d4 <prvCheckDelayedList+0xec>
    34ca:	eb 81       	ldd	r30, Y+3	; 0x03
    34cc:	fc 81       	ldd	r31, Y+4	; 0x04
    34ce:	86 89       	ldd	r24, Z+22	; 0x16
    34d0:	80 93 a8 00 	sts	0x00A8, r24
    34d4:	eb 81       	ldd	r30, Y+3	; 0x03
    34d6:	fc 81       	ldd	r31, Y+4	; 0x04
    34d8:	86 89       	ldd	r24, Z+22	; 0x16
    34da:	28 2f       	mov	r18, r24
    34dc:	30 e0       	ldi	r19, 0x00	; 0
    34de:	c9 01       	movw	r24, r18
    34e0:	88 0f       	add	r24, r24
    34e2:	99 1f       	adc	r25, r25
    34e4:	88 0f       	add	r24, r24
    34e6:	99 1f       	adc	r25, r25
    34e8:	88 0f       	add	r24, r24
    34ea:	99 1f       	adc	r25, r25
    34ec:	82 0f       	add	r24, r18
    34ee:	93 1f       	adc	r25, r19
    34f0:	ac 01       	movw	r20, r24
    34f2:	41 55       	subi	r20, 0x51	; 81
    34f4:	5f 4f       	sbci	r21, 0xFF	; 255
    34f6:	8b 81       	ldd	r24, Y+3	; 0x03
    34f8:	9c 81       	ldd	r25, Y+4	; 0x04
    34fa:	9c 01       	movw	r18, r24
    34fc:	2e 5f       	subi	r18, 0xFE	; 254
    34fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3500:	ca 01       	movw	r24, r20
    3502:	b9 01       	movw	r22, r18
    3504:	0e 94 33 1c 	call	0x3866	; 0x3866 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    3508:	e0 91 d3 00 	lds	r30, 0x00D3
    350c:	f0 91 d4 00 	lds	r31, 0x00D4
    3510:	80 81       	ld	r24, Z
    3512:	88 23       	and	r24, r24
    3514:	09 f0       	breq	.+2      	; 0x3518 <prvCheckDelayedList+0x130>
    3516:	a9 cf       	rjmp	.-174    	; 0x346a <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    3518:	80 91 ad 00 	lds	r24, 0x00AD
    351c:	90 91 ae 00 	lds	r25, 0x00AE
    3520:	00 97       	sbiw	r24, 0x00	; 0
    3522:	09 f0       	breq	.+2      	; 0x3526 <prvCheckDelayedList+0x13e>
    3524:	74 cf       	rjmp	.-280    	; 0x340e <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    3526:	80 91 a9 00 	lds	r24, 0x00A9
    352a:	90 91 aa 00 	lds	r25, 0x00AA
    352e:	90 93 ac 00 	sts	0x00AC, r25
    3532:	80 93 ab 00 	sts	0x00AB, r24
}
    3536:	0f 90       	pop	r0
    3538:	0f 90       	pop	r0
    353a:	0f 90       	pop	r0
    353c:	0f 90       	pop	r0
    353e:	cf 91       	pop	r28
    3540:	df 91       	pop	r29
    3542:	08 95       	ret

00003544 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    3544:	df 93       	push	r29
    3546:	cf 93       	push	r28
    3548:	00 d0       	rcall	.+0      	; 0x354a <vCoRoutineSchedule+0x6>
    354a:	cd b7       	in	r28, 0x3d	; 61
    354c:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    354e:	0e 94 aa 19 	call	0x3354	; 0x3354 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    3552:	0e 94 f4 19 	call	0x33e8	; 0x33e8 <prvCheckDelayedList>
    3556:	0a c0       	rjmp	.+20     	; 0x356c <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    3558:	80 91 a8 00 	lds	r24, 0x00A8
    355c:	88 23       	and	r24, r24
    355e:	09 f4       	brne	.+2      	; 0x3562 <vCoRoutineSchedule+0x1e>
    3560:	66 c0       	rjmp	.+204    	; 0x362e <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    3562:	80 91 a8 00 	lds	r24, 0x00A8
    3566:	81 50       	subi	r24, 0x01	; 1
    3568:	80 93 a8 00 	sts	0x00A8, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    356c:	80 91 a8 00 	lds	r24, 0x00A8
    3570:	28 2f       	mov	r18, r24
    3572:	30 e0       	ldi	r19, 0x00	; 0
    3574:	c9 01       	movw	r24, r18
    3576:	88 0f       	add	r24, r24
    3578:	99 1f       	adc	r25, r25
    357a:	88 0f       	add	r24, r24
    357c:	99 1f       	adc	r25, r25
    357e:	88 0f       	add	r24, r24
    3580:	99 1f       	adc	r25, r25
    3582:	82 0f       	add	r24, r18
    3584:	93 1f       	adc	r25, r19
    3586:	fc 01       	movw	r30, r24
    3588:	e1 55       	subi	r30, 0x51	; 81
    358a:	ff 4f       	sbci	r31, 0xFF	; 255
    358c:	80 81       	ld	r24, Z
    358e:	88 23       	and	r24, r24
    3590:	19 f3       	breq	.-58     	; 0x3558 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    3592:	80 91 a8 00 	lds	r24, 0x00A8
    3596:	28 2f       	mov	r18, r24
    3598:	30 e0       	ldi	r19, 0x00	; 0
    359a:	c9 01       	movw	r24, r18
    359c:	88 0f       	add	r24, r24
    359e:	99 1f       	adc	r25, r25
    35a0:	88 0f       	add	r24, r24
    35a2:	99 1f       	adc	r25, r25
    35a4:	88 0f       	add	r24, r24
    35a6:	99 1f       	adc	r25, r25
    35a8:	82 0f       	add	r24, r18
    35aa:	93 1f       	adc	r25, r19
    35ac:	81 55       	subi	r24, 0x51	; 81
    35ae:	9f 4f       	sbci	r25, 0xFF	; 255
    35b0:	9a 83       	std	Y+2, r25	; 0x02
    35b2:	89 83       	std	Y+1, r24	; 0x01
    35b4:	e9 81       	ldd	r30, Y+1	; 0x01
    35b6:	fa 81       	ldd	r31, Y+2	; 0x02
    35b8:	01 80       	ldd	r0, Z+1	; 0x01
    35ba:	f2 81       	ldd	r31, Z+2	; 0x02
    35bc:	e0 2d       	mov	r30, r0
    35be:	82 81       	ldd	r24, Z+2	; 0x02
    35c0:	93 81       	ldd	r25, Z+3	; 0x03
    35c2:	e9 81       	ldd	r30, Y+1	; 0x01
    35c4:	fa 81       	ldd	r31, Y+2	; 0x02
    35c6:	92 83       	std	Z+2, r25	; 0x02
    35c8:	81 83       	std	Z+1, r24	; 0x01
    35ca:	e9 81       	ldd	r30, Y+1	; 0x01
    35cc:	fa 81       	ldd	r31, Y+2	; 0x02
    35ce:	21 81       	ldd	r18, Z+1	; 0x01
    35d0:	32 81       	ldd	r19, Z+2	; 0x02
    35d2:	89 81       	ldd	r24, Y+1	; 0x01
    35d4:	9a 81       	ldd	r25, Y+2	; 0x02
    35d6:	03 96       	adiw	r24, 0x03	; 3
    35d8:	28 17       	cp	r18, r24
    35da:	39 07       	cpc	r19, r25
    35dc:	59 f4       	brne	.+22     	; 0x35f4 <vCoRoutineSchedule+0xb0>
    35de:	e9 81       	ldd	r30, Y+1	; 0x01
    35e0:	fa 81       	ldd	r31, Y+2	; 0x02
    35e2:	01 80       	ldd	r0, Z+1	; 0x01
    35e4:	f2 81       	ldd	r31, Z+2	; 0x02
    35e6:	e0 2d       	mov	r30, r0
    35e8:	82 81       	ldd	r24, Z+2	; 0x02
    35ea:	93 81       	ldd	r25, Z+3	; 0x03
    35ec:	e9 81       	ldd	r30, Y+1	; 0x01
    35ee:	fa 81       	ldd	r31, Y+2	; 0x02
    35f0:	92 83       	std	Z+2, r25	; 0x02
    35f2:	81 83       	std	Z+1, r24	; 0x01
    35f4:	e9 81       	ldd	r30, Y+1	; 0x01
    35f6:	fa 81       	ldd	r31, Y+2	; 0x02
    35f8:	01 80       	ldd	r0, Z+1	; 0x01
    35fa:	f2 81       	ldd	r31, Z+2	; 0x02
    35fc:	e0 2d       	mov	r30, r0
    35fe:	86 81       	ldd	r24, Z+6	; 0x06
    3600:	97 81       	ldd	r25, Z+7	; 0x07
    3602:	90 93 a7 00 	sts	0x00A7, r25
    3606:	80 93 a6 00 	sts	0x00A6, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    360a:	e0 91 a6 00 	lds	r30, 0x00A6
    360e:	f0 91 a7 00 	lds	r31, 0x00A7
    3612:	40 81       	ld	r20, Z
    3614:	51 81       	ldd	r21, Z+1	; 0x01
    3616:	80 91 a6 00 	lds	r24, 0x00A6
    361a:	90 91 a7 00 	lds	r25, 0x00A7
    361e:	e0 91 a6 00 	lds	r30, 0x00A6
    3622:	f0 91 a7 00 	lds	r31, 0x00A7
    3626:	27 89       	ldd	r18, Z+23	; 0x17
    3628:	62 2f       	mov	r22, r18
    362a:	fa 01       	movw	r30, r20
    362c:	09 95       	icall

	return;
}
    362e:	0f 90       	pop	r0
    3630:	0f 90       	pop	r0
    3632:	cf 91       	pop	r28
    3634:	df 91       	pop	r29
    3636:	08 95       	ret

00003638 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    3638:	df 93       	push	r29
    363a:	cf 93       	push	r28
    363c:	0f 92       	push	r0
    363e:	cd b7       	in	r28, 0x3d	; 61
    3640:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    3642:	19 82       	std	Y+1, r1	; 0x01
    3644:	13 c0       	rjmp	.+38     	; 0x366c <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    3646:	89 81       	ldd	r24, Y+1	; 0x01
    3648:	28 2f       	mov	r18, r24
    364a:	30 e0       	ldi	r19, 0x00	; 0
    364c:	c9 01       	movw	r24, r18
    364e:	88 0f       	add	r24, r24
    3650:	99 1f       	adc	r25, r25
    3652:	88 0f       	add	r24, r24
    3654:	99 1f       	adc	r25, r25
    3656:	88 0f       	add	r24, r24
    3658:	99 1f       	adc	r25, r25
    365a:	82 0f       	add	r24, r18
    365c:	93 1f       	adc	r25, r19
    365e:	81 55       	subi	r24, 0x51	; 81
    3660:	9f 4f       	sbci	r25, 0xFF	; 255
    3662:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    3666:	89 81       	ldd	r24, Y+1	; 0x01
    3668:	8f 5f       	subi	r24, 0xFF	; 255
    366a:	89 83       	std	Y+1, r24	; 0x01
    366c:	89 81       	ldd	r24, Y+1	; 0x01
    366e:	82 30       	cpi	r24, 0x02	; 2
    3670:	50 f3       	brcs	.-44     	; 0x3646 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    3672:	81 ec       	ldi	r24, 0xC1	; 193
    3674:	90 e0       	ldi	r25, 0x00	; 0
    3676:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    367a:	8a ec       	ldi	r24, 0xCA	; 202
    367c:	90 e0       	ldi	r25, 0x00	; 0
    367e:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    3682:	87 ed       	ldi	r24, 0xD7	; 215
    3684:	90 e0       	ldi	r25, 0x00	; 0
    3686:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    368a:	81 ec       	ldi	r24, 0xC1	; 193
    368c:	90 e0       	ldi	r25, 0x00	; 0
    368e:	90 93 d4 00 	sts	0x00D4, r25
    3692:	80 93 d3 00 	sts	0x00D3, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    3696:	8a ec       	ldi	r24, 0xCA	; 202
    3698:	90 e0       	ldi	r25, 0x00	; 0
    369a:	90 93 d6 00 	sts	0x00D6, r25
    369e:	80 93 d5 00 	sts	0x00D5, r24
}
    36a2:	0f 90       	pop	r0
    36a4:	cf 91       	pop	r28
    36a6:	df 91       	pop	r29
    36a8:	08 95       	ret

000036aa <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    36aa:	df 93       	push	r29
    36ac:	cf 93       	push	r28
    36ae:	00 d0       	rcall	.+0      	; 0x36b0 <xCoRoutineRemoveFromEventList+0x6>
    36b0:	00 d0       	rcall	.+0      	; 0x36b2 <xCoRoutineRemoveFromEventList+0x8>
    36b2:	0f 92       	push	r0
    36b4:	cd b7       	in	r28, 0x3d	; 61
    36b6:	de b7       	in	r29, 0x3e	; 62
    36b8:	9d 83       	std	Y+5, r25	; 0x05
    36ba:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    36bc:	ec 81       	ldd	r30, Y+4	; 0x04
    36be:	fd 81       	ldd	r31, Y+5	; 0x05
    36c0:	05 80       	ldd	r0, Z+5	; 0x05
    36c2:	f6 81       	ldd	r31, Z+6	; 0x06
    36c4:	e0 2d       	mov	r30, r0
    36c6:	86 81       	ldd	r24, Z+6	; 0x06
    36c8:	97 81       	ldd	r25, Z+7	; 0x07
    36ca:	9b 83       	std	Y+3, r25	; 0x03
    36cc:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    36ce:	8a 81       	ldd	r24, Y+2	; 0x02
    36d0:	9b 81       	ldd	r25, Y+3	; 0x03
    36d2:	0c 96       	adiw	r24, 0x0c	; 12
    36d4:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    36d8:	8a 81       	ldd	r24, Y+2	; 0x02
    36da:	9b 81       	ldd	r25, Y+3	; 0x03
    36dc:	9c 01       	movw	r18, r24
    36de:	24 5f       	subi	r18, 0xF4	; 244
    36e0:	3f 4f       	sbci	r19, 0xFF	; 255
    36e2:	87 ed       	ldi	r24, 0xD7	; 215
    36e4:	90 e0       	ldi	r25, 0x00	; 0
    36e6:	b9 01       	movw	r22, r18
    36e8:	0e 94 33 1c 	call	0x3866	; 0x3866 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    36ec:	ea 81       	ldd	r30, Y+2	; 0x02
    36ee:	fb 81       	ldd	r31, Y+3	; 0x03
    36f0:	96 89       	ldd	r25, Z+22	; 0x16
    36f2:	e0 91 a6 00 	lds	r30, 0x00A6
    36f6:	f0 91 a7 00 	lds	r31, 0x00A7
    36fa:	86 89       	ldd	r24, Z+22	; 0x16
    36fc:	98 17       	cp	r25, r24
    36fe:	18 f0       	brcs	.+6      	; 0x3706 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    3700:	81 e0       	ldi	r24, 0x01	; 1
    3702:	89 83       	std	Y+1, r24	; 0x01
    3704:	01 c0       	rjmp	.+2      	; 0x3708 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    3706:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3708:	89 81       	ldd	r24, Y+1	; 0x01
}
    370a:	0f 90       	pop	r0
    370c:	0f 90       	pop	r0
    370e:	0f 90       	pop	r0
    3710:	0f 90       	pop	r0
    3712:	0f 90       	pop	r0
    3714:	cf 91       	pop	r28
    3716:	df 91       	pop	r29
    3718:	08 95       	ret

0000371a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    371a:	df 93       	push	r29
    371c:	cf 93       	push	r28
    371e:	00 d0       	rcall	.+0      	; 0x3720 <pvPortMalloc+0x6>
    3720:	00 d0       	rcall	.+0      	; 0x3722 <pvPortMalloc+0x8>
    3722:	cd b7       	in	r28, 0x3d	; 61
    3724:	de b7       	in	r29, 0x3e	; 62
    3726:	9c 83       	std	Y+4, r25	; 0x04
    3728:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    372a:	1a 82       	std	Y+2, r1	; 0x02
    372c:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    372e:	0e 94 c3 26 	call	0x4d86	; 0x4d86 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    3732:	80 91 e0 00 	lds	r24, 0x00E0
    3736:	90 91 e1 00 	lds	r25, 0x00E1
    373a:	2b 81       	ldd	r18, Y+3	; 0x03
    373c:	3c 81       	ldd	r19, Y+4	; 0x04
    373e:	82 0f       	add	r24, r18
    3740:	93 1f       	adc	r25, r19
    3742:	22 e0       	ldi	r18, 0x02	; 2
    3744:	88 35       	cpi	r24, 0x58	; 88
    3746:	92 07       	cpc	r25, r18
    3748:	18 f5       	brcc	.+70     	; 0x3790 <pvPortMalloc+0x76>
    374a:	20 91 e0 00 	lds	r18, 0x00E0
    374e:	30 91 e1 00 	lds	r19, 0x00E1
    3752:	8b 81       	ldd	r24, Y+3	; 0x03
    3754:	9c 81       	ldd	r25, Y+4	; 0x04
    3756:	28 0f       	add	r18, r24
    3758:	39 1f       	adc	r19, r25
    375a:	80 91 e0 00 	lds	r24, 0x00E0
    375e:	90 91 e1 00 	lds	r25, 0x00E1
    3762:	82 17       	cp	r24, r18
    3764:	93 07       	cpc	r25, r19
    3766:	a0 f4       	brcc	.+40     	; 0x3790 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    3768:	80 91 e0 00 	lds	r24, 0x00E0
    376c:	90 91 e1 00 	lds	r25, 0x00E1
    3770:	8e 51       	subi	r24, 0x1E	; 30
    3772:	9f 4f       	sbci	r25, 0xFF	; 255
    3774:	9a 83       	std	Y+2, r25	; 0x02
    3776:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    3778:	20 91 e0 00 	lds	r18, 0x00E0
    377c:	30 91 e1 00 	lds	r19, 0x00E1
    3780:	8b 81       	ldd	r24, Y+3	; 0x03
    3782:	9c 81       	ldd	r25, Y+4	; 0x04
    3784:	82 0f       	add	r24, r18
    3786:	93 1f       	adc	r25, r19
    3788:	90 93 e1 00 	sts	0x00E1, r25
    378c:	80 93 e0 00 	sts	0x00E0, r24
		}	
	}
	xTaskResumeAll();
    3790:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    3794:	89 81       	ldd	r24, Y+1	; 0x01
    3796:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3798:	0f 90       	pop	r0
    379a:	0f 90       	pop	r0
    379c:	0f 90       	pop	r0
    379e:	0f 90       	pop	r0
    37a0:	cf 91       	pop	r28
    37a2:	df 91       	pop	r29
    37a4:	08 95       	ret

000037a6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    37a6:	df 93       	push	r29
    37a8:	cf 93       	push	r28
    37aa:	00 d0       	rcall	.+0      	; 0x37ac <vPortFree+0x6>
    37ac:	cd b7       	in	r28, 0x3d	; 61
    37ae:	de b7       	in	r29, 0x3e	; 62
    37b0:	9a 83       	std	Y+2, r25	; 0x02
    37b2:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    37b4:	0f 90       	pop	r0
    37b6:	0f 90       	pop	r0
    37b8:	cf 91       	pop	r28
    37ba:	df 91       	pop	r29
    37bc:	08 95       	ret

000037be <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    37be:	df 93       	push	r29
    37c0:	cf 93       	push	r28
    37c2:	cd b7       	in	r28, 0x3d	; 61
    37c4:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    37c6:	10 92 e1 00 	sts	0x00E1, r1
    37ca:	10 92 e0 00 	sts	0x00E0, r1
}
    37ce:	cf 91       	pop	r28
    37d0:	df 91       	pop	r29
    37d2:	08 95       	ret

000037d4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    37d4:	df 93       	push	r29
    37d6:	cf 93       	push	r28
    37d8:	cd b7       	in	r28, 0x3d	; 61
    37da:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    37dc:	20 91 e0 00 	lds	r18, 0x00E0
    37e0:	30 91 e1 00 	lds	r19, 0x00E1
    37e4:	88 e5       	ldi	r24, 0x58	; 88
    37e6:	92 e0       	ldi	r25, 0x02	; 2
    37e8:	82 1b       	sub	r24, r18
    37ea:	93 0b       	sbc	r25, r19
}
    37ec:	cf 91       	pop	r28
    37ee:	df 91       	pop	r29
    37f0:	08 95       	ret

000037f2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    37f2:	df 93       	push	r29
    37f4:	cf 93       	push	r28
    37f6:	00 d0       	rcall	.+0      	; 0x37f8 <vListInitialise+0x6>
    37f8:	cd b7       	in	r28, 0x3d	; 61
    37fa:	de b7       	in	r29, 0x3e	; 62
    37fc:	9a 83       	std	Y+2, r25	; 0x02
    37fe:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    3800:	89 81       	ldd	r24, Y+1	; 0x01
    3802:	9a 81       	ldd	r25, Y+2	; 0x02
    3804:	03 96       	adiw	r24, 0x03	; 3
    3806:	e9 81       	ldd	r30, Y+1	; 0x01
    3808:	fa 81       	ldd	r31, Y+2	; 0x02
    380a:	92 83       	std	Z+2, r25	; 0x02
    380c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    380e:	e9 81       	ldd	r30, Y+1	; 0x01
    3810:	fa 81       	ldd	r31, Y+2	; 0x02
    3812:	8f ef       	ldi	r24, 0xFF	; 255
    3814:	9f ef       	ldi	r25, 0xFF	; 255
    3816:	94 83       	std	Z+4, r25	; 0x04
    3818:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    381a:	89 81       	ldd	r24, Y+1	; 0x01
    381c:	9a 81       	ldd	r25, Y+2	; 0x02
    381e:	03 96       	adiw	r24, 0x03	; 3
    3820:	e9 81       	ldd	r30, Y+1	; 0x01
    3822:	fa 81       	ldd	r31, Y+2	; 0x02
    3824:	96 83       	std	Z+6, r25	; 0x06
    3826:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    3828:	89 81       	ldd	r24, Y+1	; 0x01
    382a:	9a 81       	ldd	r25, Y+2	; 0x02
    382c:	03 96       	adiw	r24, 0x03	; 3
    382e:	e9 81       	ldd	r30, Y+1	; 0x01
    3830:	fa 81       	ldd	r31, Y+2	; 0x02
    3832:	90 87       	std	Z+8, r25	; 0x08
    3834:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    3836:	e9 81       	ldd	r30, Y+1	; 0x01
    3838:	fa 81       	ldd	r31, Y+2	; 0x02
    383a:	10 82       	st	Z, r1
}
    383c:	0f 90       	pop	r0
    383e:	0f 90       	pop	r0
    3840:	cf 91       	pop	r28
    3842:	df 91       	pop	r29
    3844:	08 95       	ret

00003846 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    3846:	df 93       	push	r29
    3848:	cf 93       	push	r28
    384a:	00 d0       	rcall	.+0      	; 0x384c <vListInitialiseItem+0x6>
    384c:	cd b7       	in	r28, 0x3d	; 61
    384e:	de b7       	in	r29, 0x3e	; 62
    3850:	9a 83       	std	Y+2, r25	; 0x02
    3852:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    3854:	e9 81       	ldd	r30, Y+1	; 0x01
    3856:	fa 81       	ldd	r31, Y+2	; 0x02
    3858:	11 86       	std	Z+9, r1	; 0x09
    385a:	10 86       	std	Z+8, r1	; 0x08
}
    385c:	0f 90       	pop	r0
    385e:	0f 90       	pop	r0
    3860:	cf 91       	pop	r28
    3862:	df 91       	pop	r29
    3864:	08 95       	ret

00003866 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    3866:	df 93       	push	r29
    3868:	cf 93       	push	r28
    386a:	00 d0       	rcall	.+0      	; 0x386c <vListInsertEnd+0x6>
    386c:	00 d0       	rcall	.+0      	; 0x386e <vListInsertEnd+0x8>
    386e:	00 d0       	rcall	.+0      	; 0x3870 <vListInsertEnd+0xa>
    3870:	cd b7       	in	r28, 0x3d	; 61
    3872:	de b7       	in	r29, 0x3e	; 62
    3874:	9c 83       	std	Y+4, r25	; 0x04
    3876:	8b 83       	std	Y+3, r24	; 0x03
    3878:	7e 83       	std	Y+6, r23	; 0x06
    387a:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    387c:	eb 81       	ldd	r30, Y+3	; 0x03
    387e:	fc 81       	ldd	r31, Y+4	; 0x04
    3880:	81 81       	ldd	r24, Z+1	; 0x01
    3882:	92 81       	ldd	r25, Z+2	; 0x02
    3884:	9a 83       	std	Y+2, r25	; 0x02
    3886:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    3888:	e9 81       	ldd	r30, Y+1	; 0x01
    388a:	fa 81       	ldd	r31, Y+2	; 0x02
    388c:	82 81       	ldd	r24, Z+2	; 0x02
    388e:	93 81       	ldd	r25, Z+3	; 0x03
    3890:	ed 81       	ldd	r30, Y+5	; 0x05
    3892:	fe 81       	ldd	r31, Y+6	; 0x06
    3894:	93 83       	std	Z+3, r25	; 0x03
    3896:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    3898:	eb 81       	ldd	r30, Y+3	; 0x03
    389a:	fc 81       	ldd	r31, Y+4	; 0x04
    389c:	81 81       	ldd	r24, Z+1	; 0x01
    389e:	92 81       	ldd	r25, Z+2	; 0x02
    38a0:	ed 81       	ldd	r30, Y+5	; 0x05
    38a2:	fe 81       	ldd	r31, Y+6	; 0x06
    38a4:	95 83       	std	Z+5, r25	; 0x05
    38a6:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    38a8:	e9 81       	ldd	r30, Y+1	; 0x01
    38aa:	fa 81       	ldd	r31, Y+2	; 0x02
    38ac:	02 80       	ldd	r0, Z+2	; 0x02
    38ae:	f3 81       	ldd	r31, Z+3	; 0x03
    38b0:	e0 2d       	mov	r30, r0
    38b2:	8d 81       	ldd	r24, Y+5	; 0x05
    38b4:	9e 81       	ldd	r25, Y+6	; 0x06
    38b6:	95 83       	std	Z+5, r25	; 0x05
    38b8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    38ba:	8d 81       	ldd	r24, Y+5	; 0x05
    38bc:	9e 81       	ldd	r25, Y+6	; 0x06
    38be:	e9 81       	ldd	r30, Y+1	; 0x01
    38c0:	fa 81       	ldd	r31, Y+2	; 0x02
    38c2:	93 83       	std	Z+3, r25	; 0x03
    38c4:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    38c6:	8d 81       	ldd	r24, Y+5	; 0x05
    38c8:	9e 81       	ldd	r25, Y+6	; 0x06
    38ca:	eb 81       	ldd	r30, Y+3	; 0x03
    38cc:	fc 81       	ldd	r31, Y+4	; 0x04
    38ce:	92 83       	std	Z+2, r25	; 0x02
    38d0:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    38d2:	ed 81       	ldd	r30, Y+5	; 0x05
    38d4:	fe 81       	ldd	r31, Y+6	; 0x06
    38d6:	8b 81       	ldd	r24, Y+3	; 0x03
    38d8:	9c 81       	ldd	r25, Y+4	; 0x04
    38da:	91 87       	std	Z+9, r25	; 0x09
    38dc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    38de:	eb 81       	ldd	r30, Y+3	; 0x03
    38e0:	fc 81       	ldd	r31, Y+4	; 0x04
    38e2:	80 81       	ld	r24, Z
    38e4:	8f 5f       	subi	r24, 0xFF	; 255
    38e6:	eb 81       	ldd	r30, Y+3	; 0x03
    38e8:	fc 81       	ldd	r31, Y+4	; 0x04
    38ea:	80 83       	st	Z, r24
}
    38ec:	26 96       	adiw	r28, 0x06	; 6
    38ee:	0f b6       	in	r0, 0x3f	; 63
    38f0:	f8 94       	cli
    38f2:	de bf       	out	0x3e, r29	; 62
    38f4:	0f be       	out	0x3f, r0	; 63
    38f6:	cd bf       	out	0x3d, r28	; 61
    38f8:	cf 91       	pop	r28
    38fa:	df 91       	pop	r29
    38fc:	08 95       	ret

000038fe <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    38fe:	df 93       	push	r29
    3900:	cf 93       	push	r28
    3902:	cd b7       	in	r28, 0x3d	; 61
    3904:	de b7       	in	r29, 0x3e	; 62
    3906:	28 97       	sbiw	r28, 0x08	; 8
    3908:	0f b6       	in	r0, 0x3f	; 63
    390a:	f8 94       	cli
    390c:	de bf       	out	0x3e, r29	; 62
    390e:	0f be       	out	0x3f, r0	; 63
    3910:	cd bf       	out	0x3d, r28	; 61
    3912:	9e 83       	std	Y+6, r25	; 0x06
    3914:	8d 83       	std	Y+5, r24	; 0x05
    3916:	78 87       	std	Y+8, r23	; 0x08
    3918:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    391a:	ef 81       	ldd	r30, Y+7	; 0x07
    391c:	f8 85       	ldd	r31, Y+8	; 0x08
    391e:	80 81       	ld	r24, Z
    3920:	91 81       	ldd	r25, Z+1	; 0x01
    3922:	9a 83       	std	Y+2, r25	; 0x02
    3924:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    3926:	89 81       	ldd	r24, Y+1	; 0x01
    3928:	9a 81       	ldd	r25, Y+2	; 0x02
    392a:	2f ef       	ldi	r18, 0xFF	; 255
    392c:	8f 3f       	cpi	r24, 0xFF	; 255
    392e:	92 07       	cpc	r25, r18
    3930:	39 f4       	brne	.+14     	; 0x3940 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    3932:	ed 81       	ldd	r30, Y+5	; 0x05
    3934:	fe 81       	ldd	r31, Y+6	; 0x06
    3936:	87 81       	ldd	r24, Z+7	; 0x07
    3938:	90 85       	ldd	r25, Z+8	; 0x08
    393a:	9c 83       	std	Y+4, r25	; 0x04
    393c:	8b 83       	std	Y+3, r24	; 0x03
    393e:	18 c0       	rjmp	.+48     	; 0x3970 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    3940:	8d 81       	ldd	r24, Y+5	; 0x05
    3942:	9e 81       	ldd	r25, Y+6	; 0x06
    3944:	03 96       	adiw	r24, 0x03	; 3
    3946:	9c 83       	std	Y+4, r25	; 0x04
    3948:	8b 83       	std	Y+3, r24	; 0x03
    394a:	06 c0       	rjmp	.+12     	; 0x3958 <vListInsert+0x5a>
    394c:	eb 81       	ldd	r30, Y+3	; 0x03
    394e:	fc 81       	ldd	r31, Y+4	; 0x04
    3950:	82 81       	ldd	r24, Z+2	; 0x02
    3952:	93 81       	ldd	r25, Z+3	; 0x03
    3954:	9c 83       	std	Y+4, r25	; 0x04
    3956:	8b 83       	std	Y+3, r24	; 0x03
    3958:	eb 81       	ldd	r30, Y+3	; 0x03
    395a:	fc 81       	ldd	r31, Y+4	; 0x04
    395c:	02 80       	ldd	r0, Z+2	; 0x02
    395e:	f3 81       	ldd	r31, Z+3	; 0x03
    3960:	e0 2d       	mov	r30, r0
    3962:	20 81       	ld	r18, Z
    3964:	31 81       	ldd	r19, Z+1	; 0x01
    3966:	89 81       	ldd	r24, Y+1	; 0x01
    3968:	9a 81       	ldd	r25, Y+2	; 0x02
    396a:	82 17       	cp	r24, r18
    396c:	93 07       	cpc	r25, r19
    396e:	70 f7       	brcc	.-36     	; 0x394c <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    3970:	eb 81       	ldd	r30, Y+3	; 0x03
    3972:	fc 81       	ldd	r31, Y+4	; 0x04
    3974:	82 81       	ldd	r24, Z+2	; 0x02
    3976:	93 81       	ldd	r25, Z+3	; 0x03
    3978:	ef 81       	ldd	r30, Y+7	; 0x07
    397a:	f8 85       	ldd	r31, Y+8	; 0x08
    397c:	93 83       	std	Z+3, r25	; 0x03
    397e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    3980:	ef 81       	ldd	r30, Y+7	; 0x07
    3982:	f8 85       	ldd	r31, Y+8	; 0x08
    3984:	02 80       	ldd	r0, Z+2	; 0x02
    3986:	f3 81       	ldd	r31, Z+3	; 0x03
    3988:	e0 2d       	mov	r30, r0
    398a:	8f 81       	ldd	r24, Y+7	; 0x07
    398c:	98 85       	ldd	r25, Y+8	; 0x08
    398e:	95 83       	std	Z+5, r25	; 0x05
    3990:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    3992:	ef 81       	ldd	r30, Y+7	; 0x07
    3994:	f8 85       	ldd	r31, Y+8	; 0x08
    3996:	8b 81       	ldd	r24, Y+3	; 0x03
    3998:	9c 81       	ldd	r25, Y+4	; 0x04
    399a:	95 83       	std	Z+5, r25	; 0x05
    399c:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    399e:	8f 81       	ldd	r24, Y+7	; 0x07
    39a0:	98 85       	ldd	r25, Y+8	; 0x08
    39a2:	eb 81       	ldd	r30, Y+3	; 0x03
    39a4:	fc 81       	ldd	r31, Y+4	; 0x04
    39a6:	93 83       	std	Z+3, r25	; 0x03
    39a8:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    39aa:	ef 81       	ldd	r30, Y+7	; 0x07
    39ac:	f8 85       	ldd	r31, Y+8	; 0x08
    39ae:	8d 81       	ldd	r24, Y+5	; 0x05
    39b0:	9e 81       	ldd	r25, Y+6	; 0x06
    39b2:	91 87       	std	Z+9, r25	; 0x09
    39b4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    39b6:	ed 81       	ldd	r30, Y+5	; 0x05
    39b8:	fe 81       	ldd	r31, Y+6	; 0x06
    39ba:	80 81       	ld	r24, Z
    39bc:	8f 5f       	subi	r24, 0xFF	; 255
    39be:	ed 81       	ldd	r30, Y+5	; 0x05
    39c0:	fe 81       	ldd	r31, Y+6	; 0x06
    39c2:	80 83       	st	Z, r24
}
    39c4:	28 96       	adiw	r28, 0x08	; 8
    39c6:	0f b6       	in	r0, 0x3f	; 63
    39c8:	f8 94       	cli
    39ca:	de bf       	out	0x3e, r29	; 62
    39cc:	0f be       	out	0x3f, r0	; 63
    39ce:	cd bf       	out	0x3d, r28	; 61
    39d0:	cf 91       	pop	r28
    39d2:	df 91       	pop	r29
    39d4:	08 95       	ret

000039d6 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    39d6:	df 93       	push	r29
    39d8:	cf 93       	push	r28
    39da:	00 d0       	rcall	.+0      	; 0x39dc <vListRemove+0x6>
    39dc:	00 d0       	rcall	.+0      	; 0x39de <vListRemove+0x8>
    39de:	cd b7       	in	r28, 0x3d	; 61
    39e0:	de b7       	in	r29, 0x3e	; 62
    39e2:	9c 83       	std	Y+4, r25	; 0x04
    39e4:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    39e6:	eb 81       	ldd	r30, Y+3	; 0x03
    39e8:	fc 81       	ldd	r31, Y+4	; 0x04
    39ea:	a2 81       	ldd	r26, Z+2	; 0x02
    39ec:	b3 81       	ldd	r27, Z+3	; 0x03
    39ee:	eb 81       	ldd	r30, Y+3	; 0x03
    39f0:	fc 81       	ldd	r31, Y+4	; 0x04
    39f2:	84 81       	ldd	r24, Z+4	; 0x04
    39f4:	95 81       	ldd	r25, Z+5	; 0x05
    39f6:	15 96       	adiw	r26, 0x05	; 5
    39f8:	9c 93       	st	X, r25
    39fa:	8e 93       	st	-X, r24
    39fc:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    39fe:	eb 81       	ldd	r30, Y+3	; 0x03
    3a00:	fc 81       	ldd	r31, Y+4	; 0x04
    3a02:	a4 81       	ldd	r26, Z+4	; 0x04
    3a04:	b5 81       	ldd	r27, Z+5	; 0x05
    3a06:	eb 81       	ldd	r30, Y+3	; 0x03
    3a08:	fc 81       	ldd	r31, Y+4	; 0x04
    3a0a:	82 81       	ldd	r24, Z+2	; 0x02
    3a0c:	93 81       	ldd	r25, Z+3	; 0x03
    3a0e:	13 96       	adiw	r26, 0x03	; 3
    3a10:	9c 93       	st	X, r25
    3a12:	8e 93       	st	-X, r24
    3a14:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    3a16:	eb 81       	ldd	r30, Y+3	; 0x03
    3a18:	fc 81       	ldd	r31, Y+4	; 0x04
    3a1a:	80 85       	ldd	r24, Z+8	; 0x08
    3a1c:	91 85       	ldd	r25, Z+9	; 0x09
    3a1e:	9a 83       	std	Y+2, r25	; 0x02
    3a20:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3a22:	e9 81       	ldd	r30, Y+1	; 0x01
    3a24:	fa 81       	ldd	r31, Y+2	; 0x02
    3a26:	21 81       	ldd	r18, Z+1	; 0x01
    3a28:	32 81       	ldd	r19, Z+2	; 0x02
    3a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a2e:	28 17       	cp	r18, r24
    3a30:	39 07       	cpc	r19, r25
    3a32:	41 f4       	brne	.+16     	; 0x3a44 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    3a34:	eb 81       	ldd	r30, Y+3	; 0x03
    3a36:	fc 81       	ldd	r31, Y+4	; 0x04
    3a38:	84 81       	ldd	r24, Z+4	; 0x04
    3a3a:	95 81       	ldd	r25, Z+5	; 0x05
    3a3c:	e9 81       	ldd	r30, Y+1	; 0x01
    3a3e:	fa 81       	ldd	r31, Y+2	; 0x02
    3a40:	92 83       	std	Z+2, r25	; 0x02
    3a42:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    3a44:	eb 81       	ldd	r30, Y+3	; 0x03
    3a46:	fc 81       	ldd	r31, Y+4	; 0x04
    3a48:	11 86       	std	Z+9, r1	; 0x09
    3a4a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    3a4c:	e9 81       	ldd	r30, Y+1	; 0x01
    3a4e:	fa 81       	ldd	r31, Y+2	; 0x02
    3a50:	80 81       	ld	r24, Z
    3a52:	81 50       	subi	r24, 0x01	; 1
    3a54:	e9 81       	ldd	r30, Y+1	; 0x01
    3a56:	fa 81       	ldd	r31, Y+2	; 0x02
    3a58:	80 83       	st	Z, r24
}
    3a5a:	0f 90       	pop	r0
    3a5c:	0f 90       	pop	r0
    3a5e:	0f 90       	pop	r0
    3a60:	0f 90       	pop	r0
    3a62:	cf 91       	pop	r28
    3a64:	df 91       	pop	r29
    3a66:	08 95       	ret

00003a68 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    3a68:	df 93       	push	r29
    3a6a:	cf 93       	push	r28
    3a6c:	cd b7       	in	r28, 0x3d	; 61
    3a6e:	de b7       	in	r29, 0x3e	; 62
    3a70:	28 97       	sbiw	r28, 0x08	; 8
    3a72:	0f b6       	in	r0, 0x3f	; 63
    3a74:	f8 94       	cli
    3a76:	de bf       	out	0x3e, r29	; 62
    3a78:	0f be       	out	0x3f, r0	; 63
    3a7a:	cd bf       	out	0x3d, r28	; 61
    3a7c:	9c 83       	std	Y+4, r25	; 0x04
    3a7e:	8b 83       	std	Y+3, r24	; 0x03
    3a80:	7e 83       	std	Y+6, r23	; 0x06
    3a82:	6d 83       	std	Y+5, r22	; 0x05
    3a84:	58 87       	std	Y+8, r21	; 0x08
    3a86:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3a88:	eb 81       	ldd	r30, Y+3	; 0x03
    3a8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3a8c:	81 e1       	ldi	r24, 0x11	; 17
    3a8e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a90:	8b 81       	ldd	r24, Y+3	; 0x03
    3a92:	9c 81       	ldd	r25, Y+4	; 0x04
    3a94:	01 97       	sbiw	r24, 0x01	; 1
    3a96:	9c 83       	std	Y+4, r25	; 0x04
    3a98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    3a9a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a9c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a9e:	82 e2       	ldi	r24, 0x22	; 34
    3aa0:	80 83       	st	Z, r24
	pxTopOfStack--;
    3aa2:	8b 81       	ldd	r24, Y+3	; 0x03
    3aa4:	9c 81       	ldd	r25, Y+4	; 0x04
    3aa6:	01 97       	sbiw	r24, 0x01	; 1
    3aa8:	9c 83       	std	Y+4, r25	; 0x04
    3aaa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    3aac:	eb 81       	ldd	r30, Y+3	; 0x03
    3aae:	fc 81       	ldd	r31, Y+4	; 0x04
    3ab0:	83 e3       	ldi	r24, 0x33	; 51
    3ab2:	80 83       	st	Z, r24
	pxTopOfStack--;
    3ab4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ab6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ab8:	01 97       	sbiw	r24, 0x01	; 1
    3aba:	9c 83       	std	Y+4, r25	; 0x04
    3abc:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    3abe:	8d 81       	ldd	r24, Y+5	; 0x05
    3ac0:	9e 81       	ldd	r25, Y+6	; 0x06
    3ac2:	9a 83       	std	Y+2, r25	; 0x02
    3ac4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3ac6:	89 81       	ldd	r24, Y+1	; 0x01
    3ac8:	eb 81       	ldd	r30, Y+3	; 0x03
    3aca:	fc 81       	ldd	r31, Y+4	; 0x04
    3acc:	80 83       	st	Z, r24
	pxTopOfStack--;
    3ace:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad0:	9c 81       	ldd	r25, Y+4	; 0x04
    3ad2:	01 97       	sbiw	r24, 0x01	; 1
    3ad4:	9c 83       	std	Y+4, r25	; 0x04
    3ad6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3ad8:	89 81       	ldd	r24, Y+1	; 0x01
    3ada:	9a 81       	ldd	r25, Y+2	; 0x02
    3adc:	89 2f       	mov	r24, r25
    3ade:	99 27       	eor	r25, r25
    3ae0:	9a 83       	std	Y+2, r25	; 0x02
    3ae2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3ae4:	89 81       	ldd	r24, Y+1	; 0x01
    3ae6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ae8:	fc 81       	ldd	r31, Y+4	; 0x04
    3aea:	80 83       	st	Z, r24
	pxTopOfStack--;
    3aec:	8b 81       	ldd	r24, Y+3	; 0x03
    3aee:	9c 81       	ldd	r25, Y+4	; 0x04
    3af0:	01 97       	sbiw	r24, 0x01	; 1
    3af2:	9c 83       	std	Y+4, r25	; 0x04
    3af4:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    3af6:	eb 81       	ldd	r30, Y+3	; 0x03
    3af8:	fc 81       	ldd	r31, Y+4	; 0x04
    3afa:	10 82       	st	Z, r1
	pxTopOfStack--;
    3afc:	8b 81       	ldd	r24, Y+3	; 0x03
    3afe:	9c 81       	ldd	r25, Y+4	; 0x04
    3b00:	01 97       	sbiw	r24, 0x01	; 1
    3b02:	9c 83       	std	Y+4, r25	; 0x04
    3b04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3b06:	eb 81       	ldd	r30, Y+3	; 0x03
    3b08:	fc 81       	ldd	r31, Y+4	; 0x04
    3b0a:	80 e8       	ldi	r24, 0x80	; 128
    3b0c:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b10:	9c 81       	ldd	r25, Y+4	; 0x04
    3b12:	01 97       	sbiw	r24, 0x01	; 1
    3b14:	9c 83       	std	Y+4, r25	; 0x04
    3b16:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3b18:	eb 81       	ldd	r30, Y+3	; 0x03
    3b1a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b1c:	10 82       	st	Z, r1
	pxTopOfStack--;
    3b1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b20:	9c 81       	ldd	r25, Y+4	; 0x04
    3b22:	01 97       	sbiw	r24, 0x01	; 1
    3b24:	9c 83       	std	Y+4, r25	; 0x04
    3b26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3b28:	eb 81       	ldd	r30, Y+3	; 0x03
    3b2a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b2c:	82 e0       	ldi	r24, 0x02	; 2
    3b2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b30:	8b 81       	ldd	r24, Y+3	; 0x03
    3b32:	9c 81       	ldd	r25, Y+4	; 0x04
    3b34:	01 97       	sbiw	r24, 0x01	; 1
    3b36:	9c 83       	std	Y+4, r25	; 0x04
    3b38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3b3a:	eb 81       	ldd	r30, Y+3	; 0x03
    3b3c:	fc 81       	ldd	r31, Y+4	; 0x04
    3b3e:	83 e0       	ldi	r24, 0x03	; 3
    3b40:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b42:	8b 81       	ldd	r24, Y+3	; 0x03
    3b44:	9c 81       	ldd	r25, Y+4	; 0x04
    3b46:	01 97       	sbiw	r24, 0x01	; 1
    3b48:	9c 83       	std	Y+4, r25	; 0x04
    3b4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    3b4c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b4e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b50:	84 e0       	ldi	r24, 0x04	; 4
    3b52:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b54:	8b 81       	ldd	r24, Y+3	; 0x03
    3b56:	9c 81       	ldd	r25, Y+4	; 0x04
    3b58:	01 97       	sbiw	r24, 0x01	; 1
    3b5a:	9c 83       	std	Y+4, r25	; 0x04
    3b5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    3b5e:	eb 81       	ldd	r30, Y+3	; 0x03
    3b60:	fc 81       	ldd	r31, Y+4	; 0x04
    3b62:	85 e0       	ldi	r24, 0x05	; 5
    3b64:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b66:	8b 81       	ldd	r24, Y+3	; 0x03
    3b68:	9c 81       	ldd	r25, Y+4	; 0x04
    3b6a:	01 97       	sbiw	r24, 0x01	; 1
    3b6c:	9c 83       	std	Y+4, r25	; 0x04
    3b6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    3b70:	eb 81       	ldd	r30, Y+3	; 0x03
    3b72:	fc 81       	ldd	r31, Y+4	; 0x04
    3b74:	86 e0       	ldi	r24, 0x06	; 6
    3b76:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b78:	8b 81       	ldd	r24, Y+3	; 0x03
    3b7a:	9c 81       	ldd	r25, Y+4	; 0x04
    3b7c:	01 97       	sbiw	r24, 0x01	; 1
    3b7e:	9c 83       	std	Y+4, r25	; 0x04
    3b80:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    3b82:	eb 81       	ldd	r30, Y+3	; 0x03
    3b84:	fc 81       	ldd	r31, Y+4	; 0x04
    3b86:	87 e0       	ldi	r24, 0x07	; 7
    3b88:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b8a:	8b 81       	ldd	r24, Y+3	; 0x03
    3b8c:	9c 81       	ldd	r25, Y+4	; 0x04
    3b8e:	01 97       	sbiw	r24, 0x01	; 1
    3b90:	9c 83       	std	Y+4, r25	; 0x04
    3b92:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    3b94:	eb 81       	ldd	r30, Y+3	; 0x03
    3b96:	fc 81       	ldd	r31, Y+4	; 0x04
    3b98:	88 e0       	ldi	r24, 0x08	; 8
    3b9a:	80 83       	st	Z, r24
	pxTopOfStack--;
    3b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b9e:	9c 81       	ldd	r25, Y+4	; 0x04
    3ba0:	01 97       	sbiw	r24, 0x01	; 1
    3ba2:	9c 83       	std	Y+4, r25	; 0x04
    3ba4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    3ba6:	eb 81       	ldd	r30, Y+3	; 0x03
    3ba8:	fc 81       	ldd	r31, Y+4	; 0x04
    3baa:	89 e0       	ldi	r24, 0x09	; 9
    3bac:	80 83       	st	Z, r24
	pxTopOfStack--;
    3bae:	8b 81       	ldd	r24, Y+3	; 0x03
    3bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    3bb2:	01 97       	sbiw	r24, 0x01	; 1
    3bb4:	9c 83       	std	Y+4, r25	; 0x04
    3bb6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    3bb8:	eb 81       	ldd	r30, Y+3	; 0x03
    3bba:	fc 81       	ldd	r31, Y+4	; 0x04
    3bbc:	80 e1       	ldi	r24, 0x10	; 16
    3bbe:	80 83       	st	Z, r24
	pxTopOfStack--;
    3bc0:	8b 81       	ldd	r24, Y+3	; 0x03
    3bc2:	9c 81       	ldd	r25, Y+4	; 0x04
    3bc4:	01 97       	sbiw	r24, 0x01	; 1
    3bc6:	9c 83       	std	Y+4, r25	; 0x04
    3bc8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    3bca:	eb 81       	ldd	r30, Y+3	; 0x03
    3bcc:	fc 81       	ldd	r31, Y+4	; 0x04
    3bce:	81 e1       	ldi	r24, 0x11	; 17
    3bd0:	80 83       	st	Z, r24
	pxTopOfStack--;
    3bd2:	8b 81       	ldd	r24, Y+3	; 0x03
    3bd4:	9c 81       	ldd	r25, Y+4	; 0x04
    3bd6:	01 97       	sbiw	r24, 0x01	; 1
    3bd8:	9c 83       	std	Y+4, r25	; 0x04
    3bda:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    3bdc:	eb 81       	ldd	r30, Y+3	; 0x03
    3bde:	fc 81       	ldd	r31, Y+4	; 0x04
    3be0:	82 e1       	ldi	r24, 0x12	; 18
    3be2:	80 83       	st	Z, r24
	pxTopOfStack--;
    3be4:	8b 81       	ldd	r24, Y+3	; 0x03
    3be6:	9c 81       	ldd	r25, Y+4	; 0x04
    3be8:	01 97       	sbiw	r24, 0x01	; 1
    3bea:	9c 83       	std	Y+4, r25	; 0x04
    3bec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    3bee:	eb 81       	ldd	r30, Y+3	; 0x03
    3bf0:	fc 81       	ldd	r31, Y+4	; 0x04
    3bf2:	83 e1       	ldi	r24, 0x13	; 19
    3bf4:	80 83       	st	Z, r24
	pxTopOfStack--;
    3bf6:	8b 81       	ldd	r24, Y+3	; 0x03
    3bf8:	9c 81       	ldd	r25, Y+4	; 0x04
    3bfa:	01 97       	sbiw	r24, 0x01	; 1
    3bfc:	9c 83       	std	Y+4, r25	; 0x04
    3bfe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    3c00:	eb 81       	ldd	r30, Y+3	; 0x03
    3c02:	fc 81       	ldd	r31, Y+4	; 0x04
    3c04:	84 e1       	ldi	r24, 0x14	; 20
    3c06:	80 83       	st	Z, r24
	pxTopOfStack--;
    3c08:	8b 81       	ldd	r24, Y+3	; 0x03
    3c0a:	9c 81       	ldd	r25, Y+4	; 0x04
    3c0c:	01 97       	sbiw	r24, 0x01	; 1
    3c0e:	9c 83       	std	Y+4, r25	; 0x04
    3c10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    3c12:	eb 81       	ldd	r30, Y+3	; 0x03
    3c14:	fc 81       	ldd	r31, Y+4	; 0x04
    3c16:	85 e1       	ldi	r24, 0x15	; 21
    3c18:	80 83       	st	Z, r24
	pxTopOfStack--;
    3c1a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c1c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c1e:	01 97       	sbiw	r24, 0x01	; 1
    3c20:	9c 83       	std	Y+4, r25	; 0x04
    3c22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    3c24:	eb 81       	ldd	r30, Y+3	; 0x03
    3c26:	fc 81       	ldd	r31, Y+4	; 0x04
    3c28:	86 e1       	ldi	r24, 0x16	; 22
    3c2a:	80 83       	st	Z, r24
	pxTopOfStack--;
    3c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c30:	01 97       	sbiw	r24, 0x01	; 1
    3c32:	9c 83       	std	Y+4, r25	; 0x04
    3c34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    3c36:	eb 81       	ldd	r30, Y+3	; 0x03
    3c38:	fc 81       	ldd	r31, Y+4	; 0x04
    3c3a:	87 e1       	ldi	r24, 0x17	; 23
    3c3c:	80 83       	st	Z, r24
	pxTopOfStack--;
    3c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3c40:	9c 81       	ldd	r25, Y+4	; 0x04
    3c42:	01 97       	sbiw	r24, 0x01	; 1
    3c44:	9c 83       	std	Y+4, r25	; 0x04
    3c46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3c48:	eb 81       	ldd	r30, Y+3	; 0x03
    3c4a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c4c:	88 e1       	ldi	r24, 0x18	; 24
    3c4e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3c50:	8b 81       	ldd	r24, Y+3	; 0x03
    3c52:	9c 81       	ldd	r25, Y+4	; 0x04
    3c54:	01 97       	sbiw	r24, 0x01	; 1
    3c56:	9c 83       	std	Y+4, r25	; 0x04
    3c58:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3c5a:	eb 81       	ldd	r30, Y+3	; 0x03
    3c5c:	fc 81       	ldd	r31, Y+4	; 0x04
    3c5e:	89 e1       	ldi	r24, 0x19	; 25
    3c60:	80 83       	st	Z, r24
	pxTopOfStack--;
    3c62:	8b 81       	ldd	r24, Y+3	; 0x03
    3c64:	9c 81       	ldd	r25, Y+4	; 0x04
    3c66:	01 97       	sbiw	r24, 0x01	; 1
    3c68:	9c 83       	std	Y+4, r25	; 0x04
    3c6a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    3c6c:	eb 81       	ldd	r30, Y+3	; 0x03
    3c6e:	fc 81       	ldd	r31, Y+4	; 0x04
    3c70:	80 e2       	ldi	r24, 0x20	; 32
    3c72:	80 83       	st	Z, r24
	pxTopOfStack--;
    3c74:	8b 81       	ldd	r24, Y+3	; 0x03
    3c76:	9c 81       	ldd	r25, Y+4	; 0x04
    3c78:	01 97       	sbiw	r24, 0x01	; 1
    3c7a:	9c 83       	std	Y+4, r25	; 0x04
    3c7c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    3c7e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c80:	fc 81       	ldd	r31, Y+4	; 0x04
    3c82:	81 e2       	ldi	r24, 0x21	; 33
    3c84:	80 83       	st	Z, r24
	pxTopOfStack--;
    3c86:	8b 81       	ldd	r24, Y+3	; 0x03
    3c88:	9c 81       	ldd	r25, Y+4	; 0x04
    3c8a:	01 97       	sbiw	r24, 0x01	; 1
    3c8c:	9c 83       	std	Y+4, r25	; 0x04
    3c8e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    3c90:	eb 81       	ldd	r30, Y+3	; 0x03
    3c92:	fc 81       	ldd	r31, Y+4	; 0x04
    3c94:	82 e2       	ldi	r24, 0x22	; 34
    3c96:	80 83       	st	Z, r24
	pxTopOfStack--;
    3c98:	8b 81       	ldd	r24, Y+3	; 0x03
    3c9a:	9c 81       	ldd	r25, Y+4	; 0x04
    3c9c:	01 97       	sbiw	r24, 0x01	; 1
    3c9e:	9c 83       	std	Y+4, r25	; 0x04
    3ca0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    3ca2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ca4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ca6:	83 e2       	ldi	r24, 0x23	; 35
    3ca8:	80 83       	st	Z, r24
	pxTopOfStack--;
    3caa:	8b 81       	ldd	r24, Y+3	; 0x03
    3cac:	9c 81       	ldd	r25, Y+4	; 0x04
    3cae:	01 97       	sbiw	r24, 0x01	; 1
    3cb0:	9c 83       	std	Y+4, r25	; 0x04
    3cb2:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    3cb4:	8f 81       	ldd	r24, Y+7	; 0x07
    3cb6:	98 85       	ldd	r25, Y+8	; 0x08
    3cb8:	9a 83       	std	Y+2, r25	; 0x02
    3cba:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3cbc:	89 81       	ldd	r24, Y+1	; 0x01
    3cbe:	eb 81       	ldd	r30, Y+3	; 0x03
    3cc0:	fc 81       	ldd	r31, Y+4	; 0x04
    3cc2:	80 83       	st	Z, r24
	pxTopOfStack--;
    3cc4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc8:	01 97       	sbiw	r24, 0x01	; 1
    3cca:	9c 83       	std	Y+4, r25	; 0x04
    3ccc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3cce:	89 81       	ldd	r24, Y+1	; 0x01
    3cd0:	9a 81       	ldd	r25, Y+2	; 0x02
    3cd2:	89 2f       	mov	r24, r25
    3cd4:	99 27       	eor	r25, r25
    3cd6:	9a 83       	std	Y+2, r25	; 0x02
    3cd8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3cda:	89 81       	ldd	r24, Y+1	; 0x01
    3cdc:	eb 81       	ldd	r30, Y+3	; 0x03
    3cde:	fc 81       	ldd	r31, Y+4	; 0x04
    3ce0:	80 83       	st	Z, r24
	pxTopOfStack--;
    3ce2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ce4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ce6:	01 97       	sbiw	r24, 0x01	; 1
    3ce8:	9c 83       	std	Y+4, r25	; 0x04
    3cea:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    3cec:	eb 81       	ldd	r30, Y+3	; 0x03
    3cee:	fc 81       	ldd	r31, Y+4	; 0x04
    3cf0:	86 e2       	ldi	r24, 0x26	; 38
    3cf2:	80 83       	st	Z, r24
	pxTopOfStack--;
    3cf4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cf6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cf8:	01 97       	sbiw	r24, 0x01	; 1
    3cfa:	9c 83       	std	Y+4, r25	; 0x04
    3cfc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    3cfe:	eb 81       	ldd	r30, Y+3	; 0x03
    3d00:	fc 81       	ldd	r31, Y+4	; 0x04
    3d02:	87 e2       	ldi	r24, 0x27	; 39
    3d04:	80 83       	st	Z, r24
	pxTopOfStack--;
    3d06:	8b 81       	ldd	r24, Y+3	; 0x03
    3d08:	9c 81       	ldd	r25, Y+4	; 0x04
    3d0a:	01 97       	sbiw	r24, 0x01	; 1
    3d0c:	9c 83       	std	Y+4, r25	; 0x04
    3d0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    3d10:	eb 81       	ldd	r30, Y+3	; 0x03
    3d12:	fc 81       	ldd	r31, Y+4	; 0x04
    3d14:	88 e2       	ldi	r24, 0x28	; 40
    3d16:	80 83       	st	Z, r24
	pxTopOfStack--;
    3d18:	8b 81       	ldd	r24, Y+3	; 0x03
    3d1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3d1c:	01 97       	sbiw	r24, 0x01	; 1
    3d1e:	9c 83       	std	Y+4, r25	; 0x04
    3d20:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    3d22:	eb 81       	ldd	r30, Y+3	; 0x03
    3d24:	fc 81       	ldd	r31, Y+4	; 0x04
    3d26:	89 e2       	ldi	r24, 0x29	; 41
    3d28:	80 83       	st	Z, r24
	pxTopOfStack--;
    3d2a:	8b 81       	ldd	r24, Y+3	; 0x03
    3d2c:	9c 81       	ldd	r25, Y+4	; 0x04
    3d2e:	01 97       	sbiw	r24, 0x01	; 1
    3d30:	9c 83       	std	Y+4, r25	; 0x04
    3d32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    3d34:	eb 81       	ldd	r30, Y+3	; 0x03
    3d36:	fc 81       	ldd	r31, Y+4	; 0x04
    3d38:	80 e3       	ldi	r24, 0x30	; 48
    3d3a:	80 83       	st	Z, r24
	pxTopOfStack--;
    3d3c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d3e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d40:	01 97       	sbiw	r24, 0x01	; 1
    3d42:	9c 83       	std	Y+4, r25	; 0x04
    3d44:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3d46:	eb 81       	ldd	r30, Y+3	; 0x03
    3d48:	fc 81       	ldd	r31, Y+4	; 0x04
    3d4a:	81 e3       	ldi	r24, 0x31	; 49
    3d4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    3d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d50:	9c 81       	ldd	r25, Y+4	; 0x04
    3d52:	01 97       	sbiw	r24, 0x01	; 1
    3d54:	9c 83       	std	Y+4, r25	; 0x04
    3d56:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3d58:	8b 81       	ldd	r24, Y+3	; 0x03
    3d5a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3d5c:	28 96       	adiw	r28, 0x08	; 8
    3d5e:	0f b6       	in	r0, 0x3f	; 63
    3d60:	f8 94       	cli
    3d62:	de bf       	out	0x3e, r29	; 62
    3d64:	0f be       	out	0x3f, r0	; 63
    3d66:	cd bf       	out	0x3d, r28	; 61
    3d68:	cf 91       	pop	r28
    3d6a:	df 91       	pop	r29
    3d6c:	08 95       	ret

00003d6e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    3d6e:	df 93       	push	r29
    3d70:	cf 93       	push	r28
    3d72:	cd b7       	in	r28, 0x3d	; 61
    3d74:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3d76:	0e 94 a7 1f 	call	0x3f4e	; 0x3f4e <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3d7a:	a0 91 3a 03 	lds	r26, 0x033A
    3d7e:	b0 91 3b 03 	lds	r27, 0x033B
    3d82:	cd 91       	ld	r28, X+
    3d84:	cd bf       	out	0x3d, r28	; 61
    3d86:	dd 91       	ld	r29, X+
    3d88:	de bf       	out	0x3e, r29	; 62
    3d8a:	ff 91       	pop	r31
    3d8c:	ef 91       	pop	r30
    3d8e:	df 91       	pop	r29
    3d90:	cf 91       	pop	r28
    3d92:	bf 91       	pop	r27
    3d94:	af 91       	pop	r26
    3d96:	9f 91       	pop	r25
    3d98:	8f 91       	pop	r24
    3d9a:	7f 91       	pop	r23
    3d9c:	6f 91       	pop	r22
    3d9e:	5f 91       	pop	r21
    3da0:	4f 91       	pop	r20
    3da2:	3f 91       	pop	r19
    3da4:	2f 91       	pop	r18
    3da6:	1f 91       	pop	r17
    3da8:	0f 91       	pop	r16
    3daa:	ff 90       	pop	r15
    3dac:	ef 90       	pop	r14
    3dae:	df 90       	pop	r13
    3db0:	cf 90       	pop	r12
    3db2:	bf 90       	pop	r11
    3db4:	af 90       	pop	r10
    3db6:	9f 90       	pop	r9
    3db8:	8f 90       	pop	r8
    3dba:	7f 90       	pop	r7
    3dbc:	6f 90       	pop	r6
    3dbe:	5f 90       	pop	r5
    3dc0:	4f 90       	pop	r4
    3dc2:	3f 90       	pop	r3
    3dc4:	2f 90       	pop	r2
    3dc6:	1f 90       	pop	r1
    3dc8:	0f 90       	pop	r0
    3dca:	0f be       	out	0x3f, r0	; 63
    3dcc:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3dce:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3dd0:	81 e0       	ldi	r24, 0x01	; 1
}
    3dd2:	cf 91       	pop	r28
    3dd4:	df 91       	pop	r29
    3dd6:	08 95       	ret

00003dd8 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3dd8:	df 93       	push	r29
    3dda:	cf 93       	push	r28
    3ddc:	cd b7       	in	r28, 0x3d	; 61
    3dde:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3de0:	cf 91       	pop	r28
    3de2:	df 91       	pop	r29
    3de4:	08 95       	ret

00003de6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3de6:	0f 92       	push	r0
    3de8:	0f b6       	in	r0, 0x3f	; 63
    3dea:	f8 94       	cli
    3dec:	0f 92       	push	r0
    3dee:	1f 92       	push	r1
    3df0:	11 24       	eor	r1, r1
    3df2:	2f 92       	push	r2
    3df4:	3f 92       	push	r3
    3df6:	4f 92       	push	r4
    3df8:	5f 92       	push	r5
    3dfa:	6f 92       	push	r6
    3dfc:	7f 92       	push	r7
    3dfe:	8f 92       	push	r8
    3e00:	9f 92       	push	r9
    3e02:	af 92       	push	r10
    3e04:	bf 92       	push	r11
    3e06:	cf 92       	push	r12
    3e08:	df 92       	push	r13
    3e0a:	ef 92       	push	r14
    3e0c:	ff 92       	push	r15
    3e0e:	0f 93       	push	r16
    3e10:	1f 93       	push	r17
    3e12:	2f 93       	push	r18
    3e14:	3f 93       	push	r19
    3e16:	4f 93       	push	r20
    3e18:	5f 93       	push	r21
    3e1a:	6f 93       	push	r22
    3e1c:	7f 93       	push	r23
    3e1e:	8f 93       	push	r24
    3e20:	9f 93       	push	r25
    3e22:	af 93       	push	r26
    3e24:	bf 93       	push	r27
    3e26:	cf 93       	push	r28
    3e28:	df 93       	push	r29
    3e2a:	ef 93       	push	r30
    3e2c:	ff 93       	push	r31
    3e2e:	a0 91 3a 03 	lds	r26, 0x033A
    3e32:	b0 91 3b 03 	lds	r27, 0x033B
    3e36:	0d b6       	in	r0, 0x3d	; 61
    3e38:	0d 92       	st	X+, r0
    3e3a:	0e b6       	in	r0, 0x3e	; 62
    3e3c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3e3e:	0e 94 63 28 	call	0x50c6	; 0x50c6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3e42:	a0 91 3a 03 	lds	r26, 0x033A
    3e46:	b0 91 3b 03 	lds	r27, 0x033B
    3e4a:	cd 91       	ld	r28, X+
    3e4c:	cd bf       	out	0x3d, r28	; 61
    3e4e:	dd 91       	ld	r29, X+
    3e50:	de bf       	out	0x3e, r29	; 62
    3e52:	ff 91       	pop	r31
    3e54:	ef 91       	pop	r30
    3e56:	df 91       	pop	r29
    3e58:	cf 91       	pop	r28
    3e5a:	bf 91       	pop	r27
    3e5c:	af 91       	pop	r26
    3e5e:	9f 91       	pop	r25
    3e60:	8f 91       	pop	r24
    3e62:	7f 91       	pop	r23
    3e64:	6f 91       	pop	r22
    3e66:	5f 91       	pop	r21
    3e68:	4f 91       	pop	r20
    3e6a:	3f 91       	pop	r19
    3e6c:	2f 91       	pop	r18
    3e6e:	1f 91       	pop	r17
    3e70:	0f 91       	pop	r16
    3e72:	ff 90       	pop	r15
    3e74:	ef 90       	pop	r14
    3e76:	df 90       	pop	r13
    3e78:	cf 90       	pop	r12
    3e7a:	bf 90       	pop	r11
    3e7c:	af 90       	pop	r10
    3e7e:	9f 90       	pop	r9
    3e80:	8f 90       	pop	r8
    3e82:	7f 90       	pop	r7
    3e84:	6f 90       	pop	r6
    3e86:	5f 90       	pop	r5
    3e88:	4f 90       	pop	r4
    3e8a:	3f 90       	pop	r3
    3e8c:	2f 90       	pop	r2
    3e8e:	1f 90       	pop	r1
    3e90:	0f 90       	pop	r0
    3e92:	0f be       	out	0x3f, r0	; 63
    3e94:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3e96:	08 95       	ret

00003e98 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3e98:	0f 92       	push	r0
    3e9a:	0f b6       	in	r0, 0x3f	; 63
    3e9c:	f8 94       	cli
    3e9e:	0f 92       	push	r0
    3ea0:	1f 92       	push	r1
    3ea2:	11 24       	eor	r1, r1
    3ea4:	2f 92       	push	r2
    3ea6:	3f 92       	push	r3
    3ea8:	4f 92       	push	r4
    3eaa:	5f 92       	push	r5
    3eac:	6f 92       	push	r6
    3eae:	7f 92       	push	r7
    3eb0:	8f 92       	push	r8
    3eb2:	9f 92       	push	r9
    3eb4:	af 92       	push	r10
    3eb6:	bf 92       	push	r11
    3eb8:	cf 92       	push	r12
    3eba:	df 92       	push	r13
    3ebc:	ef 92       	push	r14
    3ebe:	ff 92       	push	r15
    3ec0:	0f 93       	push	r16
    3ec2:	1f 93       	push	r17
    3ec4:	2f 93       	push	r18
    3ec6:	3f 93       	push	r19
    3ec8:	4f 93       	push	r20
    3eca:	5f 93       	push	r21
    3ecc:	6f 93       	push	r22
    3ece:	7f 93       	push	r23
    3ed0:	8f 93       	push	r24
    3ed2:	9f 93       	push	r25
    3ed4:	af 93       	push	r26
    3ed6:	bf 93       	push	r27
    3ed8:	cf 93       	push	r28
    3eda:	df 93       	push	r29
    3edc:	ef 93       	push	r30
    3ede:	ff 93       	push	r31
    3ee0:	a0 91 3a 03 	lds	r26, 0x033A
    3ee4:	b0 91 3b 03 	lds	r27, 0x033B
    3ee8:	0d b6       	in	r0, 0x3d	; 61
    3eea:	0d 92       	st	X+, r0
    3eec:	0e b6       	in	r0, 0x3e	; 62
    3eee:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3ef0:	0e 94 8e 27 	call	0x4f1c	; 0x4f1c <vTaskIncrementTick>
	vTaskSwitchContext();
    3ef4:	0e 94 63 28 	call	0x50c6	; 0x50c6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3ef8:	a0 91 3a 03 	lds	r26, 0x033A
    3efc:	b0 91 3b 03 	lds	r27, 0x033B
    3f00:	cd 91       	ld	r28, X+
    3f02:	cd bf       	out	0x3d, r28	; 61
    3f04:	dd 91       	ld	r29, X+
    3f06:	de bf       	out	0x3e, r29	; 62
    3f08:	ff 91       	pop	r31
    3f0a:	ef 91       	pop	r30
    3f0c:	df 91       	pop	r29
    3f0e:	cf 91       	pop	r28
    3f10:	bf 91       	pop	r27
    3f12:	af 91       	pop	r26
    3f14:	9f 91       	pop	r25
    3f16:	8f 91       	pop	r24
    3f18:	7f 91       	pop	r23
    3f1a:	6f 91       	pop	r22
    3f1c:	5f 91       	pop	r21
    3f1e:	4f 91       	pop	r20
    3f20:	3f 91       	pop	r19
    3f22:	2f 91       	pop	r18
    3f24:	1f 91       	pop	r17
    3f26:	0f 91       	pop	r16
    3f28:	ff 90       	pop	r15
    3f2a:	ef 90       	pop	r14
    3f2c:	df 90       	pop	r13
    3f2e:	cf 90       	pop	r12
    3f30:	bf 90       	pop	r11
    3f32:	af 90       	pop	r10
    3f34:	9f 90       	pop	r9
    3f36:	8f 90       	pop	r8
    3f38:	7f 90       	pop	r7
    3f3a:	6f 90       	pop	r6
    3f3c:	5f 90       	pop	r5
    3f3e:	4f 90       	pop	r4
    3f40:	3f 90       	pop	r3
    3f42:	2f 90       	pop	r2
    3f44:	1f 90       	pop	r1
    3f46:	0f 90       	pop	r0
    3f48:	0f be       	out	0x3f, r0	; 63
    3f4a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3f4c:	08 95       	ret

00003f4e <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3f4e:	df 93       	push	r29
    3f50:	cf 93       	push	r28
    3f52:	00 d0       	rcall	.+0      	; 0x3f54 <prvSetupTimerInterrupt+0x6>
    3f54:	00 d0       	rcall	.+0      	; 0x3f56 <prvSetupTimerInterrupt+0x8>
    3f56:	00 d0       	rcall	.+0      	; 0x3f58 <prvSetupTimerInterrupt+0xa>
    3f58:	cd b7       	in	r28, 0x3d	; 61
    3f5a:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3f5c:	80 e4       	ldi	r24, 0x40	; 64
    3f5e:	9f e1       	ldi	r25, 0x1F	; 31
    3f60:	a0 e0       	ldi	r26, 0x00	; 0
    3f62:	b0 e0       	ldi	r27, 0x00	; 0
    3f64:	8b 83       	std	Y+3, r24	; 0x03
    3f66:	9c 83       	std	Y+4, r25	; 0x04
    3f68:	ad 83       	std	Y+5, r26	; 0x05
    3f6a:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3f6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f70:	ad 81       	ldd	r26, Y+5	; 0x05
    3f72:	be 81       	ldd	r27, Y+6	; 0x06
    3f74:	68 94       	set
    3f76:	15 f8       	bld	r1, 5
    3f78:	b6 95       	lsr	r27
    3f7a:	a7 95       	ror	r26
    3f7c:	97 95       	ror	r25
    3f7e:	87 95       	ror	r24
    3f80:	16 94       	lsr	r1
    3f82:	d1 f7       	brne	.-12     	; 0x3f78 <prvSetupTimerInterrupt+0x2a>
    3f84:	8b 83       	std	Y+3, r24	; 0x03
    3f86:	9c 83       	std	Y+4, r25	; 0x04
    3f88:	ad 83       	std	Y+5, r26	; 0x05
    3f8a:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    3f8c:	8b 81       	ldd	r24, Y+3	; 0x03
    3f8e:	9c 81       	ldd	r25, Y+4	; 0x04
    3f90:	ad 81       	ldd	r26, Y+5	; 0x05
    3f92:	be 81       	ldd	r27, Y+6	; 0x06
    3f94:	01 97       	sbiw	r24, 0x01	; 1
    3f96:	a1 09       	sbc	r26, r1
    3f98:	b1 09       	sbc	r27, r1
    3f9a:	8b 83       	std	Y+3, r24	; 0x03
    3f9c:	9c 83       	std	Y+4, r25	; 0x04
    3f9e:	ad 83       	std	Y+5, r26	; 0x05
    3fa0:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    3fa4:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3fa6:	8b 81       	ldd	r24, Y+3	; 0x03
    3fa8:	9c 81       	ldd	r25, Y+4	; 0x04
    3faa:	ad 81       	ldd	r26, Y+5	; 0x05
    3fac:	be 81       	ldd	r27, Y+6	; 0x06
    3fae:	89 2f       	mov	r24, r25
    3fb0:	9a 2f       	mov	r25, r26
    3fb2:	ab 2f       	mov	r26, r27
    3fb4:	bb 27       	eor	r27, r27
    3fb6:	8b 83       	std	Y+3, r24	; 0x03
    3fb8:	9c 83       	std	Y+4, r25	; 0x04
    3fba:	ad 83       	std	Y+5, r26	; 0x05
    3fbc:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3fbe:	8b 81       	ldd	r24, Y+3	; 0x03
    3fc0:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3fc2:	eb e4       	ldi	r30, 0x4B	; 75
    3fc4:	f0 e0       	ldi	r31, 0x00	; 0
    3fc6:	8a 81       	ldd	r24, Y+2	; 0x02
    3fc8:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3fca:	ea e4       	ldi	r30, 0x4A	; 74
    3fcc:	f0 e0       	ldi	r31, 0x00	; 0
    3fce:	89 81       	ldd	r24, Y+1	; 0x01
    3fd0:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3fd2:	8b e0       	ldi	r24, 0x0B	; 11
    3fd4:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3fd6:	ee e4       	ldi	r30, 0x4E	; 78
    3fd8:	f0 e0       	ldi	r31, 0x00	; 0
    3fda:	89 81       	ldd	r24, Y+1	; 0x01
    3fdc:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3fde:	e9 e5       	ldi	r30, 0x59	; 89
    3fe0:	f0 e0       	ldi	r31, 0x00	; 0
    3fe2:	80 81       	ld	r24, Z
    3fe4:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3fe6:	89 81       	ldd	r24, Y+1	; 0x01
    3fe8:	80 61       	ori	r24, 0x10	; 16
    3fea:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3fec:	e9 e5       	ldi	r30, 0x59	; 89
    3fee:	f0 e0       	ldi	r31, 0x00	; 0
    3ff0:	89 81       	ldd	r24, Y+1	; 0x01
    3ff2:	80 83       	st	Z, r24
}
    3ff4:	26 96       	adiw	r28, 0x06	; 6
    3ff6:	0f b6       	in	r0, 0x3f	; 63
    3ff8:	f8 94       	cli
    3ffa:	de bf       	out	0x3e, r29	; 62
    3ffc:	0f be       	out	0x3f, r0	; 63
    3ffe:	cd bf       	out	0x3d, r28	; 61
    4000:	cf 91       	pop	r28
    4002:	df 91       	pop	r29
    4004:	08 95       	ret

00004006 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    4006:	0e 94 4c 1f 	call	0x3e98	; 0x3e98 <vPortYieldFromTick>
		asm volatile ( "reti" );
    400a:	18 95       	reti

0000400c <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    400c:	df 93       	push	r29
    400e:	cf 93       	push	r28
    4010:	cd b7       	in	r28, 0x3d	; 61
    4012:	de b7       	in	r29, 0x3e	; 62
    4014:	28 97       	sbiw	r28, 0x08	; 8
    4016:	0f b6       	in	r0, 0x3f	; 63
    4018:	f8 94       	cli
    401a:	de bf       	out	0x3e, r29	; 62
    401c:	0f be       	out	0x3f, r0	; 63
    401e:	cd bf       	out	0x3d, r28	; 61
    4020:	8f 83       	std	Y+7, r24	; 0x07
    4022:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    4024:	1a 82       	std	Y+2, r1	; 0x02
    4026:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    4028:	8f 81       	ldd	r24, Y+7	; 0x07
    402a:	88 23       	and	r24, r24
    402c:	09 f4       	brne	.+2      	; 0x4030 <xQueueCreate+0x24>
    402e:	8c c0       	rjmp	.+280    	; 0x4148 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    4030:	8f e1       	ldi	r24, 0x1F	; 31
    4032:	90 e0       	ldi	r25, 0x00	; 0
    4034:	0e 94 8d 1b 	call	0x371a	; 0x371a <pvPortMalloc>
    4038:	9e 83       	std	Y+6, r25	; 0x06
    403a:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    403c:	8d 81       	ldd	r24, Y+5	; 0x05
    403e:	9e 81       	ldd	r25, Y+6	; 0x06
    4040:	00 97       	sbiw	r24, 0x00	; 0
    4042:	09 f4       	brne	.+2      	; 0x4046 <xQueueCreate+0x3a>
    4044:	81 c0       	rjmp	.+258    	; 0x4148 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    4046:	8f 81       	ldd	r24, Y+7	; 0x07
    4048:	28 2f       	mov	r18, r24
    404a:	30 e0       	ldi	r19, 0x00	; 0
    404c:	88 85       	ldd	r24, Y+8	; 0x08
    404e:	88 2f       	mov	r24, r24
    4050:	90 e0       	ldi	r25, 0x00	; 0
    4052:	ac 01       	movw	r20, r24
    4054:	24 9f       	mul	r18, r20
    4056:	c0 01       	movw	r24, r0
    4058:	25 9f       	mul	r18, r21
    405a:	90 0d       	add	r25, r0
    405c:	34 9f       	mul	r19, r20
    405e:	90 0d       	add	r25, r0
    4060:	11 24       	eor	r1, r1
    4062:	01 96       	adiw	r24, 0x01	; 1
    4064:	9c 83       	std	Y+4, r25	; 0x04
    4066:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    4068:	8b 81       	ldd	r24, Y+3	; 0x03
    406a:	9c 81       	ldd	r25, Y+4	; 0x04
    406c:	0e 94 8d 1b 	call	0x371a	; 0x371a <pvPortMalloc>
    4070:	ed 81       	ldd	r30, Y+5	; 0x05
    4072:	fe 81       	ldd	r31, Y+6	; 0x06
    4074:	91 83       	std	Z+1, r25	; 0x01
    4076:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    4078:	ed 81       	ldd	r30, Y+5	; 0x05
    407a:	fe 81       	ldd	r31, Y+6	; 0x06
    407c:	80 81       	ld	r24, Z
    407e:	91 81       	ldd	r25, Z+1	; 0x01
    4080:	00 97       	sbiw	r24, 0x00	; 0
    4082:	09 f4       	brne	.+2      	; 0x4086 <xQueueCreate+0x7a>
    4084:	5d c0       	rjmp	.+186    	; 0x4140 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    4086:	ed 81       	ldd	r30, Y+5	; 0x05
    4088:	fe 81       	ldd	r31, Y+6	; 0x06
    408a:	40 81       	ld	r20, Z
    408c:	51 81       	ldd	r21, Z+1	; 0x01
    408e:	8f 81       	ldd	r24, Y+7	; 0x07
    4090:	28 2f       	mov	r18, r24
    4092:	30 e0       	ldi	r19, 0x00	; 0
    4094:	88 85       	ldd	r24, Y+8	; 0x08
    4096:	88 2f       	mov	r24, r24
    4098:	90 e0       	ldi	r25, 0x00	; 0
    409a:	bc 01       	movw	r22, r24
    409c:	26 9f       	mul	r18, r22
    409e:	c0 01       	movw	r24, r0
    40a0:	27 9f       	mul	r18, r23
    40a2:	90 0d       	add	r25, r0
    40a4:	36 9f       	mul	r19, r22
    40a6:	90 0d       	add	r25, r0
    40a8:	11 24       	eor	r1, r1
    40aa:	84 0f       	add	r24, r20
    40ac:	95 1f       	adc	r25, r21
    40ae:	ed 81       	ldd	r30, Y+5	; 0x05
    40b0:	fe 81       	ldd	r31, Y+6	; 0x06
    40b2:	93 83       	std	Z+3, r25	; 0x03
    40b4:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    40b6:	ed 81       	ldd	r30, Y+5	; 0x05
    40b8:	fe 81       	ldd	r31, Y+6	; 0x06
    40ba:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    40bc:	ed 81       	ldd	r30, Y+5	; 0x05
    40be:	fe 81       	ldd	r31, Y+6	; 0x06
    40c0:	80 81       	ld	r24, Z
    40c2:	91 81       	ldd	r25, Z+1	; 0x01
    40c4:	ed 81       	ldd	r30, Y+5	; 0x05
    40c6:	fe 81       	ldd	r31, Y+6	; 0x06
    40c8:	95 83       	std	Z+5, r25	; 0x05
    40ca:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    40cc:	ed 81       	ldd	r30, Y+5	; 0x05
    40ce:	fe 81       	ldd	r31, Y+6	; 0x06
    40d0:	40 81       	ld	r20, Z
    40d2:	51 81       	ldd	r21, Z+1	; 0x01
    40d4:	8f 81       	ldd	r24, Y+7	; 0x07
    40d6:	88 2f       	mov	r24, r24
    40d8:	90 e0       	ldi	r25, 0x00	; 0
    40da:	9c 01       	movw	r18, r24
    40dc:	21 50       	subi	r18, 0x01	; 1
    40de:	30 40       	sbci	r19, 0x00	; 0
    40e0:	88 85       	ldd	r24, Y+8	; 0x08
    40e2:	88 2f       	mov	r24, r24
    40e4:	90 e0       	ldi	r25, 0x00	; 0
    40e6:	bc 01       	movw	r22, r24
    40e8:	26 9f       	mul	r18, r22
    40ea:	c0 01       	movw	r24, r0
    40ec:	27 9f       	mul	r18, r23
    40ee:	90 0d       	add	r25, r0
    40f0:	36 9f       	mul	r19, r22
    40f2:	90 0d       	add	r25, r0
    40f4:	11 24       	eor	r1, r1
    40f6:	84 0f       	add	r24, r20
    40f8:	95 1f       	adc	r25, r21
    40fa:	ed 81       	ldd	r30, Y+5	; 0x05
    40fc:	fe 81       	ldd	r31, Y+6	; 0x06
    40fe:	97 83       	std	Z+7, r25	; 0x07
    4100:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    4102:	ed 81       	ldd	r30, Y+5	; 0x05
    4104:	fe 81       	ldd	r31, Y+6	; 0x06
    4106:	8f 81       	ldd	r24, Y+7	; 0x07
    4108:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    410a:	ed 81       	ldd	r30, Y+5	; 0x05
    410c:	fe 81       	ldd	r31, Y+6	; 0x06
    410e:	88 85       	ldd	r24, Y+8	; 0x08
    4110:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    4112:	ed 81       	ldd	r30, Y+5	; 0x05
    4114:	fe 81       	ldd	r31, Y+6	; 0x06
    4116:	8f ef       	ldi	r24, 0xFF	; 255
    4118:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    411a:	ed 81       	ldd	r30, Y+5	; 0x05
    411c:	fe 81       	ldd	r31, Y+6	; 0x06
    411e:	8f ef       	ldi	r24, 0xFF	; 255
    4120:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    4122:	8d 81       	ldd	r24, Y+5	; 0x05
    4124:	9e 81       	ldd	r25, Y+6	; 0x06
    4126:	08 96       	adiw	r24, 0x08	; 8
    4128:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    412c:	8d 81       	ldd	r24, Y+5	; 0x05
    412e:	9e 81       	ldd	r25, Y+6	; 0x06
    4130:	41 96       	adiw	r24, 0x11	; 17
    4132:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    4136:	8d 81       	ldd	r24, Y+5	; 0x05
    4138:	9e 81       	ldd	r25, Y+6	; 0x06
    413a:	9a 83       	std	Y+2, r25	; 0x02
    413c:	89 83       	std	Y+1, r24	; 0x01
    413e:	04 c0       	rjmp	.+8      	; 0x4148 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    4140:	8d 81       	ldd	r24, Y+5	; 0x05
    4142:	9e 81       	ldd	r25, Y+6	; 0x06
    4144:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    4148:	89 81       	ldd	r24, Y+1	; 0x01
    414a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    414c:	28 96       	adiw	r28, 0x08	; 8
    414e:	0f b6       	in	r0, 0x3f	; 63
    4150:	f8 94       	cli
    4152:	de bf       	out	0x3e, r29	; 62
    4154:	0f be       	out	0x3f, r0	; 63
    4156:	cd bf       	out	0x3d, r28	; 61
    4158:	cf 91       	pop	r28
    415a:	df 91       	pop	r29
    415c:	08 95       	ret

0000415e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    415e:	df 93       	push	r29
    4160:	cf 93       	push	r28
    4162:	cd b7       	in	r28, 0x3d	; 61
    4164:	de b7       	in	r29, 0x3e	; 62
    4166:	2c 97       	sbiw	r28, 0x0c	; 12
    4168:	0f b6       	in	r0, 0x3f	; 63
    416a:	f8 94       	cli
    416c:	de bf       	out	0x3e, r29	; 62
    416e:	0f be       	out	0x3f, r0	; 63
    4170:	cd bf       	out	0x3d, r28	; 61
    4172:	9e 83       	std	Y+6, r25	; 0x06
    4174:	8d 83       	std	Y+5, r24	; 0x05
    4176:	78 87       	std	Y+8, r23	; 0x08
    4178:	6f 83       	std	Y+7, r22	; 0x07
    417a:	5a 87       	std	Y+10, r21	; 0x0a
    417c:	49 87       	std	Y+9, r20	; 0x09
    417e:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    4180:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    4182:	0f b6       	in	r0, 0x3f	; 63
    4184:	f8 94       	cli
    4186:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    4188:	ed 81       	ldd	r30, Y+5	; 0x05
    418a:	fe 81       	ldd	r31, Y+6	; 0x06
    418c:	92 8d       	ldd	r25, Z+26	; 0x1a
    418e:	ed 81       	ldd	r30, Y+5	; 0x05
    4190:	fe 81       	ldd	r31, Y+6	; 0x06
    4192:	83 8d       	ldd	r24, Z+27	; 0x1b
    4194:	98 17       	cp	r25, r24
    4196:	d8 f4       	brcc	.+54     	; 0x41ce <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    4198:	8d 81       	ldd	r24, Y+5	; 0x05
    419a:	9e 81       	ldd	r25, Y+6	; 0x06
    419c:	2f 81       	ldd	r18, Y+7	; 0x07
    419e:	38 85       	ldd	r19, Y+8	; 0x08
    41a0:	b9 01       	movw	r22, r18
    41a2:	4b 85       	ldd	r20, Y+11	; 0x0b
    41a4:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    41a8:	ed 81       	ldd	r30, Y+5	; 0x05
    41aa:	fe 81       	ldd	r31, Y+6	; 0x06
    41ac:	81 89       	ldd	r24, Z+17	; 0x11
    41ae:	88 23       	and	r24, r24
    41b0:	49 f0       	breq	.+18     	; 0x41c4 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    41b2:	8d 81       	ldd	r24, Y+5	; 0x05
    41b4:	9e 81       	ldd	r25, Y+6	; 0x06
    41b6:	41 96       	adiw	r24, 0x11	; 17
    41b8:	0e 94 ff 28 	call	0x51fe	; 0x51fe <xTaskRemoveFromEventList>
    41bc:	81 30       	cpi	r24, 0x01	; 1
    41be:	11 f4       	brne	.+4      	; 0x41c4 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    41c0:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    41c4:	0f 90       	pop	r0
    41c6:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    41c8:	81 e0       	ldi	r24, 0x01	; 1
    41ca:	8c 87       	std	Y+12, r24	; 0x0c
    41cc:	5c c0       	rjmp	.+184    	; 0x4286 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    41ce:	89 85       	ldd	r24, Y+9	; 0x09
    41d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    41d2:	00 97       	sbiw	r24, 0x00	; 0
    41d4:	21 f4       	brne	.+8      	; 0x41de <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    41d6:	0f 90       	pop	r0
    41d8:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    41da:	1c 86       	std	Y+12, r1	; 0x0c
    41dc:	54 c0       	rjmp	.+168    	; 0x4286 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    41de:	89 81       	ldd	r24, Y+1	; 0x01
    41e0:	88 23       	and	r24, r24
    41e2:	31 f4       	brne	.+12     	; 0x41f0 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    41e4:	ce 01       	movw	r24, r28
    41e6:	02 96       	adiw	r24, 0x02	; 2
    41e8:	0e 94 67 29 	call	0x52ce	; 0x52ce <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    41ec:	81 e0       	ldi	r24, 0x01	; 1
    41ee:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    41f0:	0f 90       	pop	r0
    41f2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    41f4:	0e 94 c3 26 	call	0x4d86	; 0x4d86 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    41f8:	0f b6       	in	r0, 0x3f	; 63
    41fa:	f8 94       	cli
    41fc:	0f 92       	push	r0
    41fe:	ed 81       	ldd	r30, Y+5	; 0x05
    4200:	fe 81       	ldd	r31, Y+6	; 0x06
    4202:	85 8d       	ldd	r24, Z+29	; 0x1d
    4204:	8f 3f       	cpi	r24, 0xFF	; 255
    4206:	19 f4       	brne	.+6      	; 0x420e <xQueueGenericSend+0xb0>
    4208:	ed 81       	ldd	r30, Y+5	; 0x05
    420a:	fe 81       	ldd	r31, Y+6	; 0x06
    420c:	15 8e       	std	Z+29, r1	; 0x1d
    420e:	ed 81       	ldd	r30, Y+5	; 0x05
    4210:	fe 81       	ldd	r31, Y+6	; 0x06
    4212:	86 8d       	ldd	r24, Z+30	; 0x1e
    4214:	8f 3f       	cpi	r24, 0xFF	; 255
    4216:	19 f4       	brne	.+6      	; 0x421e <xQueueGenericSend+0xc0>
    4218:	ed 81       	ldd	r30, Y+5	; 0x05
    421a:	fe 81       	ldd	r31, Y+6	; 0x06
    421c:	16 8e       	std	Z+30, r1	; 0x1e
    421e:	0f 90       	pop	r0
    4220:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4222:	ce 01       	movw	r24, r28
    4224:	02 96       	adiw	r24, 0x02	; 2
    4226:	9e 01       	movw	r18, r28
    4228:	27 5f       	subi	r18, 0xF7	; 247
    422a:	3f 4f       	sbci	r19, 0xFF	; 255
    422c:	b9 01       	movw	r22, r18
    422e:	0e 94 80 29 	call	0x5300	; 0x5300 <xTaskCheckForTimeOut>
    4232:	88 23       	and	r24, r24
    4234:	09 f5       	brne	.+66     	; 0x4278 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4236:	8d 81       	ldd	r24, Y+5	; 0x05
    4238:	9e 81       	ldd	r25, Y+6	; 0x06
    423a:	0e 94 4e 24 	call	0x489c	; 0x489c <prvIsQueueFull>
    423e:	88 23       	and	r24, r24
    4240:	a1 f0       	breq	.+40     	; 0x426a <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    4242:	8d 81       	ldd	r24, Y+5	; 0x05
    4244:	9e 81       	ldd	r25, Y+6	; 0x06
    4246:	08 96       	adiw	r24, 0x08	; 8
    4248:	29 85       	ldd	r18, Y+9	; 0x09
    424a:	3a 85       	ldd	r19, Y+10	; 0x0a
    424c:	b9 01       	movw	r22, r18
    424e:	0e 94 c9 28 	call	0x5192	; 0x5192 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    4252:	8d 81       	ldd	r24, Y+5	; 0x05
    4254:	9e 81       	ldd	r25, Y+6	; 0x06
    4256:	0e 94 c7 23 	call	0x478e	; 0x478e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    425a:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <xTaskResumeAll>
    425e:	88 23       	and	r24, r24
    4260:	09 f0       	breq	.+2      	; 0x4264 <xQueueGenericSend+0x106>
    4262:	8f cf       	rjmp	.-226    	; 0x4182 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    4264:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <vPortYield>
    4268:	8c cf       	rjmp	.-232    	; 0x4182 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    426a:	8d 81       	ldd	r24, Y+5	; 0x05
    426c:	9e 81       	ldd	r25, Y+6	; 0x06
    426e:	0e 94 c7 23 	call	0x478e	; 0x478e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4272:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <xTaskResumeAll>
    4276:	85 cf       	rjmp	.-246    	; 0x4182 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    4278:	8d 81       	ldd	r24, Y+5	; 0x05
    427a:	9e 81       	ldd	r25, Y+6	; 0x06
    427c:	0e 94 c7 23 	call	0x478e	; 0x478e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    4280:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    4284:	1c 86       	std	Y+12, r1	; 0x0c
    4286:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    4288:	2c 96       	adiw	r28, 0x0c	; 12
    428a:	0f b6       	in	r0, 0x3f	; 63
    428c:	f8 94       	cli
    428e:	de bf       	out	0x3e, r29	; 62
    4290:	0f be       	out	0x3f, r0	; 63
    4292:	cd bf       	out	0x3d, r28	; 61
    4294:	cf 91       	pop	r28
    4296:	df 91       	pop	r29
    4298:	08 95       	ret

0000429a <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    429a:	df 93       	push	r29
    429c:	cf 93       	push	r28
    429e:	cd b7       	in	r28, 0x3d	; 61
    42a0:	de b7       	in	r29, 0x3e	; 62
    42a2:	29 97       	sbiw	r28, 0x09	; 9
    42a4:	0f b6       	in	r0, 0x3f	; 63
    42a6:	f8 94       	cli
    42a8:	de bf       	out	0x3e, r29	; 62
    42aa:	0f be       	out	0x3f, r0	; 63
    42ac:	cd bf       	out	0x3d, r28	; 61
    42ae:	9c 83       	std	Y+4, r25	; 0x04
    42b0:	8b 83       	std	Y+3, r24	; 0x03
    42b2:	7e 83       	std	Y+6, r23	; 0x06
    42b4:	6d 83       	std	Y+5, r22	; 0x05
    42b6:	58 87       	std	Y+8, r21	; 0x08
    42b8:	4f 83       	std	Y+7, r20	; 0x07
    42ba:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    42bc:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    42be:	eb 81       	ldd	r30, Y+3	; 0x03
    42c0:	fc 81       	ldd	r31, Y+4	; 0x04
    42c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    42c4:	eb 81       	ldd	r30, Y+3	; 0x03
    42c6:	fc 81       	ldd	r31, Y+4	; 0x04
    42c8:	83 8d       	ldd	r24, Z+27	; 0x1b
    42ca:	98 17       	cp	r25, r24
    42cc:	40 f5       	brcc	.+80     	; 0x431e <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    42ce:	8b 81       	ldd	r24, Y+3	; 0x03
    42d0:	9c 81       	ldd	r25, Y+4	; 0x04
    42d2:	2d 81       	ldd	r18, Y+5	; 0x05
    42d4:	3e 81       	ldd	r19, Y+6	; 0x06
    42d6:	b9 01       	movw	r22, r18
    42d8:	49 85       	ldd	r20, Y+9	; 0x09
    42da:	0e 94 ea 22 	call	0x45d4	; 0x45d4 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    42de:	eb 81       	ldd	r30, Y+3	; 0x03
    42e0:	fc 81       	ldd	r31, Y+4	; 0x04
    42e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    42e4:	8f 3f       	cpi	r24, 0xFF	; 255
    42e6:	89 f4       	brne	.+34     	; 0x430a <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    42e8:	eb 81       	ldd	r30, Y+3	; 0x03
    42ea:	fc 81       	ldd	r31, Y+4	; 0x04
    42ec:	81 89       	ldd	r24, Z+17	; 0x11
    42ee:	88 23       	and	r24, r24
    42f0:	99 f0       	breq	.+38     	; 0x4318 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    42f2:	8b 81       	ldd	r24, Y+3	; 0x03
    42f4:	9c 81       	ldd	r25, Y+4	; 0x04
    42f6:	41 96       	adiw	r24, 0x11	; 17
    42f8:	0e 94 ff 28 	call	0x51fe	; 0x51fe <xTaskRemoveFromEventList>
    42fc:	88 23       	and	r24, r24
    42fe:	61 f0       	breq	.+24     	; 0x4318 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    4300:	ef 81       	ldd	r30, Y+7	; 0x07
    4302:	f8 85       	ldd	r31, Y+8	; 0x08
    4304:	81 e0       	ldi	r24, 0x01	; 1
    4306:	80 83       	st	Z, r24
    4308:	07 c0       	rjmp	.+14     	; 0x4318 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    430a:	eb 81       	ldd	r30, Y+3	; 0x03
    430c:	fc 81       	ldd	r31, Y+4	; 0x04
    430e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4310:	8f 5f       	subi	r24, 0xFF	; 255
    4312:	eb 81       	ldd	r30, Y+3	; 0x03
    4314:	fc 81       	ldd	r31, Y+4	; 0x04
    4316:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    4318:	81 e0       	ldi	r24, 0x01	; 1
    431a:	8a 83       	std	Y+2, r24	; 0x02
    431c:	01 c0       	rjmp	.+2      	; 0x4320 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    431e:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4320:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4322:	29 96       	adiw	r28, 0x09	; 9
    4324:	0f b6       	in	r0, 0x3f	; 63
    4326:	f8 94       	cli
    4328:	de bf       	out	0x3e, r29	; 62
    432a:	0f be       	out	0x3f, r0	; 63
    432c:	cd bf       	out	0x3d, r28	; 61
    432e:	cf 91       	pop	r28
    4330:	df 91       	pop	r29
    4332:	08 95       	ret

00004334 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    4334:	df 93       	push	r29
    4336:	cf 93       	push	r28
    4338:	cd b7       	in	r28, 0x3d	; 61
    433a:	de b7       	in	r29, 0x3e	; 62
    433c:	2e 97       	sbiw	r28, 0x0e	; 14
    433e:	0f b6       	in	r0, 0x3f	; 63
    4340:	f8 94       	cli
    4342:	de bf       	out	0x3e, r29	; 62
    4344:	0f be       	out	0x3f, r0	; 63
    4346:	cd bf       	out	0x3d, r28	; 61
    4348:	98 87       	std	Y+8, r25	; 0x08
    434a:	8f 83       	std	Y+7, r24	; 0x07
    434c:	7a 87       	std	Y+10, r23	; 0x0a
    434e:	69 87       	std	Y+9, r22	; 0x09
    4350:	5c 87       	std	Y+12, r21	; 0x0c
    4352:	4b 87       	std	Y+11, r20	; 0x0b
    4354:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    4356:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    4358:	0f b6       	in	r0, 0x3f	; 63
    435a:	f8 94       	cli
    435c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    435e:	ef 81       	ldd	r30, Y+7	; 0x07
    4360:	f8 85       	ldd	r31, Y+8	; 0x08
    4362:	82 8d       	ldd	r24, Z+26	; 0x1a
    4364:	88 23       	and	r24, r24
    4366:	09 f4       	brne	.+2      	; 0x436a <xQueueGenericReceive+0x36>
    4368:	3f c0       	rjmp	.+126    	; 0x43e8 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    436a:	ef 81       	ldd	r30, Y+7	; 0x07
    436c:	f8 85       	ldd	r31, Y+8	; 0x08
    436e:	86 81       	ldd	r24, Z+6	; 0x06
    4370:	97 81       	ldd	r25, Z+7	; 0x07
    4372:	9a 83       	std	Y+2, r25	; 0x02
    4374:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    4376:	8f 81       	ldd	r24, Y+7	; 0x07
    4378:	98 85       	ldd	r25, Y+8	; 0x08
    437a:	29 85       	ldd	r18, Y+9	; 0x09
    437c:	3a 85       	ldd	r19, Y+10	; 0x0a
    437e:	b9 01       	movw	r22, r18
    4380:	0e 94 7f 23 	call	0x46fe	; 0x46fe <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    4384:	8d 85       	ldd	r24, Y+13	; 0x0d
    4386:	88 23       	and	r24, r24
    4388:	b1 f4       	brne	.+44     	; 0x43b6 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    438a:	ef 81       	ldd	r30, Y+7	; 0x07
    438c:	f8 85       	ldd	r31, Y+8	; 0x08
    438e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4390:	81 50       	subi	r24, 0x01	; 1
    4392:	ef 81       	ldd	r30, Y+7	; 0x07
    4394:	f8 85       	ldd	r31, Y+8	; 0x08
    4396:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4398:	ef 81       	ldd	r30, Y+7	; 0x07
    439a:	f8 85       	ldd	r31, Y+8	; 0x08
    439c:	80 85       	ldd	r24, Z+8	; 0x08
    439e:	88 23       	and	r24, r24
    43a0:	f1 f0       	breq	.+60     	; 0x43de <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    43a2:	8f 81       	ldd	r24, Y+7	; 0x07
    43a4:	98 85       	ldd	r25, Y+8	; 0x08
    43a6:	08 96       	adiw	r24, 0x08	; 8
    43a8:	0e 94 ff 28 	call	0x51fe	; 0x51fe <xTaskRemoveFromEventList>
    43ac:	81 30       	cpi	r24, 0x01	; 1
    43ae:	b9 f4       	brne	.+46     	; 0x43de <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    43b0:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <vPortYield>
    43b4:	14 c0       	rjmp	.+40     	; 0x43de <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    43b6:	ef 81       	ldd	r30, Y+7	; 0x07
    43b8:	f8 85       	ldd	r31, Y+8	; 0x08
    43ba:	89 81       	ldd	r24, Y+1	; 0x01
    43bc:	9a 81       	ldd	r25, Y+2	; 0x02
    43be:	97 83       	std	Z+7, r25	; 0x07
    43c0:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    43c2:	ef 81       	ldd	r30, Y+7	; 0x07
    43c4:	f8 85       	ldd	r31, Y+8	; 0x08
    43c6:	81 89       	ldd	r24, Z+17	; 0x11
    43c8:	88 23       	and	r24, r24
    43ca:	49 f0       	breq	.+18     	; 0x43de <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    43cc:	8f 81       	ldd	r24, Y+7	; 0x07
    43ce:	98 85       	ldd	r25, Y+8	; 0x08
    43d0:	41 96       	adiw	r24, 0x11	; 17
    43d2:	0e 94 ff 28 	call	0x51fe	; 0x51fe <xTaskRemoveFromEventList>
    43d6:	88 23       	and	r24, r24
    43d8:	11 f0       	breq	.+4      	; 0x43de <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    43da:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    43de:	0f 90       	pop	r0
    43e0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    43e2:	81 e0       	ldi	r24, 0x01	; 1
    43e4:	8e 87       	std	Y+14, r24	; 0x0e
    43e6:	5c c0       	rjmp	.+184    	; 0x44a0 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    43e8:	8b 85       	ldd	r24, Y+11	; 0x0b
    43ea:	9c 85       	ldd	r25, Y+12	; 0x0c
    43ec:	00 97       	sbiw	r24, 0x00	; 0
    43ee:	21 f4       	brne	.+8      	; 0x43f8 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    43f0:	0f 90       	pop	r0
    43f2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    43f4:	1e 86       	std	Y+14, r1	; 0x0e
    43f6:	54 c0       	rjmp	.+168    	; 0x44a0 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    43f8:	8b 81       	ldd	r24, Y+3	; 0x03
    43fa:	88 23       	and	r24, r24
    43fc:	31 f4       	brne	.+12     	; 0x440a <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    43fe:	ce 01       	movw	r24, r28
    4400:	04 96       	adiw	r24, 0x04	; 4
    4402:	0e 94 67 29 	call	0x52ce	; 0x52ce <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    4406:	81 e0       	ldi	r24, 0x01	; 1
    4408:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    440a:	0f 90       	pop	r0
    440c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    440e:	0e 94 c3 26 	call	0x4d86	; 0x4d86 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4412:	0f b6       	in	r0, 0x3f	; 63
    4414:	f8 94       	cli
    4416:	0f 92       	push	r0
    4418:	ef 81       	ldd	r30, Y+7	; 0x07
    441a:	f8 85       	ldd	r31, Y+8	; 0x08
    441c:	85 8d       	ldd	r24, Z+29	; 0x1d
    441e:	8f 3f       	cpi	r24, 0xFF	; 255
    4420:	19 f4       	brne	.+6      	; 0x4428 <xQueueGenericReceive+0xf4>
    4422:	ef 81       	ldd	r30, Y+7	; 0x07
    4424:	f8 85       	ldd	r31, Y+8	; 0x08
    4426:	15 8e       	std	Z+29, r1	; 0x1d
    4428:	ef 81       	ldd	r30, Y+7	; 0x07
    442a:	f8 85       	ldd	r31, Y+8	; 0x08
    442c:	86 8d       	ldd	r24, Z+30	; 0x1e
    442e:	8f 3f       	cpi	r24, 0xFF	; 255
    4430:	19 f4       	brne	.+6      	; 0x4438 <xQueueGenericReceive+0x104>
    4432:	ef 81       	ldd	r30, Y+7	; 0x07
    4434:	f8 85       	ldd	r31, Y+8	; 0x08
    4436:	16 8e       	std	Z+30, r1	; 0x1e
    4438:	0f 90       	pop	r0
    443a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    443c:	ce 01       	movw	r24, r28
    443e:	04 96       	adiw	r24, 0x04	; 4
    4440:	9e 01       	movw	r18, r28
    4442:	25 5f       	subi	r18, 0xF5	; 245
    4444:	3f 4f       	sbci	r19, 0xFF	; 255
    4446:	b9 01       	movw	r22, r18
    4448:	0e 94 80 29 	call	0x5300	; 0x5300 <xTaskCheckForTimeOut>
    444c:	88 23       	and	r24, r24
    444e:	09 f5       	brne	.+66     	; 0x4492 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4450:	8f 81       	ldd	r24, Y+7	; 0x07
    4452:	98 85       	ldd	r25, Y+8	; 0x08
    4454:	0e 94 1b 24 	call	0x4836	; 0x4836 <prvIsQueueEmpty>
    4458:	88 23       	and	r24, r24
    445a:	a1 f0       	breq	.+40     	; 0x4484 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    445c:	8f 81       	ldd	r24, Y+7	; 0x07
    445e:	98 85       	ldd	r25, Y+8	; 0x08
    4460:	41 96       	adiw	r24, 0x11	; 17
    4462:	2b 85       	ldd	r18, Y+11	; 0x0b
    4464:	3c 85       	ldd	r19, Y+12	; 0x0c
    4466:	b9 01       	movw	r22, r18
    4468:	0e 94 c9 28 	call	0x5192	; 0x5192 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    446c:	8f 81       	ldd	r24, Y+7	; 0x07
    446e:	98 85       	ldd	r25, Y+8	; 0x08
    4470:	0e 94 c7 23 	call	0x478e	; 0x478e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    4474:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <xTaskResumeAll>
    4478:	88 23       	and	r24, r24
    447a:	09 f0       	breq	.+2      	; 0x447e <xQueueGenericReceive+0x14a>
    447c:	6d cf       	rjmp	.-294    	; 0x4358 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    447e:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <vPortYield>
    4482:	6a cf       	rjmp	.-300    	; 0x4358 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    4484:	8f 81       	ldd	r24, Y+7	; 0x07
    4486:	98 85       	ldd	r25, Y+8	; 0x08
    4488:	0e 94 c7 23 	call	0x478e	; 0x478e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    448c:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <xTaskResumeAll>
    4490:	63 cf       	rjmp	.-314    	; 0x4358 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    4492:	8f 81       	ldd	r24, Y+7	; 0x07
    4494:	98 85       	ldd	r25, Y+8	; 0x08
    4496:	0e 94 c7 23 	call	0x478e	; 0x478e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    449a:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    449e:	1e 86       	std	Y+14, r1	; 0x0e
    44a0:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    44a2:	2e 96       	adiw	r28, 0x0e	; 14
    44a4:	0f b6       	in	r0, 0x3f	; 63
    44a6:	f8 94       	cli
    44a8:	de bf       	out	0x3e, r29	; 62
    44aa:	0f be       	out	0x3f, r0	; 63
    44ac:	cd bf       	out	0x3d, r28	; 61
    44ae:	cf 91       	pop	r28
    44b0:	df 91       	pop	r29
    44b2:	08 95       	ret

000044b4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    44b4:	df 93       	push	r29
    44b6:	cf 93       	push	r28
    44b8:	cd b7       	in	r28, 0x3d	; 61
    44ba:	de b7       	in	r29, 0x3e	; 62
    44bc:	28 97       	sbiw	r28, 0x08	; 8
    44be:	0f b6       	in	r0, 0x3f	; 63
    44c0:	f8 94       	cli
    44c2:	de bf       	out	0x3e, r29	; 62
    44c4:	0f be       	out	0x3f, r0	; 63
    44c6:	cd bf       	out	0x3d, r28	; 61
    44c8:	9c 83       	std	Y+4, r25	; 0x04
    44ca:	8b 83       	std	Y+3, r24	; 0x03
    44cc:	7e 83       	std	Y+6, r23	; 0x06
    44ce:	6d 83       	std	Y+5, r22	; 0x05
    44d0:	58 87       	std	Y+8, r21	; 0x08
    44d2:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    44d4:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    44d6:	eb 81       	ldd	r30, Y+3	; 0x03
    44d8:	fc 81       	ldd	r31, Y+4	; 0x04
    44da:	82 8d       	ldd	r24, Z+26	; 0x1a
    44dc:	88 23       	and	r24, r24
    44de:	71 f1       	breq	.+92     	; 0x453c <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    44e0:	8b 81       	ldd	r24, Y+3	; 0x03
    44e2:	9c 81       	ldd	r25, Y+4	; 0x04
    44e4:	2d 81       	ldd	r18, Y+5	; 0x05
    44e6:	3e 81       	ldd	r19, Y+6	; 0x06
    44e8:	b9 01       	movw	r22, r18
    44ea:	0e 94 7f 23 	call	0x46fe	; 0x46fe <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    44ee:	eb 81       	ldd	r30, Y+3	; 0x03
    44f0:	fc 81       	ldd	r31, Y+4	; 0x04
    44f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    44f4:	81 50       	subi	r24, 0x01	; 1
    44f6:	eb 81       	ldd	r30, Y+3	; 0x03
    44f8:	fc 81       	ldd	r31, Y+4	; 0x04
    44fa:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    44fc:	eb 81       	ldd	r30, Y+3	; 0x03
    44fe:	fc 81       	ldd	r31, Y+4	; 0x04
    4500:	85 8d       	ldd	r24, Z+29	; 0x1d
    4502:	8f 3f       	cpi	r24, 0xFF	; 255
    4504:	89 f4       	brne	.+34     	; 0x4528 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4506:	eb 81       	ldd	r30, Y+3	; 0x03
    4508:	fc 81       	ldd	r31, Y+4	; 0x04
    450a:	80 85       	ldd	r24, Z+8	; 0x08
    450c:	88 23       	and	r24, r24
    450e:	99 f0       	breq	.+38     	; 0x4536 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4510:	8b 81       	ldd	r24, Y+3	; 0x03
    4512:	9c 81       	ldd	r25, Y+4	; 0x04
    4514:	08 96       	adiw	r24, 0x08	; 8
    4516:	0e 94 ff 28 	call	0x51fe	; 0x51fe <xTaskRemoveFromEventList>
    451a:	88 23       	and	r24, r24
    451c:	61 f0       	breq	.+24     	; 0x4536 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    451e:	ef 81       	ldd	r30, Y+7	; 0x07
    4520:	f8 85       	ldd	r31, Y+8	; 0x08
    4522:	81 e0       	ldi	r24, 0x01	; 1
    4524:	80 83       	st	Z, r24
    4526:	07 c0       	rjmp	.+14     	; 0x4536 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    4528:	eb 81       	ldd	r30, Y+3	; 0x03
    452a:	fc 81       	ldd	r31, Y+4	; 0x04
    452c:	85 8d       	ldd	r24, Z+29	; 0x1d
    452e:	8f 5f       	subi	r24, 0xFF	; 255
    4530:	eb 81       	ldd	r30, Y+3	; 0x03
    4532:	fc 81       	ldd	r31, Y+4	; 0x04
    4534:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    4536:	81 e0       	ldi	r24, 0x01	; 1
    4538:	8a 83       	std	Y+2, r24	; 0x02
    453a:	01 c0       	rjmp	.+2      	; 0x453e <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    453c:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    453e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4540:	28 96       	adiw	r28, 0x08	; 8
    4542:	0f b6       	in	r0, 0x3f	; 63
    4544:	f8 94       	cli
    4546:	de bf       	out	0x3e, r29	; 62
    4548:	0f be       	out	0x3f, r0	; 63
    454a:	cd bf       	out	0x3d, r28	; 61
    454c:	cf 91       	pop	r28
    454e:	df 91       	pop	r29
    4550:	08 95       	ret

00004552 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    4552:	df 93       	push	r29
    4554:	cf 93       	push	r28
    4556:	00 d0       	rcall	.+0      	; 0x4558 <uxQueueMessagesWaiting+0x6>
    4558:	0f 92       	push	r0
    455a:	cd b7       	in	r28, 0x3d	; 61
    455c:	de b7       	in	r29, 0x3e	; 62
    455e:	9b 83       	std	Y+3, r25	; 0x03
    4560:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    4562:	0f b6       	in	r0, 0x3f	; 63
    4564:	f8 94       	cli
    4566:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    4568:	ea 81       	ldd	r30, Y+2	; 0x02
    456a:	fb 81       	ldd	r31, Y+3	; 0x03
    456c:	82 8d       	ldd	r24, Z+26	; 0x1a
    456e:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    4570:	0f 90       	pop	r0
    4572:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    4574:	89 81       	ldd	r24, Y+1	; 0x01
}
    4576:	0f 90       	pop	r0
    4578:	0f 90       	pop	r0
    457a:	0f 90       	pop	r0
    457c:	cf 91       	pop	r28
    457e:	df 91       	pop	r29
    4580:	08 95       	ret

00004582 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    4582:	df 93       	push	r29
    4584:	cf 93       	push	r28
    4586:	00 d0       	rcall	.+0      	; 0x4588 <uxQueueMessagesWaitingFromISR+0x6>
    4588:	0f 92       	push	r0
    458a:	cd b7       	in	r28, 0x3d	; 61
    458c:	de b7       	in	r29, 0x3e	; 62
    458e:	9b 83       	std	Y+3, r25	; 0x03
    4590:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    4592:	ea 81       	ldd	r30, Y+2	; 0x02
    4594:	fb 81       	ldd	r31, Y+3	; 0x03
    4596:	82 8d       	ldd	r24, Z+26	; 0x1a
    4598:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    459a:	89 81       	ldd	r24, Y+1	; 0x01
}
    459c:	0f 90       	pop	r0
    459e:	0f 90       	pop	r0
    45a0:	0f 90       	pop	r0
    45a2:	cf 91       	pop	r28
    45a4:	df 91       	pop	r29
    45a6:	08 95       	ret

000045a8 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    45a8:	df 93       	push	r29
    45aa:	cf 93       	push	r28
    45ac:	00 d0       	rcall	.+0      	; 0x45ae <vQueueDelete+0x6>
    45ae:	cd b7       	in	r28, 0x3d	; 61
    45b0:	de b7       	in	r29, 0x3e	; 62
    45b2:	9a 83       	std	Y+2, r25	; 0x02
    45b4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    45b6:	e9 81       	ldd	r30, Y+1	; 0x01
    45b8:	fa 81       	ldd	r31, Y+2	; 0x02
    45ba:	80 81       	ld	r24, Z
    45bc:	91 81       	ldd	r25, Z+1	; 0x01
    45be:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <vPortFree>
	vPortFree( pxQueue );
    45c2:	89 81       	ldd	r24, Y+1	; 0x01
    45c4:	9a 81       	ldd	r25, Y+2	; 0x02
    45c6:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <vPortFree>
}
    45ca:	0f 90       	pop	r0
    45cc:	0f 90       	pop	r0
    45ce:	cf 91       	pop	r28
    45d0:	df 91       	pop	r29
    45d2:	08 95       	ret

000045d4 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    45d4:	df 93       	push	r29
    45d6:	cf 93       	push	r28
    45d8:	00 d0       	rcall	.+0      	; 0x45da <prvCopyDataToQueue+0x6>
    45da:	00 d0       	rcall	.+0      	; 0x45dc <prvCopyDataToQueue+0x8>
    45dc:	0f 92       	push	r0
    45de:	cd b7       	in	r28, 0x3d	; 61
    45e0:	de b7       	in	r29, 0x3e	; 62
    45e2:	9a 83       	std	Y+2, r25	; 0x02
    45e4:	89 83       	std	Y+1, r24	; 0x01
    45e6:	7c 83       	std	Y+4, r23	; 0x04
    45e8:	6b 83       	std	Y+3, r22	; 0x03
    45ea:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    45ec:	e9 81       	ldd	r30, Y+1	; 0x01
    45ee:	fa 81       	ldd	r31, Y+2	; 0x02
    45f0:	84 8d       	ldd	r24, Z+28	; 0x1c
    45f2:	88 23       	and	r24, r24
    45f4:	09 f4       	brne	.+2      	; 0x45f8 <prvCopyDataToQueue+0x24>
    45f6:	74 c0       	rjmp	.+232    	; 0x46e0 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    45f8:	8d 81       	ldd	r24, Y+5	; 0x05
    45fa:	88 23       	and	r24, r24
    45fc:	99 f5       	brne	.+102    	; 0x4664 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    45fe:	e9 81       	ldd	r30, Y+1	; 0x01
    4600:	fa 81       	ldd	r31, Y+2	; 0x02
    4602:	64 81       	ldd	r22, Z+4	; 0x04
    4604:	75 81       	ldd	r23, Z+5	; 0x05
    4606:	e9 81       	ldd	r30, Y+1	; 0x01
    4608:	fa 81       	ldd	r31, Y+2	; 0x02
    460a:	84 8d       	ldd	r24, Z+28	; 0x1c
    460c:	48 2f       	mov	r20, r24
    460e:	50 e0       	ldi	r21, 0x00	; 0
    4610:	2b 81       	ldd	r18, Y+3	; 0x03
    4612:	3c 81       	ldd	r19, Y+4	; 0x04
    4614:	cb 01       	movw	r24, r22
    4616:	b9 01       	movw	r22, r18
    4618:	0e 94 81 2c 	call	0x5902	; 0x5902 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    461c:	e9 81       	ldd	r30, Y+1	; 0x01
    461e:	fa 81       	ldd	r31, Y+2	; 0x02
    4620:	24 81       	ldd	r18, Z+4	; 0x04
    4622:	35 81       	ldd	r19, Z+5	; 0x05
    4624:	e9 81       	ldd	r30, Y+1	; 0x01
    4626:	fa 81       	ldd	r31, Y+2	; 0x02
    4628:	84 8d       	ldd	r24, Z+28	; 0x1c
    462a:	88 2f       	mov	r24, r24
    462c:	90 e0       	ldi	r25, 0x00	; 0
    462e:	82 0f       	add	r24, r18
    4630:	93 1f       	adc	r25, r19
    4632:	e9 81       	ldd	r30, Y+1	; 0x01
    4634:	fa 81       	ldd	r31, Y+2	; 0x02
    4636:	95 83       	std	Z+5, r25	; 0x05
    4638:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    463a:	e9 81       	ldd	r30, Y+1	; 0x01
    463c:	fa 81       	ldd	r31, Y+2	; 0x02
    463e:	24 81       	ldd	r18, Z+4	; 0x04
    4640:	35 81       	ldd	r19, Z+5	; 0x05
    4642:	e9 81       	ldd	r30, Y+1	; 0x01
    4644:	fa 81       	ldd	r31, Y+2	; 0x02
    4646:	82 81       	ldd	r24, Z+2	; 0x02
    4648:	93 81       	ldd	r25, Z+3	; 0x03
    464a:	28 17       	cp	r18, r24
    464c:	39 07       	cpc	r19, r25
    464e:	08 f4       	brcc	.+2      	; 0x4652 <prvCopyDataToQueue+0x7e>
    4650:	47 c0       	rjmp	.+142    	; 0x46e0 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    4652:	e9 81       	ldd	r30, Y+1	; 0x01
    4654:	fa 81       	ldd	r31, Y+2	; 0x02
    4656:	80 81       	ld	r24, Z
    4658:	91 81       	ldd	r25, Z+1	; 0x01
    465a:	e9 81       	ldd	r30, Y+1	; 0x01
    465c:	fa 81       	ldd	r31, Y+2	; 0x02
    465e:	95 83       	std	Z+5, r25	; 0x05
    4660:	84 83       	std	Z+4, r24	; 0x04
    4662:	3e c0       	rjmp	.+124    	; 0x46e0 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    4664:	e9 81       	ldd	r30, Y+1	; 0x01
    4666:	fa 81       	ldd	r31, Y+2	; 0x02
    4668:	66 81       	ldd	r22, Z+6	; 0x06
    466a:	77 81       	ldd	r23, Z+7	; 0x07
    466c:	e9 81       	ldd	r30, Y+1	; 0x01
    466e:	fa 81       	ldd	r31, Y+2	; 0x02
    4670:	84 8d       	ldd	r24, Z+28	; 0x1c
    4672:	48 2f       	mov	r20, r24
    4674:	50 e0       	ldi	r21, 0x00	; 0
    4676:	2b 81       	ldd	r18, Y+3	; 0x03
    4678:	3c 81       	ldd	r19, Y+4	; 0x04
    467a:	cb 01       	movw	r24, r22
    467c:	b9 01       	movw	r22, r18
    467e:	0e 94 81 2c 	call	0x5902	; 0x5902 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    4682:	e9 81       	ldd	r30, Y+1	; 0x01
    4684:	fa 81       	ldd	r31, Y+2	; 0x02
    4686:	26 81       	ldd	r18, Z+6	; 0x06
    4688:	37 81       	ldd	r19, Z+7	; 0x07
    468a:	e9 81       	ldd	r30, Y+1	; 0x01
    468c:	fa 81       	ldd	r31, Y+2	; 0x02
    468e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4690:	88 2f       	mov	r24, r24
    4692:	90 e0       	ldi	r25, 0x00	; 0
    4694:	90 95       	com	r25
    4696:	81 95       	neg	r24
    4698:	9f 4f       	sbci	r25, 0xFF	; 255
    469a:	82 0f       	add	r24, r18
    469c:	93 1f       	adc	r25, r19
    469e:	e9 81       	ldd	r30, Y+1	; 0x01
    46a0:	fa 81       	ldd	r31, Y+2	; 0x02
    46a2:	97 83       	std	Z+7, r25	; 0x07
    46a4:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    46a6:	e9 81       	ldd	r30, Y+1	; 0x01
    46a8:	fa 81       	ldd	r31, Y+2	; 0x02
    46aa:	26 81       	ldd	r18, Z+6	; 0x06
    46ac:	37 81       	ldd	r19, Z+7	; 0x07
    46ae:	e9 81       	ldd	r30, Y+1	; 0x01
    46b0:	fa 81       	ldd	r31, Y+2	; 0x02
    46b2:	80 81       	ld	r24, Z
    46b4:	91 81       	ldd	r25, Z+1	; 0x01
    46b6:	28 17       	cp	r18, r24
    46b8:	39 07       	cpc	r19, r25
    46ba:	90 f4       	brcc	.+36     	; 0x46e0 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    46bc:	e9 81       	ldd	r30, Y+1	; 0x01
    46be:	fa 81       	ldd	r31, Y+2	; 0x02
    46c0:	22 81       	ldd	r18, Z+2	; 0x02
    46c2:	33 81       	ldd	r19, Z+3	; 0x03
    46c4:	e9 81       	ldd	r30, Y+1	; 0x01
    46c6:	fa 81       	ldd	r31, Y+2	; 0x02
    46c8:	84 8d       	ldd	r24, Z+28	; 0x1c
    46ca:	88 2f       	mov	r24, r24
    46cc:	90 e0       	ldi	r25, 0x00	; 0
    46ce:	90 95       	com	r25
    46d0:	81 95       	neg	r24
    46d2:	9f 4f       	sbci	r25, 0xFF	; 255
    46d4:	82 0f       	add	r24, r18
    46d6:	93 1f       	adc	r25, r19
    46d8:	e9 81       	ldd	r30, Y+1	; 0x01
    46da:	fa 81       	ldd	r31, Y+2	; 0x02
    46dc:	97 83       	std	Z+7, r25	; 0x07
    46de:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    46e0:	e9 81       	ldd	r30, Y+1	; 0x01
    46e2:	fa 81       	ldd	r31, Y+2	; 0x02
    46e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    46e6:	8f 5f       	subi	r24, 0xFF	; 255
    46e8:	e9 81       	ldd	r30, Y+1	; 0x01
    46ea:	fa 81       	ldd	r31, Y+2	; 0x02
    46ec:	82 8f       	std	Z+26, r24	; 0x1a
}
    46ee:	0f 90       	pop	r0
    46f0:	0f 90       	pop	r0
    46f2:	0f 90       	pop	r0
    46f4:	0f 90       	pop	r0
    46f6:	0f 90       	pop	r0
    46f8:	cf 91       	pop	r28
    46fa:	df 91       	pop	r29
    46fc:	08 95       	ret

000046fe <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    46fe:	df 93       	push	r29
    4700:	cf 93       	push	r28
    4702:	00 d0       	rcall	.+0      	; 0x4704 <prvCopyDataFromQueue+0x6>
    4704:	00 d0       	rcall	.+0      	; 0x4706 <prvCopyDataFromQueue+0x8>
    4706:	cd b7       	in	r28, 0x3d	; 61
    4708:	de b7       	in	r29, 0x3e	; 62
    470a:	9a 83       	std	Y+2, r25	; 0x02
    470c:	89 83       	std	Y+1, r24	; 0x01
    470e:	7c 83       	std	Y+4, r23	; 0x04
    4710:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    4712:	e9 81       	ldd	r30, Y+1	; 0x01
    4714:	fa 81       	ldd	r31, Y+2	; 0x02
    4716:	80 81       	ld	r24, Z
    4718:	91 81       	ldd	r25, Z+1	; 0x01
    471a:	00 97       	sbiw	r24, 0x00	; 0
    471c:	89 f1       	breq	.+98     	; 0x4780 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    471e:	e9 81       	ldd	r30, Y+1	; 0x01
    4720:	fa 81       	ldd	r31, Y+2	; 0x02
    4722:	26 81       	ldd	r18, Z+6	; 0x06
    4724:	37 81       	ldd	r19, Z+7	; 0x07
    4726:	e9 81       	ldd	r30, Y+1	; 0x01
    4728:	fa 81       	ldd	r31, Y+2	; 0x02
    472a:	84 8d       	ldd	r24, Z+28	; 0x1c
    472c:	88 2f       	mov	r24, r24
    472e:	90 e0       	ldi	r25, 0x00	; 0
    4730:	82 0f       	add	r24, r18
    4732:	93 1f       	adc	r25, r19
    4734:	e9 81       	ldd	r30, Y+1	; 0x01
    4736:	fa 81       	ldd	r31, Y+2	; 0x02
    4738:	97 83       	std	Z+7, r25	; 0x07
    473a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    473c:	e9 81       	ldd	r30, Y+1	; 0x01
    473e:	fa 81       	ldd	r31, Y+2	; 0x02
    4740:	26 81       	ldd	r18, Z+6	; 0x06
    4742:	37 81       	ldd	r19, Z+7	; 0x07
    4744:	e9 81       	ldd	r30, Y+1	; 0x01
    4746:	fa 81       	ldd	r31, Y+2	; 0x02
    4748:	82 81       	ldd	r24, Z+2	; 0x02
    474a:	93 81       	ldd	r25, Z+3	; 0x03
    474c:	28 17       	cp	r18, r24
    474e:	39 07       	cpc	r19, r25
    4750:	40 f0       	brcs	.+16     	; 0x4762 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    4752:	e9 81       	ldd	r30, Y+1	; 0x01
    4754:	fa 81       	ldd	r31, Y+2	; 0x02
    4756:	80 81       	ld	r24, Z
    4758:	91 81       	ldd	r25, Z+1	; 0x01
    475a:	e9 81       	ldd	r30, Y+1	; 0x01
    475c:	fa 81       	ldd	r31, Y+2	; 0x02
    475e:	97 83       	std	Z+7, r25	; 0x07
    4760:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    4762:	e9 81       	ldd	r30, Y+1	; 0x01
    4764:	fa 81       	ldd	r31, Y+2	; 0x02
    4766:	46 81       	ldd	r20, Z+6	; 0x06
    4768:	57 81       	ldd	r21, Z+7	; 0x07
    476a:	e9 81       	ldd	r30, Y+1	; 0x01
    476c:	fa 81       	ldd	r31, Y+2	; 0x02
    476e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4770:	28 2f       	mov	r18, r24
    4772:	30 e0       	ldi	r19, 0x00	; 0
    4774:	8b 81       	ldd	r24, Y+3	; 0x03
    4776:	9c 81       	ldd	r25, Y+4	; 0x04
    4778:	ba 01       	movw	r22, r20
    477a:	a9 01       	movw	r20, r18
    477c:	0e 94 81 2c 	call	0x5902	; 0x5902 <memcpy>
	}
}
    4780:	0f 90       	pop	r0
    4782:	0f 90       	pop	r0
    4784:	0f 90       	pop	r0
    4786:	0f 90       	pop	r0
    4788:	cf 91       	pop	r28
    478a:	df 91       	pop	r29
    478c:	08 95       	ret

0000478e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    478e:	df 93       	push	r29
    4790:	cf 93       	push	r28
    4792:	00 d0       	rcall	.+0      	; 0x4794 <prvUnlockQueue+0x6>
    4794:	cd b7       	in	r28, 0x3d	; 61
    4796:	de b7       	in	r29, 0x3e	; 62
    4798:	9a 83       	std	Y+2, r25	; 0x02
    479a:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    479c:	0f b6       	in	r0, 0x3f	; 63
    479e:	f8 94       	cli
    47a0:	0f 92       	push	r0
    47a2:	15 c0       	rjmp	.+42     	; 0x47ce <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    47a4:	e9 81       	ldd	r30, Y+1	; 0x01
    47a6:	fa 81       	ldd	r31, Y+2	; 0x02
    47a8:	81 89       	ldd	r24, Z+17	; 0x11
    47aa:	88 23       	and	r24, r24
    47ac:	a9 f0       	breq	.+42     	; 0x47d8 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    47ae:	89 81       	ldd	r24, Y+1	; 0x01
    47b0:	9a 81       	ldd	r25, Y+2	; 0x02
    47b2:	41 96       	adiw	r24, 0x11	; 17
    47b4:	0e 94 ff 28 	call	0x51fe	; 0x51fe <xTaskRemoveFromEventList>
    47b8:	88 23       	and	r24, r24
    47ba:	11 f0       	breq	.+4      	; 0x47c0 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    47bc:	0e 94 dd 29 	call	0x53ba	; 0x53ba <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    47c0:	e9 81       	ldd	r30, Y+1	; 0x01
    47c2:	fa 81       	ldd	r31, Y+2	; 0x02
    47c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    47c6:	81 50       	subi	r24, 0x01	; 1
    47c8:	e9 81       	ldd	r30, Y+1	; 0x01
    47ca:	fa 81       	ldd	r31, Y+2	; 0x02
    47cc:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    47ce:	e9 81       	ldd	r30, Y+1	; 0x01
    47d0:	fa 81       	ldd	r31, Y+2	; 0x02
    47d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    47d4:	18 16       	cp	r1, r24
    47d6:	34 f3       	brlt	.-52     	; 0x47a4 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    47d8:	e9 81       	ldd	r30, Y+1	; 0x01
    47da:	fa 81       	ldd	r31, Y+2	; 0x02
    47dc:	8f ef       	ldi	r24, 0xFF	; 255
    47de:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    47e0:	0f 90       	pop	r0
    47e2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    47e4:	0f b6       	in	r0, 0x3f	; 63
    47e6:	f8 94       	cli
    47e8:	0f 92       	push	r0
    47ea:	15 c0       	rjmp	.+42     	; 0x4816 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    47ec:	e9 81       	ldd	r30, Y+1	; 0x01
    47ee:	fa 81       	ldd	r31, Y+2	; 0x02
    47f0:	80 85       	ldd	r24, Z+8	; 0x08
    47f2:	88 23       	and	r24, r24
    47f4:	a9 f0       	breq	.+42     	; 0x4820 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    47f6:	89 81       	ldd	r24, Y+1	; 0x01
    47f8:	9a 81       	ldd	r25, Y+2	; 0x02
    47fa:	08 96       	adiw	r24, 0x08	; 8
    47fc:	0e 94 ff 28 	call	0x51fe	; 0x51fe <xTaskRemoveFromEventList>
    4800:	88 23       	and	r24, r24
    4802:	11 f0       	breq	.+4      	; 0x4808 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    4804:	0e 94 dd 29 	call	0x53ba	; 0x53ba <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    4808:	e9 81       	ldd	r30, Y+1	; 0x01
    480a:	fa 81       	ldd	r31, Y+2	; 0x02
    480c:	85 8d       	ldd	r24, Z+29	; 0x1d
    480e:	81 50       	subi	r24, 0x01	; 1
    4810:	e9 81       	ldd	r30, Y+1	; 0x01
    4812:	fa 81       	ldd	r31, Y+2	; 0x02
    4814:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4816:	e9 81       	ldd	r30, Y+1	; 0x01
    4818:	fa 81       	ldd	r31, Y+2	; 0x02
    481a:	85 8d       	ldd	r24, Z+29	; 0x1d
    481c:	18 16       	cp	r1, r24
    481e:	34 f3       	brlt	.-52     	; 0x47ec <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4820:	e9 81       	ldd	r30, Y+1	; 0x01
    4822:	fa 81       	ldd	r31, Y+2	; 0x02
    4824:	8f ef       	ldi	r24, 0xFF	; 255
    4826:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4828:	0f 90       	pop	r0
    482a:	0f be       	out	0x3f, r0	; 63
}
    482c:	0f 90       	pop	r0
    482e:	0f 90       	pop	r0
    4830:	cf 91       	pop	r28
    4832:	df 91       	pop	r29
    4834:	08 95       	ret

00004836 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    4836:	df 93       	push	r29
    4838:	cf 93       	push	r28
    483a:	00 d0       	rcall	.+0      	; 0x483c <prvIsQueueEmpty+0x6>
    483c:	0f 92       	push	r0
    483e:	cd b7       	in	r28, 0x3d	; 61
    4840:	de b7       	in	r29, 0x3e	; 62
    4842:	9b 83       	std	Y+3, r25	; 0x03
    4844:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    4846:	0f b6       	in	r0, 0x3f	; 63
    4848:	f8 94       	cli
    484a:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    484c:	ea 81       	ldd	r30, Y+2	; 0x02
    484e:	fb 81       	ldd	r31, Y+3	; 0x03
    4850:	82 8d       	ldd	r24, Z+26	; 0x1a
    4852:	19 82       	std	Y+1, r1	; 0x01
    4854:	88 23       	and	r24, r24
    4856:	11 f4       	brne	.+4      	; 0x485c <prvIsQueueEmpty+0x26>
    4858:	81 e0       	ldi	r24, 0x01	; 1
    485a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    485c:	0f 90       	pop	r0
    485e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4860:	89 81       	ldd	r24, Y+1	; 0x01
}
    4862:	0f 90       	pop	r0
    4864:	0f 90       	pop	r0
    4866:	0f 90       	pop	r0
    4868:	cf 91       	pop	r28
    486a:	df 91       	pop	r29
    486c:	08 95       	ret

0000486e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    486e:	df 93       	push	r29
    4870:	cf 93       	push	r28
    4872:	00 d0       	rcall	.+0      	; 0x4874 <xQueueIsQueueEmptyFromISR+0x6>
    4874:	0f 92       	push	r0
    4876:	cd b7       	in	r28, 0x3d	; 61
    4878:	de b7       	in	r29, 0x3e	; 62
    487a:	9b 83       	std	Y+3, r25	; 0x03
    487c:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    487e:	ea 81       	ldd	r30, Y+2	; 0x02
    4880:	fb 81       	ldd	r31, Y+3	; 0x03
    4882:	82 8d       	ldd	r24, Z+26	; 0x1a
    4884:	19 82       	std	Y+1, r1	; 0x01
    4886:	88 23       	and	r24, r24
    4888:	11 f4       	brne	.+4      	; 0x488e <xQueueIsQueueEmptyFromISR+0x20>
    488a:	81 e0       	ldi	r24, 0x01	; 1
    488c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    488e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4890:	0f 90       	pop	r0
    4892:	0f 90       	pop	r0
    4894:	0f 90       	pop	r0
    4896:	cf 91       	pop	r28
    4898:	df 91       	pop	r29
    489a:	08 95       	ret

0000489c <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    489c:	df 93       	push	r29
    489e:	cf 93       	push	r28
    48a0:	00 d0       	rcall	.+0      	; 0x48a2 <prvIsQueueFull+0x6>
    48a2:	0f 92       	push	r0
    48a4:	cd b7       	in	r28, 0x3d	; 61
    48a6:	de b7       	in	r29, 0x3e	; 62
    48a8:	9b 83       	std	Y+3, r25	; 0x03
    48aa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    48ac:	0f b6       	in	r0, 0x3f	; 63
    48ae:	f8 94       	cli
    48b0:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    48b2:	ea 81       	ldd	r30, Y+2	; 0x02
    48b4:	fb 81       	ldd	r31, Y+3	; 0x03
    48b6:	92 8d       	ldd	r25, Z+26	; 0x1a
    48b8:	ea 81       	ldd	r30, Y+2	; 0x02
    48ba:	fb 81       	ldd	r31, Y+3	; 0x03
    48bc:	83 8d       	ldd	r24, Z+27	; 0x1b
    48be:	19 82       	std	Y+1, r1	; 0x01
    48c0:	98 17       	cp	r25, r24
    48c2:	11 f4       	brne	.+4      	; 0x48c8 <prvIsQueueFull+0x2c>
    48c4:	81 e0       	ldi	r24, 0x01	; 1
    48c6:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    48c8:	0f 90       	pop	r0
    48ca:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    48cc:	89 81       	ldd	r24, Y+1	; 0x01
}
    48ce:	0f 90       	pop	r0
    48d0:	0f 90       	pop	r0
    48d2:	0f 90       	pop	r0
    48d4:	cf 91       	pop	r28
    48d6:	df 91       	pop	r29
    48d8:	08 95       	ret

000048da <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    48da:	df 93       	push	r29
    48dc:	cf 93       	push	r28
    48de:	00 d0       	rcall	.+0      	; 0x48e0 <xQueueIsQueueFullFromISR+0x6>
    48e0:	0f 92       	push	r0
    48e2:	cd b7       	in	r28, 0x3d	; 61
    48e4:	de b7       	in	r29, 0x3e	; 62
    48e6:	9b 83       	std	Y+3, r25	; 0x03
    48e8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    48ea:	ea 81       	ldd	r30, Y+2	; 0x02
    48ec:	fb 81       	ldd	r31, Y+3	; 0x03
    48ee:	92 8d       	ldd	r25, Z+26	; 0x1a
    48f0:	ea 81       	ldd	r30, Y+2	; 0x02
    48f2:	fb 81       	ldd	r31, Y+3	; 0x03
    48f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    48f6:	19 82       	std	Y+1, r1	; 0x01
    48f8:	98 17       	cp	r25, r24
    48fa:	11 f4       	brne	.+4      	; 0x4900 <xQueueIsQueueFullFromISR+0x26>
    48fc:	81 e0       	ldi	r24, 0x01	; 1
    48fe:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    4900:	89 81       	ldd	r24, Y+1	; 0x01
}
    4902:	0f 90       	pop	r0
    4904:	0f 90       	pop	r0
    4906:	0f 90       	pop	r0
    4908:	cf 91       	pop	r28
    490a:	df 91       	pop	r29
    490c:	08 95       	ret

0000490e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    490e:	af 92       	push	r10
    4910:	bf 92       	push	r11
    4912:	cf 92       	push	r12
    4914:	df 92       	push	r13
    4916:	ef 92       	push	r14
    4918:	ff 92       	push	r15
    491a:	0f 93       	push	r16
    491c:	1f 93       	push	r17
    491e:	df 93       	push	r29
    4920:	cf 93       	push	r28
    4922:	cd b7       	in	r28, 0x3d	; 61
    4924:	de b7       	in	r29, 0x3e	; 62
    4926:	64 97       	sbiw	r28, 0x14	; 20
    4928:	0f b6       	in	r0, 0x3f	; 63
    492a:	f8 94       	cli
    492c:	de bf       	out	0x3e, r29	; 62
    492e:	0f be       	out	0x3f, r0	; 63
    4930:	cd bf       	out	0x3d, r28	; 61
    4932:	9f 83       	std	Y+7, r25	; 0x07
    4934:	8e 83       	std	Y+6, r24	; 0x06
    4936:	79 87       	std	Y+9, r23	; 0x09
    4938:	68 87       	std	Y+8, r22	; 0x08
    493a:	5b 87       	std	Y+11, r21	; 0x0b
    493c:	4a 87       	std	Y+10, r20	; 0x0a
    493e:	3d 87       	std	Y+13, r19	; 0x0d
    4940:	2c 87       	std	Y+12, r18	; 0x0c
    4942:	0e 87       	std	Y+14, r16	; 0x0e
    4944:	f8 8a       	std	Y+16, r15	; 0x10
    4946:	ef 86       	std	Y+15, r14	; 0x0f
    4948:	da 8a       	std	Y+18, r13	; 0x12
    494a:	c9 8a       	std	Y+17, r12	; 0x11
    494c:	bc 8a       	std	Y+20, r11	; 0x14
    494e:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    4950:	8a 85       	ldd	r24, Y+10	; 0x0a
    4952:	9b 85       	ldd	r25, Y+11	; 0x0b
    4954:	29 89       	ldd	r18, Y+17	; 0x11
    4956:	3a 89       	ldd	r19, Y+18	; 0x12
    4958:	b9 01       	movw	r22, r18
    495a:	0e 94 0c 2b 	call	0x5618	; 0x5618 <prvAllocateTCBAndStack>
    495e:	9c 83       	std	Y+4, r25	; 0x04
    4960:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    4962:	8b 81       	ldd	r24, Y+3	; 0x03
    4964:	9c 81       	ldd	r25, Y+4	; 0x04
    4966:	00 97       	sbiw	r24, 0x00	; 0
    4968:	09 f4       	brne	.+2      	; 0x496c <xTaskGenericCreate+0x5e>
    496a:	99 c0       	rjmp	.+306    	; 0x4a9e <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    496c:	eb 81       	ldd	r30, Y+3	; 0x03
    496e:	fc 81       	ldd	r31, Y+4	; 0x04
    4970:	27 89       	ldd	r18, Z+23	; 0x17
    4972:	30 8d       	ldd	r19, Z+24	; 0x18
    4974:	8a 85       	ldd	r24, Y+10	; 0x0a
    4976:	9b 85       	ldd	r25, Y+11	; 0x0b
    4978:	01 97       	sbiw	r24, 0x01	; 1
    497a:	82 0f       	add	r24, r18
    497c:	93 1f       	adc	r25, r19
    497e:	9a 83       	std	Y+2, r25	; 0x02
    4980:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    4982:	8b 81       	ldd	r24, Y+3	; 0x03
    4984:	9c 81       	ldd	r25, Y+4	; 0x04
    4986:	28 85       	ldd	r18, Y+8	; 0x08
    4988:	39 85       	ldd	r19, Y+9	; 0x09
    498a:	eb 89       	ldd	r30, Y+19	; 0x13
    498c:	fc 89       	ldd	r31, Y+20	; 0x14
    498e:	aa 85       	ldd	r26, Y+10	; 0x0a
    4990:	bb 85       	ldd	r27, Y+11	; 0x0b
    4992:	b9 01       	movw	r22, r18
    4994:	4e 85       	ldd	r20, Y+14	; 0x0e
    4996:	9f 01       	movw	r18, r30
    4998:	8d 01       	movw	r16, r26
    499a:	0e 94 f1 29 	call	0x53e2	; 0x53e2 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    499e:	89 81       	ldd	r24, Y+1	; 0x01
    49a0:	9a 81       	ldd	r25, Y+2	; 0x02
    49a2:	2e 81       	ldd	r18, Y+6	; 0x06
    49a4:	3f 81       	ldd	r19, Y+7	; 0x07
    49a6:	4c 85       	ldd	r20, Y+12	; 0x0c
    49a8:	5d 85       	ldd	r21, Y+13	; 0x0d
    49aa:	b9 01       	movw	r22, r18
    49ac:	0e 94 34 1d 	call	0x3a68	; 0x3a68 <pxPortInitialiseStack>
    49b0:	eb 81       	ldd	r30, Y+3	; 0x03
    49b2:	fc 81       	ldd	r31, Y+4	; 0x04
    49b4:	91 83       	std	Z+1, r25	; 0x01
    49b6:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    49b8:	8f 85       	ldd	r24, Y+15	; 0x0f
    49ba:	98 89       	ldd	r25, Y+16	; 0x10
    49bc:	00 97       	sbiw	r24, 0x00	; 0
    49be:	31 f0       	breq	.+12     	; 0x49cc <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    49c0:	ef 85       	ldd	r30, Y+15	; 0x0f
    49c2:	f8 89       	ldd	r31, Y+16	; 0x10
    49c4:	8b 81       	ldd	r24, Y+3	; 0x03
    49c6:	9c 81       	ldd	r25, Y+4	; 0x04
    49c8:	91 83       	std	Z+1, r25	; 0x01
    49ca:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    49cc:	0f b6       	in	r0, 0x3f	; 63
    49ce:	f8 94       	cli
    49d0:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    49d2:	80 91 3d 03 	lds	r24, 0x033D
    49d6:	8f 5f       	subi	r24, 0xFF	; 255
    49d8:	80 93 3d 03 	sts	0x033D, r24
			if( pxCurrentTCB == NULL )
    49dc:	80 91 3a 03 	lds	r24, 0x033A
    49e0:	90 91 3b 03 	lds	r25, 0x033B
    49e4:	00 97       	sbiw	r24, 0x00	; 0
    49e6:	69 f4       	brne	.+26     	; 0x4a02 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    49e8:	8b 81       	ldd	r24, Y+3	; 0x03
    49ea:	9c 81       	ldd	r25, Y+4	; 0x04
    49ec:	90 93 3b 03 	sts	0x033B, r25
    49f0:	80 93 3a 03 	sts	0x033A, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    49f4:	80 91 3d 03 	lds	r24, 0x033D
    49f8:	81 30       	cpi	r24, 0x01	; 1
    49fa:	a9 f4       	brne	.+42     	; 0x4a26 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    49fc:	0e 94 48 2a 	call	0x5490	; 0x5490 <prvInitialiseTaskLists>
    4a00:	12 c0       	rjmp	.+36     	; 0x4a26 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    4a02:	80 91 42 03 	lds	r24, 0x0342
    4a06:	88 23       	and	r24, r24
    4a08:	71 f4       	brne	.+28     	; 0x4a26 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4a0a:	e0 91 3a 03 	lds	r30, 0x033A
    4a0e:	f0 91 3b 03 	lds	r31, 0x033B
    4a12:	96 89       	ldd	r25, Z+22	; 0x16
    4a14:	8e 85       	ldd	r24, Y+14	; 0x0e
    4a16:	89 17       	cp	r24, r25
    4a18:	30 f0       	brcs	.+12     	; 0x4a26 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4a1a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a1c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a1e:	90 93 3b 03 	sts	0x033B, r25
    4a22:	80 93 3a 03 	sts	0x033A, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    4a26:	eb 81       	ldd	r30, Y+3	; 0x03
    4a28:	fc 81       	ldd	r31, Y+4	; 0x04
    4a2a:	96 89       	ldd	r25, Z+22	; 0x16
    4a2c:	80 91 40 03 	lds	r24, 0x0340
    4a30:	89 17       	cp	r24, r25
    4a32:	28 f4       	brcc	.+10     	; 0x4a3e <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    4a34:	eb 81       	ldd	r30, Y+3	; 0x03
    4a36:	fc 81       	ldd	r31, Y+4	; 0x04
    4a38:	86 89       	ldd	r24, Z+22	; 0x16
    4a3a:	80 93 40 03 	sts	0x0340, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    4a3e:	80 91 47 03 	lds	r24, 0x0347
    4a42:	8f 5f       	subi	r24, 0xFF	; 255
    4a44:	80 93 47 03 	sts	0x0347, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    4a48:	eb 81       	ldd	r30, Y+3	; 0x03
    4a4a:	fc 81       	ldd	r31, Y+4	; 0x04
    4a4c:	96 89       	ldd	r25, Z+22	; 0x16
    4a4e:	80 91 41 03 	lds	r24, 0x0341
    4a52:	89 17       	cp	r24, r25
    4a54:	28 f4       	brcc	.+10     	; 0x4a60 <xTaskGenericCreate+0x152>
    4a56:	eb 81       	ldd	r30, Y+3	; 0x03
    4a58:	fc 81       	ldd	r31, Y+4	; 0x04
    4a5a:	86 89       	ldd	r24, Z+22	; 0x16
    4a5c:	80 93 41 03 	sts	0x0341, r24
    4a60:	eb 81       	ldd	r30, Y+3	; 0x03
    4a62:	fc 81       	ldd	r31, Y+4	; 0x04
    4a64:	86 89       	ldd	r24, Z+22	; 0x16
    4a66:	28 2f       	mov	r18, r24
    4a68:	30 e0       	ldi	r19, 0x00	; 0
    4a6a:	c9 01       	movw	r24, r18
    4a6c:	88 0f       	add	r24, r24
    4a6e:	99 1f       	adc	r25, r25
    4a70:	88 0f       	add	r24, r24
    4a72:	99 1f       	adc	r25, r25
    4a74:	88 0f       	add	r24, r24
    4a76:	99 1f       	adc	r25, r25
    4a78:	82 0f       	add	r24, r18
    4a7a:	93 1f       	adc	r25, r19
    4a7c:	ac 01       	movw	r20, r24
    4a7e:	48 5b       	subi	r20, 0xB8	; 184
    4a80:	5c 4f       	sbci	r21, 0xFC	; 252
    4a82:	8b 81       	ldd	r24, Y+3	; 0x03
    4a84:	9c 81       	ldd	r25, Y+4	; 0x04
    4a86:	9c 01       	movw	r18, r24
    4a88:	2e 5f       	subi	r18, 0xFE	; 254
    4a8a:	3f 4f       	sbci	r19, 0xFF	; 255
    4a8c:	ca 01       	movw	r24, r20
    4a8e:	b9 01       	movw	r22, r18
    4a90:	0e 94 33 1c 	call	0x3866	; 0x3866 <vListInsertEnd>

			xReturn = pdPASS;
    4a94:	81 e0       	ldi	r24, 0x01	; 1
    4a96:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    4a98:	0f 90       	pop	r0
    4a9a:	0f be       	out	0x3f, r0	; 63
    4a9c:	02 c0       	rjmp	.+4      	; 0x4aa2 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4a9e:	8f ef       	ldi	r24, 0xFF	; 255
    4aa0:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    4aa2:	8d 81       	ldd	r24, Y+5	; 0x05
    4aa4:	81 30       	cpi	r24, 0x01	; 1
    4aa6:	71 f4       	brne	.+28     	; 0x4ac4 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    4aa8:	80 91 42 03 	lds	r24, 0x0342
    4aac:	88 23       	and	r24, r24
    4aae:	51 f0       	breq	.+20     	; 0x4ac4 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    4ab0:	e0 91 3a 03 	lds	r30, 0x033A
    4ab4:	f0 91 3b 03 	lds	r31, 0x033B
    4ab8:	96 89       	ldd	r25, Z+22	; 0x16
    4aba:	8e 85       	ldd	r24, Y+14	; 0x0e
    4abc:	98 17       	cp	r25, r24
    4abe:	10 f4       	brcc	.+4      	; 0x4ac4 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    4ac0:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <vPortYield>
			}
		}
	}

	return xReturn;
    4ac4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4ac6:	64 96       	adiw	r28, 0x14	; 20
    4ac8:	0f b6       	in	r0, 0x3f	; 63
    4aca:	f8 94       	cli
    4acc:	de bf       	out	0x3e, r29	; 62
    4ace:	0f be       	out	0x3f, r0	; 63
    4ad0:	cd bf       	out	0x3d, r28	; 61
    4ad2:	cf 91       	pop	r28
    4ad4:	df 91       	pop	r29
    4ad6:	1f 91       	pop	r17
    4ad8:	0f 91       	pop	r16
    4ada:	ff 90       	pop	r15
    4adc:	ef 90       	pop	r14
    4ade:	df 90       	pop	r13
    4ae0:	cf 90       	pop	r12
    4ae2:	bf 90       	pop	r11
    4ae4:	af 90       	pop	r10
    4ae6:	08 95       	ret

00004ae8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    4ae8:	df 93       	push	r29
    4aea:	cf 93       	push	r28
    4aec:	00 d0       	rcall	.+0      	; 0x4aee <vTaskDelete+0x6>
    4aee:	00 d0       	rcall	.+0      	; 0x4af0 <vTaskDelete+0x8>
    4af0:	00 d0       	rcall	.+0      	; 0x4af2 <vTaskDelete+0xa>
    4af2:	cd b7       	in	r28, 0x3d	; 61
    4af4:	de b7       	in	r29, 0x3e	; 62
    4af6:	9c 83       	std	Y+4, r25	; 0x04
    4af8:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    4afa:	0f b6       	in	r0, 0x3f	; 63
    4afc:	f8 94       	cli
    4afe:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    4b00:	20 91 3a 03 	lds	r18, 0x033A
    4b04:	30 91 3b 03 	lds	r19, 0x033B
    4b08:	8b 81       	ldd	r24, Y+3	; 0x03
    4b0a:	9c 81       	ldd	r25, Y+4	; 0x04
    4b0c:	82 17       	cp	r24, r18
    4b0e:	93 07       	cpc	r25, r19
    4b10:	11 f4       	brne	.+4      	; 0x4b16 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    4b12:	1c 82       	std	Y+4, r1	; 0x04
    4b14:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    4b16:	8b 81       	ldd	r24, Y+3	; 0x03
    4b18:	9c 81       	ldd	r25, Y+4	; 0x04
    4b1a:	00 97       	sbiw	r24, 0x00	; 0
    4b1c:	39 f4       	brne	.+14     	; 0x4b2c <vTaskDelete+0x44>
    4b1e:	80 91 3a 03 	lds	r24, 0x033A
    4b22:	90 91 3b 03 	lds	r25, 0x033B
    4b26:	9e 83       	std	Y+6, r25	; 0x06
    4b28:	8d 83       	std	Y+5, r24	; 0x05
    4b2a:	04 c0       	rjmp	.+8      	; 0x4b34 <vTaskDelete+0x4c>
    4b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4b30:	9e 83       	std	Y+6, r25	; 0x06
    4b32:	8d 83       	std	Y+5, r24	; 0x05
    4b34:	8d 81       	ldd	r24, Y+5	; 0x05
    4b36:	9e 81       	ldd	r25, Y+6	; 0x06
    4b38:	9a 83       	std	Y+2, r25	; 0x02
    4b3a:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    4b3c:	89 81       	ldd	r24, Y+1	; 0x01
    4b3e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b40:	02 96       	adiw	r24, 0x02	; 2
    4b42:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    4b46:	e9 81       	ldd	r30, Y+1	; 0x01
    4b48:	fa 81       	ldd	r31, Y+2	; 0x02
    4b4a:	84 89       	ldd	r24, Z+20	; 0x14
    4b4c:	95 89       	ldd	r25, Z+21	; 0x15
    4b4e:	00 97       	sbiw	r24, 0x00	; 0
    4b50:	29 f0       	breq	.+10     	; 0x4b5c <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    4b52:	89 81       	ldd	r24, Y+1	; 0x01
    4b54:	9a 81       	ldd	r25, Y+2	; 0x02
    4b56:	0c 96       	adiw	r24, 0x0c	; 12
    4b58:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4b5c:	89 81       	ldd	r24, Y+1	; 0x01
    4b5e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b60:	9c 01       	movw	r18, r24
    4b62:	2e 5f       	subi	r18, 0xFE	; 254
    4b64:	3f 4f       	sbci	r19, 0xFF	; 255
    4b66:	84 e9       	ldi	r24, 0x94	; 148
    4b68:	93 e0       	ldi	r25, 0x03	; 3
    4b6a:	b9 01       	movw	r22, r18
    4b6c:	0e 94 33 1c 	call	0x3866	; 0x3866 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    4b70:	80 91 3c 03 	lds	r24, 0x033C
    4b74:	8f 5f       	subi	r24, 0xFF	; 255
    4b76:	80 93 3c 03 	sts	0x033C, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    4b7a:	80 91 47 03 	lds	r24, 0x0347
    4b7e:	8f 5f       	subi	r24, 0xFF	; 255
    4b80:	80 93 47 03 	sts	0x0347, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    4b84:	0f 90       	pop	r0
    4b86:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    4b88:	80 91 42 03 	lds	r24, 0x0342
    4b8c:	88 23       	and	r24, r24
    4b8e:	31 f0       	breq	.+12     	; 0x4b9c <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    4b90:	8b 81       	ldd	r24, Y+3	; 0x03
    4b92:	9c 81       	ldd	r25, Y+4	; 0x04
    4b94:	00 97       	sbiw	r24, 0x00	; 0
    4b96:	11 f4       	brne	.+4      	; 0x4b9c <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    4b98:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <vPortYield>
			}
		}
	}
    4b9c:	26 96       	adiw	r28, 0x06	; 6
    4b9e:	0f b6       	in	r0, 0x3f	; 63
    4ba0:	f8 94       	cli
    4ba2:	de bf       	out	0x3e, r29	; 62
    4ba4:	0f be       	out	0x3f, r0	; 63
    4ba6:	cd bf       	out	0x3d, r28	; 61
    4ba8:	cf 91       	pop	r28
    4baa:	df 91       	pop	r29
    4bac:	08 95       	ret

00004bae <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    4bae:	df 93       	push	r29
    4bb0:	cf 93       	push	r28
    4bb2:	cd b7       	in	r28, 0x3d	; 61
    4bb4:	de b7       	in	r29, 0x3e	; 62
    4bb6:	28 97       	sbiw	r28, 0x08	; 8
    4bb8:	0f b6       	in	r0, 0x3f	; 63
    4bba:	f8 94       	cli
    4bbc:	de bf       	out	0x3e, r29	; 62
    4bbe:	0f be       	out	0x3f, r0	; 63
    4bc0:	cd bf       	out	0x3d, r28	; 61
    4bc2:	9e 83       	std	Y+6, r25	; 0x06
    4bc4:	8d 83       	std	Y+5, r24	; 0x05
    4bc6:	78 87       	std	Y+8, r23	; 0x08
    4bc8:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    4bca:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    4bcc:	0e 94 c3 26 	call	0x4d86	; 0x4d86 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4bd0:	ed 81       	ldd	r30, Y+5	; 0x05
    4bd2:	fe 81       	ldd	r31, Y+6	; 0x06
    4bd4:	20 81       	ld	r18, Z
    4bd6:	31 81       	ldd	r19, Z+1	; 0x01
    4bd8:	8f 81       	ldd	r24, Y+7	; 0x07
    4bda:	98 85       	ldd	r25, Y+8	; 0x08
    4bdc:	82 0f       	add	r24, r18
    4bde:	93 1f       	adc	r25, r19
    4be0:	9c 83       	std	Y+4, r25	; 0x04
    4be2:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    4be4:	ed 81       	ldd	r30, Y+5	; 0x05
    4be6:	fe 81       	ldd	r31, Y+6	; 0x06
    4be8:	20 81       	ld	r18, Z
    4bea:	31 81       	ldd	r19, Z+1	; 0x01
    4bec:	80 91 3e 03 	lds	r24, 0x033E
    4bf0:	90 91 3f 03 	lds	r25, 0x033F
    4bf4:	82 17       	cp	r24, r18
    4bf6:	93 07       	cpc	r25, r19
    4bf8:	a8 f4       	brcc	.+42     	; 0x4c24 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    4bfa:	ed 81       	ldd	r30, Y+5	; 0x05
    4bfc:	fe 81       	ldd	r31, Y+6	; 0x06
    4bfe:	20 81       	ld	r18, Z
    4c00:	31 81       	ldd	r19, Z+1	; 0x01
    4c02:	8b 81       	ldd	r24, Y+3	; 0x03
    4c04:	9c 81       	ldd	r25, Y+4	; 0x04
    4c06:	82 17       	cp	r24, r18
    4c08:	93 07       	cpc	r25, r19
    4c0a:	00 f5       	brcc	.+64     	; 0x4c4c <vTaskDelayUntil+0x9e>
    4c0c:	20 91 3e 03 	lds	r18, 0x033E
    4c10:	30 91 3f 03 	lds	r19, 0x033F
    4c14:	8b 81       	ldd	r24, Y+3	; 0x03
    4c16:	9c 81       	ldd	r25, Y+4	; 0x04
    4c18:	28 17       	cp	r18, r24
    4c1a:	39 07       	cpc	r19, r25
    4c1c:	b8 f4       	brcc	.+46     	; 0x4c4c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4c1e:	81 e0       	ldi	r24, 0x01	; 1
    4c20:	89 83       	std	Y+1, r24	; 0x01
    4c22:	14 c0       	rjmp	.+40     	; 0x4c4c <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    4c24:	ed 81       	ldd	r30, Y+5	; 0x05
    4c26:	fe 81       	ldd	r31, Y+6	; 0x06
    4c28:	20 81       	ld	r18, Z
    4c2a:	31 81       	ldd	r19, Z+1	; 0x01
    4c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4c30:	82 17       	cp	r24, r18
    4c32:	93 07       	cpc	r25, r19
    4c34:	48 f0       	brcs	.+18     	; 0x4c48 <vTaskDelayUntil+0x9a>
    4c36:	20 91 3e 03 	lds	r18, 0x033E
    4c3a:	30 91 3f 03 	lds	r19, 0x033F
    4c3e:	8b 81       	ldd	r24, Y+3	; 0x03
    4c40:	9c 81       	ldd	r25, Y+4	; 0x04
    4c42:	28 17       	cp	r18, r24
    4c44:	39 07       	cpc	r19, r25
    4c46:	10 f4       	brcc	.+4      	; 0x4c4c <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4c48:	81 e0       	ldi	r24, 0x01	; 1
    4c4a:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4c4c:	ed 81       	ldd	r30, Y+5	; 0x05
    4c4e:	fe 81       	ldd	r31, Y+6	; 0x06
    4c50:	8b 81       	ldd	r24, Y+3	; 0x03
    4c52:	9c 81       	ldd	r25, Y+4	; 0x04
    4c54:	91 83       	std	Z+1, r25	; 0x01
    4c56:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4c58:	89 81       	ldd	r24, Y+1	; 0x01
    4c5a:	88 23       	and	r24, r24
    4c5c:	59 f0       	breq	.+22     	; 0x4c74 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4c5e:	80 91 3a 03 	lds	r24, 0x033A
    4c62:	90 91 3b 03 	lds	r25, 0x033B
    4c66:	02 96       	adiw	r24, 0x02	; 2
    4c68:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    4c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    4c70:	0e 94 c3 2a 	call	0x5586	; 0x5586 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    4c74:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <xTaskResumeAll>
    4c78:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4c7a:	8a 81       	ldd	r24, Y+2	; 0x02
    4c7c:	88 23       	and	r24, r24
    4c7e:	11 f4       	brne	.+4      	; 0x4c84 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    4c80:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <vPortYield>
		}
	}
    4c84:	28 96       	adiw	r28, 0x08	; 8
    4c86:	0f b6       	in	r0, 0x3f	; 63
    4c88:	f8 94       	cli
    4c8a:	de bf       	out	0x3e, r29	; 62
    4c8c:	0f be       	out	0x3f, r0	; 63
    4c8e:	cd bf       	out	0x3d, r28	; 61
    4c90:	cf 91       	pop	r28
    4c92:	df 91       	pop	r29
    4c94:	08 95       	ret

00004c96 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    4c96:	df 93       	push	r29
    4c98:	cf 93       	push	r28
    4c9a:	00 d0       	rcall	.+0      	; 0x4c9c <vTaskDelay+0x6>
    4c9c:	00 d0       	rcall	.+0      	; 0x4c9e <vTaskDelay+0x8>
    4c9e:	0f 92       	push	r0
    4ca0:	cd b7       	in	r28, 0x3d	; 61
    4ca2:	de b7       	in	r29, 0x3e	; 62
    4ca4:	9d 83       	std	Y+5, r25	; 0x05
    4ca6:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4ca8:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    4caa:	8c 81       	ldd	r24, Y+4	; 0x04
    4cac:	9d 81       	ldd	r25, Y+5	; 0x05
    4cae:	00 97       	sbiw	r24, 0x00	; 0
    4cb0:	d1 f0       	breq	.+52     	; 0x4ce6 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    4cb2:	0e 94 c3 26 	call	0x4d86	; 0x4d86 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    4cb6:	20 91 3e 03 	lds	r18, 0x033E
    4cba:	30 91 3f 03 	lds	r19, 0x033F
    4cbe:	8c 81       	ldd	r24, Y+4	; 0x04
    4cc0:	9d 81       	ldd	r25, Y+5	; 0x05
    4cc2:	82 0f       	add	r24, r18
    4cc4:	93 1f       	adc	r25, r19
    4cc6:	9b 83       	std	Y+3, r25	; 0x03
    4cc8:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4cca:	80 91 3a 03 	lds	r24, 0x033A
    4cce:	90 91 3b 03 	lds	r25, 0x033B
    4cd2:	02 96       	adiw	r24, 0x02	; 2
    4cd4:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4cd8:	8a 81       	ldd	r24, Y+2	; 0x02
    4cda:	9b 81       	ldd	r25, Y+3	; 0x03
    4cdc:	0e 94 c3 2a 	call	0x5586	; 0x5586 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4ce0:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <xTaskResumeAll>
    4ce4:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4ce6:	89 81       	ldd	r24, Y+1	; 0x01
    4ce8:	88 23       	and	r24, r24
    4cea:	11 f4       	brne	.+4      	; 0x4cf0 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4cec:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <vPortYield>
		}
	}
    4cf0:	0f 90       	pop	r0
    4cf2:	0f 90       	pop	r0
    4cf4:	0f 90       	pop	r0
    4cf6:	0f 90       	pop	r0
    4cf8:	0f 90       	pop	r0
    4cfa:	cf 91       	pop	r28
    4cfc:	df 91       	pop	r29
    4cfe:	08 95       	ret

00004d00 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    4d00:	af 92       	push	r10
    4d02:	bf 92       	push	r11
    4d04:	cf 92       	push	r12
    4d06:	df 92       	push	r13
    4d08:	ef 92       	push	r14
    4d0a:	ff 92       	push	r15
    4d0c:	0f 93       	push	r16
    4d0e:	df 93       	push	r29
    4d10:	cf 93       	push	r28
    4d12:	0f 92       	push	r0
    4d14:	cd b7       	in	r28, 0x3d	; 61
    4d16:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    4d18:	23 e6       	ldi	r18, 0x63	; 99
    4d1a:	30 e0       	ldi	r19, 0x00	; 0
    4d1c:	87 ee       	ldi	r24, 0xE7	; 231
    4d1e:	99 e2       	ldi	r25, 0x29	; 41
    4d20:	b9 01       	movw	r22, r18
    4d22:	45 e5       	ldi	r20, 0x55	; 85
    4d24:	50 e0       	ldi	r21, 0x00	; 0
    4d26:	20 e0       	ldi	r18, 0x00	; 0
    4d28:	30 e0       	ldi	r19, 0x00	; 0
    4d2a:	00 e0       	ldi	r16, 0x00	; 0
    4d2c:	ee 24       	eor	r14, r14
    4d2e:	ff 24       	eor	r15, r15
    4d30:	cc 24       	eor	r12, r12
    4d32:	dd 24       	eor	r13, r13
    4d34:	aa 24       	eor	r10, r10
    4d36:	bb 24       	eor	r11, r11
    4d38:	0e 94 87 24 	call	0x490e	; 0x490e <xTaskGenericCreate>
    4d3c:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    4d3e:	89 81       	ldd	r24, Y+1	; 0x01
    4d40:	81 30       	cpi	r24, 0x01	; 1
    4d42:	51 f4       	brne	.+20     	; 0x4d58 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    4d44:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    4d46:	81 e0       	ldi	r24, 0x01	; 1
    4d48:	80 93 42 03 	sts	0x0342, r24
		xTickCount = ( portTickType ) 0U;
    4d4c:	10 92 3f 03 	sts	0x033F, r1
    4d50:	10 92 3e 03 	sts	0x033E, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4d54:	0e 94 b7 1e 	call	0x3d6e	; 0x3d6e <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    4d58:	0f 90       	pop	r0
    4d5a:	cf 91       	pop	r28
    4d5c:	df 91       	pop	r29
    4d5e:	0f 91       	pop	r16
    4d60:	ff 90       	pop	r15
    4d62:	ef 90       	pop	r14
    4d64:	df 90       	pop	r13
    4d66:	cf 90       	pop	r12
    4d68:	bf 90       	pop	r11
    4d6a:	af 90       	pop	r10
    4d6c:	08 95       	ret

00004d6e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    4d6e:	df 93       	push	r29
    4d70:	cf 93       	push	r28
    4d72:	cd b7       	in	r28, 0x3d	; 61
    4d74:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    4d76:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    4d78:	10 92 42 03 	sts	0x0342, r1
	vPortEndScheduler();
    4d7c:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <vPortEndScheduler>
}
    4d80:	cf 91       	pop	r28
    4d82:	df 91       	pop	r29
    4d84:	08 95       	ret

00004d86 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    4d86:	df 93       	push	r29
    4d88:	cf 93       	push	r28
    4d8a:	cd b7       	in	r28, 0x3d	; 61
    4d8c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    4d8e:	80 91 43 03 	lds	r24, 0x0343
    4d92:	8f 5f       	subi	r24, 0xFF	; 255
    4d94:	80 93 43 03 	sts	0x0343, r24
}
    4d98:	cf 91       	pop	r28
    4d9a:	df 91       	pop	r29
    4d9c:	08 95       	ret

00004d9e <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    4d9e:	df 93       	push	r29
    4da0:	cf 93       	push	r28
    4da2:	00 d0       	rcall	.+0      	; 0x4da4 <xTaskResumeAll+0x6>
    4da4:	00 d0       	rcall	.+0      	; 0x4da6 <xTaskResumeAll+0x8>
    4da6:	cd b7       	in	r28, 0x3d	; 61
    4da8:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4daa:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4dac:	0f b6       	in	r0, 0x3f	; 63
    4dae:	f8 94       	cli
    4db0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4db2:	80 91 43 03 	lds	r24, 0x0343
    4db6:	81 50       	subi	r24, 0x01	; 1
    4db8:	80 93 43 03 	sts	0x0343, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4dbc:	80 91 43 03 	lds	r24, 0x0343
    4dc0:	88 23       	and	r24, r24
    4dc2:	09 f0       	breq	.+2      	; 0x4dc6 <xTaskResumeAll+0x28>
    4dc4:	6c c0       	rjmp	.+216    	; 0x4e9e <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    4dc6:	80 91 3d 03 	lds	r24, 0x033D
    4dca:	88 23       	and	r24, r24
    4dcc:	09 f4       	brne	.+2      	; 0x4dd0 <xTaskResumeAll+0x32>
    4dce:	67 c0       	rjmp	.+206    	; 0x4e9e <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    4dd0:	19 82       	std	Y+1, r1	; 0x01
    4dd2:	41 c0       	rjmp	.+130    	; 0x4e56 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    4dd4:	e0 91 90 03 	lds	r30, 0x0390
    4dd8:	f0 91 91 03 	lds	r31, 0x0391
    4ddc:	86 81       	ldd	r24, Z+6	; 0x06
    4dde:	97 81       	ldd	r25, Z+7	; 0x07
    4de0:	9c 83       	std	Y+4, r25	; 0x04
    4de2:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    4de4:	8b 81       	ldd	r24, Y+3	; 0x03
    4de6:	9c 81       	ldd	r25, Y+4	; 0x04
    4de8:	0c 96       	adiw	r24, 0x0c	; 12
    4dea:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    4dee:	8b 81       	ldd	r24, Y+3	; 0x03
    4df0:	9c 81       	ldd	r25, Y+4	; 0x04
    4df2:	02 96       	adiw	r24, 0x02	; 2
    4df4:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    4df8:	eb 81       	ldd	r30, Y+3	; 0x03
    4dfa:	fc 81       	ldd	r31, Y+4	; 0x04
    4dfc:	96 89       	ldd	r25, Z+22	; 0x16
    4dfe:	80 91 41 03 	lds	r24, 0x0341
    4e02:	89 17       	cp	r24, r25
    4e04:	28 f4       	brcc	.+10     	; 0x4e10 <xTaskResumeAll+0x72>
    4e06:	eb 81       	ldd	r30, Y+3	; 0x03
    4e08:	fc 81       	ldd	r31, Y+4	; 0x04
    4e0a:	86 89       	ldd	r24, Z+22	; 0x16
    4e0c:	80 93 41 03 	sts	0x0341, r24
    4e10:	eb 81       	ldd	r30, Y+3	; 0x03
    4e12:	fc 81       	ldd	r31, Y+4	; 0x04
    4e14:	86 89       	ldd	r24, Z+22	; 0x16
    4e16:	28 2f       	mov	r18, r24
    4e18:	30 e0       	ldi	r19, 0x00	; 0
    4e1a:	c9 01       	movw	r24, r18
    4e1c:	88 0f       	add	r24, r24
    4e1e:	99 1f       	adc	r25, r25
    4e20:	88 0f       	add	r24, r24
    4e22:	99 1f       	adc	r25, r25
    4e24:	88 0f       	add	r24, r24
    4e26:	99 1f       	adc	r25, r25
    4e28:	82 0f       	add	r24, r18
    4e2a:	93 1f       	adc	r25, r19
    4e2c:	88 5b       	subi	r24, 0xB8	; 184
    4e2e:	9c 4f       	sbci	r25, 0xFC	; 252
    4e30:	2b 81       	ldd	r18, Y+3	; 0x03
    4e32:	3c 81       	ldd	r19, Y+4	; 0x04
    4e34:	2e 5f       	subi	r18, 0xFE	; 254
    4e36:	3f 4f       	sbci	r19, 0xFF	; 255
    4e38:	b9 01       	movw	r22, r18
    4e3a:	0e 94 33 1c 	call	0x3866	; 0x3866 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    4e40:	fc 81       	ldd	r31, Y+4	; 0x04
    4e42:	96 89       	ldd	r25, Z+22	; 0x16
    4e44:	e0 91 3a 03 	lds	r30, 0x033A
    4e48:	f0 91 3b 03 	lds	r31, 0x033B
    4e4c:	86 89       	ldd	r24, Z+22	; 0x16
    4e4e:	98 17       	cp	r25, r24
    4e50:	10 f0       	brcs	.+4      	; 0x4e56 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    4e52:	81 e0       	ldi	r24, 0x01	; 1
    4e54:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    4e56:	80 91 8b 03 	lds	r24, 0x038B
    4e5a:	88 23       	and	r24, r24
    4e5c:	09 f0       	breq	.+2      	; 0x4e60 <xTaskResumeAll+0xc2>
    4e5e:	ba cf       	rjmp	.-140    	; 0x4dd4 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4e60:	80 91 44 03 	lds	r24, 0x0344
    4e64:	88 23       	and	r24, r24
    4e66:	71 f0       	breq	.+28     	; 0x4e84 <xTaskResumeAll+0xe6>
    4e68:	07 c0       	rjmp	.+14     	; 0x4e78 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    4e6a:	0e 94 8e 27 	call	0x4f1c	; 0x4f1c <vTaskIncrementTick>
						--uxMissedTicks;
    4e6e:	80 91 44 03 	lds	r24, 0x0344
    4e72:	81 50       	subi	r24, 0x01	; 1
    4e74:	80 93 44 03 	sts	0x0344, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4e78:	80 91 44 03 	lds	r24, 0x0344
    4e7c:	88 23       	and	r24, r24
    4e7e:	a9 f7       	brne	.-22     	; 0x4e6a <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    4e80:	81 e0       	ldi	r24, 0x01	; 1
    4e82:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    4e84:	89 81       	ldd	r24, Y+1	; 0x01
    4e86:	81 30       	cpi	r24, 0x01	; 1
    4e88:	21 f0       	breq	.+8      	; 0x4e92 <xTaskResumeAll+0xf4>
    4e8a:	80 91 45 03 	lds	r24, 0x0345
    4e8e:	81 30       	cpi	r24, 0x01	; 1
    4e90:	31 f4       	brne	.+12     	; 0x4e9e <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    4e92:	81 e0       	ldi	r24, 0x01	; 1
    4e94:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    4e96:	10 92 45 03 	sts	0x0345, r1
					portYIELD_WITHIN_API();
    4e9a:	0e 94 f3 1e 	call	0x3de6	; 0x3de6 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    4e9e:	0f 90       	pop	r0
    4ea0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4ea2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4ea4:	0f 90       	pop	r0
    4ea6:	0f 90       	pop	r0
    4ea8:	0f 90       	pop	r0
    4eaa:	0f 90       	pop	r0
    4eac:	cf 91       	pop	r28
    4eae:	df 91       	pop	r29
    4eb0:	08 95       	ret

00004eb2 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    4eb2:	df 93       	push	r29
    4eb4:	cf 93       	push	r28
    4eb6:	00 d0       	rcall	.+0      	; 0x4eb8 <xTaskGetTickCount+0x6>
    4eb8:	cd b7       	in	r28, 0x3d	; 61
    4eba:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    4ebc:	0f b6       	in	r0, 0x3f	; 63
    4ebe:	f8 94       	cli
    4ec0:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4ec2:	80 91 3e 03 	lds	r24, 0x033E
    4ec6:	90 91 3f 03 	lds	r25, 0x033F
    4eca:	9a 83       	std	Y+2, r25	; 0x02
    4ecc:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4ece:	0f 90       	pop	r0
    4ed0:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4ed2:	89 81       	ldd	r24, Y+1	; 0x01
    4ed4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4ed6:	0f 90       	pop	r0
    4ed8:	0f 90       	pop	r0
    4eda:	cf 91       	pop	r28
    4edc:	df 91       	pop	r29
    4ede:	08 95       	ret

00004ee0 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    4ee0:	df 93       	push	r29
    4ee2:	cf 93       	push	r28
    4ee4:	00 d0       	rcall	.+0      	; 0x4ee6 <xTaskGetTickCountFromISR+0x6>
    4ee6:	0f 92       	push	r0
    4ee8:	cd b7       	in	r28, 0x3d	; 61
    4eea:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4eec:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    4eee:	80 91 3e 03 	lds	r24, 0x033E
    4ef2:	90 91 3f 03 	lds	r25, 0x033F
    4ef6:	9b 83       	std	Y+3, r25	; 0x03
    4ef8:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4efa:	8a 81       	ldd	r24, Y+2	; 0x02
    4efc:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4efe:	0f 90       	pop	r0
    4f00:	0f 90       	pop	r0
    4f02:	0f 90       	pop	r0
    4f04:	cf 91       	pop	r28
    4f06:	df 91       	pop	r29
    4f08:	08 95       	ret

00004f0a <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4f0a:	df 93       	push	r29
    4f0c:	cf 93       	push	r28
    4f0e:	cd b7       	in	r28, 0x3d	; 61
    4f10:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    4f12:	80 91 3d 03 	lds	r24, 0x033D
}
    4f16:	cf 91       	pop	r28
    4f18:	df 91       	pop	r29
    4f1a:	08 95       	ret

00004f1c <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4f1c:	df 93       	push	r29
    4f1e:	cf 93       	push	r28
    4f20:	00 d0       	rcall	.+0      	; 0x4f22 <vTaskIncrementTick+0x6>
    4f22:	00 d0       	rcall	.+0      	; 0x4f24 <vTaskIncrementTick+0x8>
    4f24:	00 d0       	rcall	.+0      	; 0x4f26 <vTaskIncrementTick+0xa>
    4f26:	cd b7       	in	r28, 0x3d	; 61
    4f28:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4f2a:	80 91 43 03 	lds	r24, 0x0343
    4f2e:	88 23       	and	r24, r24
    4f30:	09 f0       	breq	.+2      	; 0x4f34 <vTaskIncrementTick+0x18>
    4f32:	bb c0       	rjmp	.+374    	; 0x50aa <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    4f34:	80 91 3e 03 	lds	r24, 0x033E
    4f38:	90 91 3f 03 	lds	r25, 0x033F
    4f3c:	01 96       	adiw	r24, 0x01	; 1
    4f3e:	90 93 3f 03 	sts	0x033F, r25
    4f42:	80 93 3e 03 	sts	0x033E, r24
		if( xTickCount == ( portTickType ) 0U )
    4f46:	80 91 3e 03 	lds	r24, 0x033E
    4f4a:	90 91 3f 03 	lds	r25, 0x033F
    4f4e:	00 97       	sbiw	r24, 0x00	; 0
    4f50:	d1 f5       	brne	.+116    	; 0x4fc6 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    4f52:	80 91 87 03 	lds	r24, 0x0387
    4f56:	90 91 88 03 	lds	r25, 0x0388
    4f5a:	9c 83       	std	Y+4, r25	; 0x04
    4f5c:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    4f5e:	80 91 89 03 	lds	r24, 0x0389
    4f62:	90 91 8a 03 	lds	r25, 0x038A
    4f66:	90 93 88 03 	sts	0x0388, r25
    4f6a:	80 93 87 03 	sts	0x0387, r24
			pxOverflowDelayedTaskList = pxTemp;
    4f6e:	8b 81       	ldd	r24, Y+3	; 0x03
    4f70:	9c 81       	ldd	r25, Y+4	; 0x04
    4f72:	90 93 8a 03 	sts	0x038A, r25
    4f76:	80 93 89 03 	sts	0x0389, r24
			xNumOfOverflows++;
    4f7a:	80 91 46 03 	lds	r24, 0x0346
    4f7e:	8f 5f       	subi	r24, 0xFF	; 255
    4f80:	80 93 46 03 	sts	0x0346, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4f84:	e0 91 87 03 	lds	r30, 0x0387
    4f88:	f0 91 88 03 	lds	r31, 0x0388
    4f8c:	80 81       	ld	r24, Z
    4f8e:	88 23       	and	r24, r24
    4f90:	39 f4       	brne	.+14     	; 0x4fa0 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    4f92:	8f ef       	ldi	r24, 0xFF	; 255
    4f94:	9f ef       	ldi	r25, 0xFF	; 255
    4f96:	90 93 93 00 	sts	0x0093, r25
    4f9a:	80 93 92 00 	sts	0x0092, r24
    4f9e:	13 c0       	rjmp	.+38     	; 0x4fc6 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4fa0:	e0 91 87 03 	lds	r30, 0x0387
    4fa4:	f0 91 88 03 	lds	r31, 0x0388
    4fa8:	05 80       	ldd	r0, Z+5	; 0x05
    4faa:	f6 81       	ldd	r31, Z+6	; 0x06
    4fac:	e0 2d       	mov	r30, r0
    4fae:	86 81       	ldd	r24, Z+6	; 0x06
    4fb0:	97 81       	ldd	r25, Z+7	; 0x07
    4fb2:	9e 83       	std	Y+6, r25	; 0x06
    4fb4:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    4fb6:	ed 81       	ldd	r30, Y+5	; 0x05
    4fb8:	fe 81       	ldd	r31, Y+6	; 0x06
    4fba:	82 81       	ldd	r24, Z+2	; 0x02
    4fbc:	93 81       	ldd	r25, Z+3	; 0x03
    4fbe:	90 93 93 00 	sts	0x0093, r25
    4fc2:	80 93 92 00 	sts	0x0092, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    4fc6:	20 91 3e 03 	lds	r18, 0x033E
    4fca:	30 91 3f 03 	lds	r19, 0x033F
    4fce:	80 91 92 00 	lds	r24, 0x0092
    4fd2:	90 91 93 00 	lds	r25, 0x0093
    4fd6:	28 17       	cp	r18, r24
    4fd8:	39 07       	cpc	r19, r25
    4fda:	08 f4       	brcc	.+2      	; 0x4fde <vTaskIncrementTick+0xc2>
    4fdc:	6b c0       	rjmp	.+214    	; 0x50b4 <vTaskIncrementTick+0x198>
    4fde:	e0 91 87 03 	lds	r30, 0x0387
    4fe2:	f0 91 88 03 	lds	r31, 0x0388
    4fe6:	80 81       	ld	r24, Z
    4fe8:	88 23       	and	r24, r24
    4fea:	39 f4       	brne	.+14     	; 0x4ffa <vTaskIncrementTick+0xde>
    4fec:	8f ef       	ldi	r24, 0xFF	; 255
    4fee:	9f ef       	ldi	r25, 0xFF	; 255
    4ff0:	90 93 93 00 	sts	0x0093, r25
    4ff4:	80 93 92 00 	sts	0x0092, r24
    4ff8:	5d c0       	rjmp	.+186    	; 0x50b4 <vTaskIncrementTick+0x198>
    4ffa:	e0 91 87 03 	lds	r30, 0x0387
    4ffe:	f0 91 88 03 	lds	r31, 0x0388
    5002:	05 80       	ldd	r0, Z+5	; 0x05
    5004:	f6 81       	ldd	r31, Z+6	; 0x06
    5006:	e0 2d       	mov	r30, r0
    5008:	86 81       	ldd	r24, Z+6	; 0x06
    500a:	97 81       	ldd	r25, Z+7	; 0x07
    500c:	9e 83       	std	Y+6, r25	; 0x06
    500e:	8d 83       	std	Y+5, r24	; 0x05
    5010:	ed 81       	ldd	r30, Y+5	; 0x05
    5012:	fe 81       	ldd	r31, Y+6	; 0x06
    5014:	82 81       	ldd	r24, Z+2	; 0x02
    5016:	93 81       	ldd	r25, Z+3	; 0x03
    5018:	9a 83       	std	Y+2, r25	; 0x02
    501a:	89 83       	std	Y+1, r24	; 0x01
    501c:	20 91 3e 03 	lds	r18, 0x033E
    5020:	30 91 3f 03 	lds	r19, 0x033F
    5024:	89 81       	ldd	r24, Y+1	; 0x01
    5026:	9a 81       	ldd	r25, Y+2	; 0x02
    5028:	28 17       	cp	r18, r24
    502a:	39 07       	cpc	r19, r25
    502c:	38 f4       	brcc	.+14     	; 0x503c <vTaskIncrementTick+0x120>
    502e:	89 81       	ldd	r24, Y+1	; 0x01
    5030:	9a 81       	ldd	r25, Y+2	; 0x02
    5032:	90 93 93 00 	sts	0x0093, r25
    5036:	80 93 92 00 	sts	0x0092, r24
    503a:	3c c0       	rjmp	.+120    	; 0x50b4 <vTaskIncrementTick+0x198>
    503c:	8d 81       	ldd	r24, Y+5	; 0x05
    503e:	9e 81       	ldd	r25, Y+6	; 0x06
    5040:	02 96       	adiw	r24, 0x02	; 2
    5042:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
    5046:	ed 81       	ldd	r30, Y+5	; 0x05
    5048:	fe 81       	ldd	r31, Y+6	; 0x06
    504a:	84 89       	ldd	r24, Z+20	; 0x14
    504c:	95 89       	ldd	r25, Z+21	; 0x15
    504e:	00 97       	sbiw	r24, 0x00	; 0
    5050:	29 f0       	breq	.+10     	; 0x505c <vTaskIncrementTick+0x140>
    5052:	8d 81       	ldd	r24, Y+5	; 0x05
    5054:	9e 81       	ldd	r25, Y+6	; 0x06
    5056:	0c 96       	adiw	r24, 0x0c	; 12
    5058:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
    505c:	ed 81       	ldd	r30, Y+5	; 0x05
    505e:	fe 81       	ldd	r31, Y+6	; 0x06
    5060:	96 89       	ldd	r25, Z+22	; 0x16
    5062:	80 91 41 03 	lds	r24, 0x0341
    5066:	89 17       	cp	r24, r25
    5068:	28 f4       	brcc	.+10     	; 0x5074 <vTaskIncrementTick+0x158>
    506a:	ed 81       	ldd	r30, Y+5	; 0x05
    506c:	fe 81       	ldd	r31, Y+6	; 0x06
    506e:	86 89       	ldd	r24, Z+22	; 0x16
    5070:	80 93 41 03 	sts	0x0341, r24
    5074:	ed 81       	ldd	r30, Y+5	; 0x05
    5076:	fe 81       	ldd	r31, Y+6	; 0x06
    5078:	86 89       	ldd	r24, Z+22	; 0x16
    507a:	28 2f       	mov	r18, r24
    507c:	30 e0       	ldi	r19, 0x00	; 0
    507e:	c9 01       	movw	r24, r18
    5080:	88 0f       	add	r24, r24
    5082:	99 1f       	adc	r25, r25
    5084:	88 0f       	add	r24, r24
    5086:	99 1f       	adc	r25, r25
    5088:	88 0f       	add	r24, r24
    508a:	99 1f       	adc	r25, r25
    508c:	82 0f       	add	r24, r18
    508e:	93 1f       	adc	r25, r19
    5090:	ac 01       	movw	r20, r24
    5092:	48 5b       	subi	r20, 0xB8	; 184
    5094:	5c 4f       	sbci	r21, 0xFC	; 252
    5096:	8d 81       	ldd	r24, Y+5	; 0x05
    5098:	9e 81       	ldd	r25, Y+6	; 0x06
    509a:	9c 01       	movw	r18, r24
    509c:	2e 5f       	subi	r18, 0xFE	; 254
    509e:	3f 4f       	sbci	r19, 0xFF	; 255
    50a0:	ca 01       	movw	r24, r20
    50a2:	b9 01       	movw	r22, r18
    50a4:	0e 94 33 1c 	call	0x3866	; 0x3866 <vListInsertEnd>
    50a8:	9a cf       	rjmp	.-204    	; 0x4fde <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    50aa:	80 91 44 03 	lds	r24, 0x0344
    50ae:	8f 5f       	subi	r24, 0xFF	; 255
    50b0:	80 93 44 03 	sts	0x0344, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    50b4:	26 96       	adiw	r28, 0x06	; 6
    50b6:	0f b6       	in	r0, 0x3f	; 63
    50b8:	f8 94       	cli
    50ba:	de bf       	out	0x3e, r29	; 62
    50bc:	0f be       	out	0x3f, r0	; 63
    50be:	cd bf       	out	0x3d, r28	; 61
    50c0:	cf 91       	pop	r28
    50c2:	df 91       	pop	r29
    50c4:	08 95       	ret

000050c6 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    50c6:	df 93       	push	r29
    50c8:	cf 93       	push	r28
    50ca:	00 d0       	rcall	.+0      	; 0x50cc <vTaskSwitchContext+0x6>
    50cc:	cd b7       	in	r28, 0x3d	; 61
    50ce:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    50d0:	80 91 43 03 	lds	r24, 0x0343
    50d4:	88 23       	and	r24, r24
    50d6:	49 f0       	breq	.+18     	; 0x50ea <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    50d8:	81 e0       	ldi	r24, 0x01	; 1
    50da:	80 93 45 03 	sts	0x0345, r24
    50de:	54 c0       	rjmp	.+168    	; 0x5188 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    50e0:	80 91 41 03 	lds	r24, 0x0341
    50e4:	81 50       	subi	r24, 0x01	; 1
    50e6:	80 93 41 03 	sts	0x0341, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    50ea:	80 91 41 03 	lds	r24, 0x0341
    50ee:	28 2f       	mov	r18, r24
    50f0:	30 e0       	ldi	r19, 0x00	; 0
    50f2:	c9 01       	movw	r24, r18
    50f4:	88 0f       	add	r24, r24
    50f6:	99 1f       	adc	r25, r25
    50f8:	88 0f       	add	r24, r24
    50fa:	99 1f       	adc	r25, r25
    50fc:	88 0f       	add	r24, r24
    50fe:	99 1f       	adc	r25, r25
    5100:	82 0f       	add	r24, r18
    5102:	93 1f       	adc	r25, r19
    5104:	fc 01       	movw	r30, r24
    5106:	e8 5b       	subi	r30, 0xB8	; 184
    5108:	fc 4f       	sbci	r31, 0xFC	; 252
    510a:	80 81       	ld	r24, Z
    510c:	88 23       	and	r24, r24
    510e:	41 f3       	breq	.-48     	; 0x50e0 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    5110:	80 91 41 03 	lds	r24, 0x0341
    5114:	28 2f       	mov	r18, r24
    5116:	30 e0       	ldi	r19, 0x00	; 0
    5118:	c9 01       	movw	r24, r18
    511a:	88 0f       	add	r24, r24
    511c:	99 1f       	adc	r25, r25
    511e:	88 0f       	add	r24, r24
    5120:	99 1f       	adc	r25, r25
    5122:	88 0f       	add	r24, r24
    5124:	99 1f       	adc	r25, r25
    5126:	82 0f       	add	r24, r18
    5128:	93 1f       	adc	r25, r19
    512a:	88 5b       	subi	r24, 0xB8	; 184
    512c:	9c 4f       	sbci	r25, 0xFC	; 252
    512e:	9a 83       	std	Y+2, r25	; 0x02
    5130:	89 83       	std	Y+1, r24	; 0x01
    5132:	e9 81       	ldd	r30, Y+1	; 0x01
    5134:	fa 81       	ldd	r31, Y+2	; 0x02
    5136:	01 80       	ldd	r0, Z+1	; 0x01
    5138:	f2 81       	ldd	r31, Z+2	; 0x02
    513a:	e0 2d       	mov	r30, r0
    513c:	82 81       	ldd	r24, Z+2	; 0x02
    513e:	93 81       	ldd	r25, Z+3	; 0x03
    5140:	e9 81       	ldd	r30, Y+1	; 0x01
    5142:	fa 81       	ldd	r31, Y+2	; 0x02
    5144:	92 83       	std	Z+2, r25	; 0x02
    5146:	81 83       	std	Z+1, r24	; 0x01
    5148:	e9 81       	ldd	r30, Y+1	; 0x01
    514a:	fa 81       	ldd	r31, Y+2	; 0x02
    514c:	21 81       	ldd	r18, Z+1	; 0x01
    514e:	32 81       	ldd	r19, Z+2	; 0x02
    5150:	89 81       	ldd	r24, Y+1	; 0x01
    5152:	9a 81       	ldd	r25, Y+2	; 0x02
    5154:	03 96       	adiw	r24, 0x03	; 3
    5156:	28 17       	cp	r18, r24
    5158:	39 07       	cpc	r19, r25
    515a:	59 f4       	brne	.+22     	; 0x5172 <vTaskSwitchContext+0xac>
    515c:	e9 81       	ldd	r30, Y+1	; 0x01
    515e:	fa 81       	ldd	r31, Y+2	; 0x02
    5160:	01 80       	ldd	r0, Z+1	; 0x01
    5162:	f2 81       	ldd	r31, Z+2	; 0x02
    5164:	e0 2d       	mov	r30, r0
    5166:	82 81       	ldd	r24, Z+2	; 0x02
    5168:	93 81       	ldd	r25, Z+3	; 0x03
    516a:	e9 81       	ldd	r30, Y+1	; 0x01
    516c:	fa 81       	ldd	r31, Y+2	; 0x02
    516e:	92 83       	std	Z+2, r25	; 0x02
    5170:	81 83       	std	Z+1, r24	; 0x01
    5172:	e9 81       	ldd	r30, Y+1	; 0x01
    5174:	fa 81       	ldd	r31, Y+2	; 0x02
    5176:	01 80       	ldd	r0, Z+1	; 0x01
    5178:	f2 81       	ldd	r31, Z+2	; 0x02
    517a:	e0 2d       	mov	r30, r0
    517c:	86 81       	ldd	r24, Z+6	; 0x06
    517e:	97 81       	ldd	r25, Z+7	; 0x07
    5180:	90 93 3b 03 	sts	0x033B, r25
    5184:	80 93 3a 03 	sts	0x033A, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    5188:	0f 90       	pop	r0
    518a:	0f 90       	pop	r0
    518c:	cf 91       	pop	r28
    518e:	df 91       	pop	r29
    5190:	08 95       	ret

00005192 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    5192:	df 93       	push	r29
    5194:	cf 93       	push	r28
    5196:	00 d0       	rcall	.+0      	; 0x5198 <vTaskPlaceOnEventList+0x6>
    5198:	00 d0       	rcall	.+0      	; 0x519a <vTaskPlaceOnEventList+0x8>
    519a:	00 d0       	rcall	.+0      	; 0x519c <vTaskPlaceOnEventList+0xa>
    519c:	cd b7       	in	r28, 0x3d	; 61
    519e:	de b7       	in	r29, 0x3e	; 62
    51a0:	9c 83       	std	Y+4, r25	; 0x04
    51a2:	8b 83       	std	Y+3, r24	; 0x03
    51a4:	7e 83       	std	Y+6, r23	; 0x06
    51a6:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    51a8:	4b 81       	ldd	r20, Y+3	; 0x03
    51aa:	5c 81       	ldd	r21, Y+4	; 0x04
    51ac:	80 91 3a 03 	lds	r24, 0x033A
    51b0:	90 91 3b 03 	lds	r25, 0x033B
    51b4:	9c 01       	movw	r18, r24
    51b6:	24 5f       	subi	r18, 0xF4	; 244
    51b8:	3f 4f       	sbci	r19, 0xFF	; 255
    51ba:	ca 01       	movw	r24, r20
    51bc:	b9 01       	movw	r22, r18
    51be:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    51c2:	80 91 3a 03 	lds	r24, 0x033A
    51c6:	90 91 3b 03 	lds	r25, 0x033B
    51ca:	02 96       	adiw	r24, 0x02	; 2
    51cc:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    51d0:	20 91 3e 03 	lds	r18, 0x033E
    51d4:	30 91 3f 03 	lds	r19, 0x033F
    51d8:	8d 81       	ldd	r24, Y+5	; 0x05
    51da:	9e 81       	ldd	r25, Y+6	; 0x06
    51dc:	82 0f       	add	r24, r18
    51de:	93 1f       	adc	r25, r19
    51e0:	9a 83       	std	Y+2, r25	; 0x02
    51e2:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    51e4:	89 81       	ldd	r24, Y+1	; 0x01
    51e6:	9a 81       	ldd	r25, Y+2	; 0x02
    51e8:	0e 94 c3 2a 	call	0x5586	; 0x5586 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    51ec:	26 96       	adiw	r28, 0x06	; 6
    51ee:	0f b6       	in	r0, 0x3f	; 63
    51f0:	f8 94       	cli
    51f2:	de bf       	out	0x3e, r29	; 62
    51f4:	0f be       	out	0x3f, r0	; 63
    51f6:	cd bf       	out	0x3d, r28	; 61
    51f8:	cf 91       	pop	r28
    51fa:	df 91       	pop	r29
    51fc:	08 95       	ret

000051fe <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    51fe:	df 93       	push	r29
    5200:	cf 93       	push	r28
    5202:	00 d0       	rcall	.+0      	; 0x5204 <xTaskRemoveFromEventList+0x6>
    5204:	00 d0       	rcall	.+0      	; 0x5206 <xTaskRemoveFromEventList+0x8>
    5206:	0f 92       	push	r0
    5208:	cd b7       	in	r28, 0x3d	; 61
    520a:	de b7       	in	r29, 0x3e	; 62
    520c:	9d 83       	std	Y+5, r25	; 0x05
    520e:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    5210:	ec 81       	ldd	r30, Y+4	; 0x04
    5212:	fd 81       	ldd	r31, Y+5	; 0x05
    5214:	05 80       	ldd	r0, Z+5	; 0x05
    5216:	f6 81       	ldd	r31, Z+6	; 0x06
    5218:	e0 2d       	mov	r30, r0
    521a:	86 81       	ldd	r24, Z+6	; 0x06
    521c:	97 81       	ldd	r25, Z+7	; 0x07
    521e:	9b 83       	std	Y+3, r25	; 0x03
    5220:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5222:	8a 81       	ldd	r24, Y+2	; 0x02
    5224:	9b 81       	ldd	r25, Y+3	; 0x03
    5226:	0c 96       	adiw	r24, 0x0c	; 12
    5228:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    522c:	80 91 43 03 	lds	r24, 0x0343
    5230:	88 23       	and	r24, r24
    5232:	61 f5       	brne	.+88     	; 0x528c <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    5234:	8a 81       	ldd	r24, Y+2	; 0x02
    5236:	9b 81       	ldd	r25, Y+3	; 0x03
    5238:	02 96       	adiw	r24, 0x02	; 2
    523a:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    523e:	ea 81       	ldd	r30, Y+2	; 0x02
    5240:	fb 81       	ldd	r31, Y+3	; 0x03
    5242:	96 89       	ldd	r25, Z+22	; 0x16
    5244:	80 91 41 03 	lds	r24, 0x0341
    5248:	89 17       	cp	r24, r25
    524a:	28 f4       	brcc	.+10     	; 0x5256 <xTaskRemoveFromEventList+0x58>
    524c:	ea 81       	ldd	r30, Y+2	; 0x02
    524e:	fb 81       	ldd	r31, Y+3	; 0x03
    5250:	86 89       	ldd	r24, Z+22	; 0x16
    5252:	80 93 41 03 	sts	0x0341, r24
    5256:	ea 81       	ldd	r30, Y+2	; 0x02
    5258:	fb 81       	ldd	r31, Y+3	; 0x03
    525a:	86 89       	ldd	r24, Z+22	; 0x16
    525c:	28 2f       	mov	r18, r24
    525e:	30 e0       	ldi	r19, 0x00	; 0
    5260:	c9 01       	movw	r24, r18
    5262:	88 0f       	add	r24, r24
    5264:	99 1f       	adc	r25, r25
    5266:	88 0f       	add	r24, r24
    5268:	99 1f       	adc	r25, r25
    526a:	88 0f       	add	r24, r24
    526c:	99 1f       	adc	r25, r25
    526e:	82 0f       	add	r24, r18
    5270:	93 1f       	adc	r25, r19
    5272:	ac 01       	movw	r20, r24
    5274:	48 5b       	subi	r20, 0xB8	; 184
    5276:	5c 4f       	sbci	r21, 0xFC	; 252
    5278:	8a 81       	ldd	r24, Y+2	; 0x02
    527a:	9b 81       	ldd	r25, Y+3	; 0x03
    527c:	9c 01       	movw	r18, r24
    527e:	2e 5f       	subi	r18, 0xFE	; 254
    5280:	3f 4f       	sbci	r19, 0xFF	; 255
    5282:	ca 01       	movw	r24, r20
    5284:	b9 01       	movw	r22, r18
    5286:	0e 94 33 1c 	call	0x3866	; 0x3866 <vListInsertEnd>
    528a:	0a c0       	rjmp	.+20     	; 0x52a0 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    528c:	8a 81       	ldd	r24, Y+2	; 0x02
    528e:	9b 81       	ldd	r25, Y+3	; 0x03
    5290:	9c 01       	movw	r18, r24
    5292:	24 5f       	subi	r18, 0xF4	; 244
    5294:	3f 4f       	sbci	r19, 0xFF	; 255
    5296:	8b e8       	ldi	r24, 0x8B	; 139
    5298:	93 e0       	ldi	r25, 0x03	; 3
    529a:	b9 01       	movw	r22, r18
    529c:	0e 94 33 1c 	call	0x3866	; 0x3866 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    52a0:	ea 81       	ldd	r30, Y+2	; 0x02
    52a2:	fb 81       	ldd	r31, Y+3	; 0x03
    52a4:	96 89       	ldd	r25, Z+22	; 0x16
    52a6:	e0 91 3a 03 	lds	r30, 0x033A
    52aa:	f0 91 3b 03 	lds	r31, 0x033B
    52ae:	86 89       	ldd	r24, Z+22	; 0x16
    52b0:	98 17       	cp	r25, r24
    52b2:	18 f0       	brcs	.+6      	; 0x52ba <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    52b4:	81 e0       	ldi	r24, 0x01	; 1
    52b6:	89 83       	std	Y+1, r24	; 0x01
    52b8:	01 c0       	rjmp	.+2      	; 0x52bc <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    52ba:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    52bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    52be:	0f 90       	pop	r0
    52c0:	0f 90       	pop	r0
    52c2:	0f 90       	pop	r0
    52c4:	0f 90       	pop	r0
    52c6:	0f 90       	pop	r0
    52c8:	cf 91       	pop	r28
    52ca:	df 91       	pop	r29
    52cc:	08 95       	ret

000052ce <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    52ce:	df 93       	push	r29
    52d0:	cf 93       	push	r28
    52d2:	00 d0       	rcall	.+0      	; 0x52d4 <vTaskSetTimeOutState+0x6>
    52d4:	cd b7       	in	r28, 0x3d	; 61
    52d6:	de b7       	in	r29, 0x3e	; 62
    52d8:	9a 83       	std	Y+2, r25	; 0x02
    52da:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    52dc:	80 91 46 03 	lds	r24, 0x0346
    52e0:	e9 81       	ldd	r30, Y+1	; 0x01
    52e2:	fa 81       	ldd	r31, Y+2	; 0x02
    52e4:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    52e6:	80 91 3e 03 	lds	r24, 0x033E
    52ea:	90 91 3f 03 	lds	r25, 0x033F
    52ee:	e9 81       	ldd	r30, Y+1	; 0x01
    52f0:	fa 81       	ldd	r31, Y+2	; 0x02
    52f2:	92 83       	std	Z+2, r25	; 0x02
    52f4:	81 83       	std	Z+1, r24	; 0x01
}
    52f6:	0f 90       	pop	r0
    52f8:	0f 90       	pop	r0
    52fa:	cf 91       	pop	r28
    52fc:	df 91       	pop	r29
    52fe:	08 95       	ret

00005300 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    5300:	df 93       	push	r29
    5302:	cf 93       	push	r28
    5304:	00 d0       	rcall	.+0      	; 0x5306 <xTaskCheckForTimeOut+0x6>
    5306:	00 d0       	rcall	.+0      	; 0x5308 <xTaskCheckForTimeOut+0x8>
    5308:	0f 92       	push	r0
    530a:	cd b7       	in	r28, 0x3d	; 61
    530c:	de b7       	in	r29, 0x3e	; 62
    530e:	9b 83       	std	Y+3, r25	; 0x03
    5310:	8a 83       	std	Y+2, r24	; 0x02
    5312:	7d 83       	std	Y+5, r23	; 0x05
    5314:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5316:	0f b6       	in	r0, 0x3f	; 63
    5318:	f8 94       	cli
    531a:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    531c:	ea 81       	ldd	r30, Y+2	; 0x02
    531e:	fb 81       	ldd	r31, Y+3	; 0x03
    5320:	90 81       	ld	r25, Z
    5322:	80 91 46 03 	lds	r24, 0x0346
    5326:	98 17       	cp	r25, r24
    5328:	71 f0       	breq	.+28     	; 0x5346 <xTaskCheckForTimeOut+0x46>
    532a:	ea 81       	ldd	r30, Y+2	; 0x02
    532c:	fb 81       	ldd	r31, Y+3	; 0x03
    532e:	21 81       	ldd	r18, Z+1	; 0x01
    5330:	32 81       	ldd	r19, Z+2	; 0x02
    5332:	80 91 3e 03 	lds	r24, 0x033E
    5336:	90 91 3f 03 	lds	r25, 0x033F
    533a:	82 17       	cp	r24, r18
    533c:	93 07       	cpc	r25, r19
    533e:	18 f0       	brcs	.+6      	; 0x5346 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    5340:	81 e0       	ldi	r24, 0x01	; 1
    5342:	89 83       	std	Y+1, r24	; 0x01
    5344:	2f c0       	rjmp	.+94     	; 0x53a4 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    5346:	20 91 3e 03 	lds	r18, 0x033E
    534a:	30 91 3f 03 	lds	r19, 0x033F
    534e:	ea 81       	ldd	r30, Y+2	; 0x02
    5350:	fb 81       	ldd	r31, Y+3	; 0x03
    5352:	81 81       	ldd	r24, Z+1	; 0x01
    5354:	92 81       	ldd	r25, Z+2	; 0x02
    5356:	28 1b       	sub	r18, r24
    5358:	39 0b       	sbc	r19, r25
    535a:	ec 81       	ldd	r30, Y+4	; 0x04
    535c:	fd 81       	ldd	r31, Y+5	; 0x05
    535e:	80 81       	ld	r24, Z
    5360:	91 81       	ldd	r25, Z+1	; 0x01
    5362:	28 17       	cp	r18, r24
    5364:	39 07       	cpc	r19, r25
    5366:	e0 f4       	brcc	.+56     	; 0x53a0 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    5368:	ec 81       	ldd	r30, Y+4	; 0x04
    536a:	fd 81       	ldd	r31, Y+5	; 0x05
    536c:	40 81       	ld	r20, Z
    536e:	51 81       	ldd	r21, Z+1	; 0x01
    5370:	ea 81       	ldd	r30, Y+2	; 0x02
    5372:	fb 81       	ldd	r31, Y+3	; 0x03
    5374:	21 81       	ldd	r18, Z+1	; 0x01
    5376:	32 81       	ldd	r19, Z+2	; 0x02
    5378:	80 91 3e 03 	lds	r24, 0x033E
    537c:	90 91 3f 03 	lds	r25, 0x033F
    5380:	b9 01       	movw	r22, r18
    5382:	68 1b       	sub	r22, r24
    5384:	79 0b       	sbc	r23, r25
    5386:	cb 01       	movw	r24, r22
    5388:	84 0f       	add	r24, r20
    538a:	95 1f       	adc	r25, r21
    538c:	ec 81       	ldd	r30, Y+4	; 0x04
    538e:	fd 81       	ldd	r31, Y+5	; 0x05
    5390:	91 83       	std	Z+1, r25	; 0x01
    5392:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    5394:	8a 81       	ldd	r24, Y+2	; 0x02
    5396:	9b 81       	ldd	r25, Y+3	; 0x03
    5398:	0e 94 67 29 	call	0x52ce	; 0x52ce <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    539c:	19 82       	std	Y+1, r1	; 0x01
    539e:	02 c0       	rjmp	.+4      	; 0x53a4 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    53a0:	81 e0       	ldi	r24, 0x01	; 1
    53a2:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    53a4:	0f 90       	pop	r0
    53a6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    53a8:	89 81       	ldd	r24, Y+1	; 0x01
}
    53aa:	0f 90       	pop	r0
    53ac:	0f 90       	pop	r0
    53ae:	0f 90       	pop	r0
    53b0:	0f 90       	pop	r0
    53b2:	0f 90       	pop	r0
    53b4:	cf 91       	pop	r28
    53b6:	df 91       	pop	r29
    53b8:	08 95       	ret

000053ba <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    53ba:	df 93       	push	r29
    53bc:	cf 93       	push	r28
    53be:	cd b7       	in	r28, 0x3d	; 61
    53c0:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    53c2:	81 e0       	ldi	r24, 0x01	; 1
    53c4:	80 93 45 03 	sts	0x0345, r24
}
    53c8:	cf 91       	pop	r28
    53ca:	df 91       	pop	r29
    53cc:	08 95       	ret

000053ce <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    53ce:	df 93       	push	r29
    53d0:	cf 93       	push	r28
    53d2:	00 d0       	rcall	.+0      	; 0x53d4 <prvIdleTask+0x6>
    53d4:	cd b7       	in	r28, 0x3d	; 61
    53d6:	de b7       	in	r29, 0x3e	; 62
    53d8:	9a 83       	std	Y+2, r25	; 0x02
    53da:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    53dc:	0e 94 85 2a 	call	0x550a	; 0x550a <prvCheckTasksWaitingTermination>
    53e0:	fd cf       	rjmp	.-6      	; 0x53dc <prvIdleTask+0xe>

000053e2 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    53e2:	0f 93       	push	r16
    53e4:	1f 93       	push	r17
    53e6:	df 93       	push	r29
    53e8:	cf 93       	push	r28
    53ea:	cd b7       	in	r28, 0x3d	; 61
    53ec:	de b7       	in	r29, 0x3e	; 62
    53ee:	29 97       	sbiw	r28, 0x09	; 9
    53f0:	0f b6       	in	r0, 0x3f	; 63
    53f2:	f8 94       	cli
    53f4:	de bf       	out	0x3e, r29	; 62
    53f6:	0f be       	out	0x3f, r0	; 63
    53f8:	cd bf       	out	0x3d, r28	; 61
    53fa:	9a 83       	std	Y+2, r25	; 0x02
    53fc:	89 83       	std	Y+1, r24	; 0x01
    53fe:	7c 83       	std	Y+4, r23	; 0x04
    5400:	6b 83       	std	Y+3, r22	; 0x03
    5402:	4d 83       	std	Y+5, r20	; 0x05
    5404:	3f 83       	std	Y+7, r19	; 0x07
    5406:	2e 83       	std	Y+6, r18	; 0x06
    5408:	19 87       	std	Y+9, r17	; 0x09
    540a:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    540c:	89 81       	ldd	r24, Y+1	; 0x01
    540e:	9a 81       	ldd	r25, Y+2	; 0x02
    5410:	49 96       	adiw	r24, 0x19	; 25
    5412:	2b 81       	ldd	r18, Y+3	; 0x03
    5414:	3c 81       	ldd	r19, Y+4	; 0x04
    5416:	b9 01       	movw	r22, r18
    5418:	48 e0       	ldi	r20, 0x08	; 8
    541a:	50 e0       	ldi	r21, 0x00	; 0
    541c:	0e 94 91 2c 	call	0x5922	; 0x5922 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    5420:	e9 81       	ldd	r30, Y+1	; 0x01
    5422:	fa 81       	ldd	r31, Y+2	; 0x02
    5424:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    5426:	8d 81       	ldd	r24, Y+5	; 0x05
    5428:	85 30       	cpi	r24, 0x05	; 5
    542a:	10 f0       	brcs	.+4      	; 0x5430 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    542c:	84 e0       	ldi	r24, 0x04	; 4
    542e:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    5430:	e9 81       	ldd	r30, Y+1	; 0x01
    5432:	fa 81       	ldd	r31, Y+2	; 0x02
    5434:	8d 81       	ldd	r24, Y+5	; 0x05
    5436:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    5438:	89 81       	ldd	r24, Y+1	; 0x01
    543a:	9a 81       	ldd	r25, Y+2	; 0x02
    543c:	02 96       	adiw	r24, 0x02	; 2
    543e:	0e 94 23 1c 	call	0x3846	; 0x3846 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    5442:	89 81       	ldd	r24, Y+1	; 0x01
    5444:	9a 81       	ldd	r25, Y+2	; 0x02
    5446:	0c 96       	adiw	r24, 0x0c	; 12
    5448:	0e 94 23 1c 	call	0x3846	; 0x3846 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    544c:	e9 81       	ldd	r30, Y+1	; 0x01
    544e:	fa 81       	ldd	r31, Y+2	; 0x02
    5450:	89 81       	ldd	r24, Y+1	; 0x01
    5452:	9a 81       	ldd	r25, Y+2	; 0x02
    5454:	91 87       	std	Z+9, r25	; 0x09
    5456:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    5458:	8d 81       	ldd	r24, Y+5	; 0x05
    545a:	28 2f       	mov	r18, r24
    545c:	30 e0       	ldi	r19, 0x00	; 0
    545e:	85 e0       	ldi	r24, 0x05	; 5
    5460:	90 e0       	ldi	r25, 0x00	; 0
    5462:	82 1b       	sub	r24, r18
    5464:	93 0b       	sbc	r25, r19
    5466:	e9 81       	ldd	r30, Y+1	; 0x01
    5468:	fa 81       	ldd	r31, Y+2	; 0x02
    546a:	95 87       	std	Z+13, r25	; 0x0d
    546c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    546e:	e9 81       	ldd	r30, Y+1	; 0x01
    5470:	fa 81       	ldd	r31, Y+2	; 0x02
    5472:	89 81       	ldd	r24, Y+1	; 0x01
    5474:	9a 81       	ldd	r25, Y+2	; 0x02
    5476:	93 8b       	std	Z+19, r25	; 0x13
    5478:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    547a:	29 96       	adiw	r28, 0x09	; 9
    547c:	0f b6       	in	r0, 0x3f	; 63
    547e:	f8 94       	cli
    5480:	de bf       	out	0x3e, r29	; 62
    5482:	0f be       	out	0x3f, r0	; 63
    5484:	cd bf       	out	0x3d, r28	; 61
    5486:	cf 91       	pop	r28
    5488:	df 91       	pop	r29
    548a:	1f 91       	pop	r17
    548c:	0f 91       	pop	r16
    548e:	08 95       	ret

00005490 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    5490:	df 93       	push	r29
    5492:	cf 93       	push	r28
    5494:	0f 92       	push	r0
    5496:	cd b7       	in	r28, 0x3d	; 61
    5498:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    549a:	19 82       	std	Y+1, r1	; 0x01
    549c:	13 c0       	rjmp	.+38     	; 0x54c4 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    549e:	89 81       	ldd	r24, Y+1	; 0x01
    54a0:	28 2f       	mov	r18, r24
    54a2:	30 e0       	ldi	r19, 0x00	; 0
    54a4:	c9 01       	movw	r24, r18
    54a6:	88 0f       	add	r24, r24
    54a8:	99 1f       	adc	r25, r25
    54aa:	88 0f       	add	r24, r24
    54ac:	99 1f       	adc	r25, r25
    54ae:	88 0f       	add	r24, r24
    54b0:	99 1f       	adc	r25, r25
    54b2:	82 0f       	add	r24, r18
    54b4:	93 1f       	adc	r25, r19
    54b6:	88 5b       	subi	r24, 0xB8	; 184
    54b8:	9c 4f       	sbci	r25, 0xFC	; 252
    54ba:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    54be:	89 81       	ldd	r24, Y+1	; 0x01
    54c0:	8f 5f       	subi	r24, 0xFF	; 255
    54c2:	89 83       	std	Y+1, r24	; 0x01
    54c4:	89 81       	ldd	r24, Y+1	; 0x01
    54c6:	85 30       	cpi	r24, 0x05	; 5
    54c8:	50 f3       	brcs	.-44     	; 0x549e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    54ca:	85 e7       	ldi	r24, 0x75	; 117
    54cc:	93 e0       	ldi	r25, 0x03	; 3
    54ce:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    54d2:	8e e7       	ldi	r24, 0x7E	; 126
    54d4:	93 e0       	ldi	r25, 0x03	; 3
    54d6:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    54da:	8b e8       	ldi	r24, 0x8B	; 139
    54dc:	93 e0       	ldi	r25, 0x03	; 3
    54de:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    54e2:	84 e9       	ldi	r24, 0x94	; 148
    54e4:	93 e0       	ldi	r25, 0x03	; 3
    54e6:	0e 94 f9 1b 	call	0x37f2	; 0x37f2 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    54ea:	85 e7       	ldi	r24, 0x75	; 117
    54ec:	93 e0       	ldi	r25, 0x03	; 3
    54ee:	90 93 88 03 	sts	0x0388, r25
    54f2:	80 93 87 03 	sts	0x0387, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    54f6:	8e e7       	ldi	r24, 0x7E	; 126
    54f8:	93 e0       	ldi	r25, 0x03	; 3
    54fa:	90 93 8a 03 	sts	0x038A, r25
    54fe:	80 93 89 03 	sts	0x0389, r24
}
    5502:	0f 90       	pop	r0
    5504:	cf 91       	pop	r28
    5506:	df 91       	pop	r29
    5508:	08 95       	ret

0000550a <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    550a:	df 93       	push	r29
    550c:	cf 93       	push	r28
    550e:	00 d0       	rcall	.+0      	; 0x5510 <prvCheckTasksWaitingTermination+0x6>
    5510:	0f 92       	push	r0
    5512:	cd b7       	in	r28, 0x3d	; 61
    5514:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    5516:	80 91 3c 03 	lds	r24, 0x033C
    551a:	88 23       	and	r24, r24
    551c:	71 f1       	breq	.+92     	; 0x557a <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    551e:	0e 94 c3 26 	call	0x4d86	; 0x4d86 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    5522:	80 91 94 03 	lds	r24, 0x0394
    5526:	1b 82       	std	Y+3, r1	; 0x03
    5528:	88 23       	and	r24, r24
    552a:	11 f4       	brne	.+4      	; 0x5530 <prvCheckTasksWaitingTermination+0x26>
    552c:	81 e0       	ldi	r24, 0x01	; 1
    552e:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    5530:	0e 94 cf 26 	call	0x4d9e	; 0x4d9e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    5534:	8b 81       	ldd	r24, Y+3	; 0x03
    5536:	88 23       	and	r24, r24
    5538:	01 f5       	brne	.+64     	; 0x557a <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    553a:	0f b6       	in	r0, 0x3f	; 63
    553c:	f8 94       	cli
    553e:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    5540:	e0 91 99 03 	lds	r30, 0x0399
    5544:	f0 91 9a 03 	lds	r31, 0x039A
    5548:	86 81       	ldd	r24, Z+6	; 0x06
    554a:	97 81       	ldd	r25, Z+7	; 0x07
    554c:	9a 83       	std	Y+2, r25	; 0x02
    554e:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    5550:	89 81       	ldd	r24, Y+1	; 0x01
    5552:	9a 81       	ldd	r25, Y+2	; 0x02
    5554:	02 96       	adiw	r24, 0x02	; 2
    5556:	0e 94 eb 1c 	call	0x39d6	; 0x39d6 <vListRemove>
					--uxCurrentNumberOfTasks;
    555a:	80 91 3d 03 	lds	r24, 0x033D
    555e:	81 50       	subi	r24, 0x01	; 1
    5560:	80 93 3d 03 	sts	0x033D, r24
					--uxTasksDeleted;
    5564:	80 91 3c 03 	lds	r24, 0x033C
    5568:	81 50       	subi	r24, 0x01	; 1
    556a:	80 93 3c 03 	sts	0x033C, r24
				}
				taskEXIT_CRITICAL();
    556e:	0f 90       	pop	r0
    5570:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    5572:	89 81       	ldd	r24, Y+1	; 0x01
    5574:	9a 81       	ldd	r25, Y+2	; 0x02
    5576:	0e 94 5c 2b 	call	0x56b8	; 0x56b8 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    557a:	0f 90       	pop	r0
    557c:	0f 90       	pop	r0
    557e:	0f 90       	pop	r0
    5580:	cf 91       	pop	r28
    5582:	df 91       	pop	r29
    5584:	08 95       	ret

00005586 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    5586:	df 93       	push	r29
    5588:	cf 93       	push	r28
    558a:	00 d0       	rcall	.+0      	; 0x558c <prvAddCurrentTaskToDelayedList+0x6>
    558c:	cd b7       	in	r28, 0x3d	; 61
    558e:	de b7       	in	r29, 0x3e	; 62
    5590:	9a 83       	std	Y+2, r25	; 0x02
    5592:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    5594:	e0 91 3a 03 	lds	r30, 0x033A
    5598:	f0 91 3b 03 	lds	r31, 0x033B
    559c:	89 81       	ldd	r24, Y+1	; 0x01
    559e:	9a 81       	ldd	r25, Y+2	; 0x02
    55a0:	93 83       	std	Z+3, r25	; 0x03
    55a2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    55a4:	20 91 3e 03 	lds	r18, 0x033E
    55a8:	30 91 3f 03 	lds	r19, 0x033F
    55ac:	89 81       	ldd	r24, Y+1	; 0x01
    55ae:	9a 81       	ldd	r25, Y+2	; 0x02
    55b0:	82 17       	cp	r24, r18
    55b2:	93 07       	cpc	r25, r19
    55b4:	70 f4       	brcc	.+28     	; 0x55d2 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    55b6:	80 91 89 03 	lds	r24, 0x0389
    55ba:	90 91 8a 03 	lds	r25, 0x038A
    55be:	20 91 3a 03 	lds	r18, 0x033A
    55c2:	30 91 3b 03 	lds	r19, 0x033B
    55c6:	2e 5f       	subi	r18, 0xFE	; 254
    55c8:	3f 4f       	sbci	r19, 0xFF	; 255
    55ca:	b9 01       	movw	r22, r18
    55cc:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <vListInsert>
    55d0:	1e c0       	rjmp	.+60     	; 0x560e <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    55d2:	40 91 87 03 	lds	r20, 0x0387
    55d6:	50 91 88 03 	lds	r21, 0x0388
    55da:	80 91 3a 03 	lds	r24, 0x033A
    55de:	90 91 3b 03 	lds	r25, 0x033B
    55e2:	9c 01       	movw	r18, r24
    55e4:	2e 5f       	subi	r18, 0xFE	; 254
    55e6:	3f 4f       	sbci	r19, 0xFF	; 255
    55e8:	ca 01       	movw	r24, r20
    55ea:	b9 01       	movw	r22, r18
    55ec:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    55f0:	20 91 92 00 	lds	r18, 0x0092
    55f4:	30 91 93 00 	lds	r19, 0x0093
    55f8:	89 81       	ldd	r24, Y+1	; 0x01
    55fa:	9a 81       	ldd	r25, Y+2	; 0x02
    55fc:	82 17       	cp	r24, r18
    55fe:	93 07       	cpc	r25, r19
    5600:	30 f4       	brcc	.+12     	; 0x560e <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    5602:	89 81       	ldd	r24, Y+1	; 0x01
    5604:	9a 81       	ldd	r25, Y+2	; 0x02
    5606:	90 93 93 00 	sts	0x0093, r25
    560a:	80 93 92 00 	sts	0x0092, r24
		}
	}
}
    560e:	0f 90       	pop	r0
    5610:	0f 90       	pop	r0
    5612:	cf 91       	pop	r28
    5614:	df 91       	pop	r29
    5616:	08 95       	ret

00005618 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    5618:	df 93       	push	r29
    561a:	cf 93       	push	r28
    561c:	cd b7       	in	r28, 0x3d	; 61
    561e:	de b7       	in	r29, 0x3e	; 62
    5620:	28 97       	sbiw	r28, 0x08	; 8
    5622:	0f b6       	in	r0, 0x3f	; 63
    5624:	f8 94       	cli
    5626:	de bf       	out	0x3e, r29	; 62
    5628:	0f be       	out	0x3f, r0	; 63
    562a:	cd bf       	out	0x3d, r28	; 61
    562c:	9c 83       	std	Y+4, r25	; 0x04
    562e:	8b 83       	std	Y+3, r24	; 0x03
    5630:	7e 83       	std	Y+6, r23	; 0x06
    5632:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    5634:	81 e2       	ldi	r24, 0x21	; 33
    5636:	90 e0       	ldi	r25, 0x00	; 0
    5638:	0e 94 8d 1b 	call	0x371a	; 0x371a <pvPortMalloc>
    563c:	9a 83       	std	Y+2, r25	; 0x02
    563e:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    5640:	89 81       	ldd	r24, Y+1	; 0x01
    5642:	9a 81       	ldd	r25, Y+2	; 0x02
    5644:	00 97       	sbiw	r24, 0x00	; 0
    5646:	69 f1       	breq	.+90     	; 0x56a2 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    5648:	8d 81       	ldd	r24, Y+5	; 0x05
    564a:	9e 81       	ldd	r25, Y+6	; 0x06
    564c:	00 97       	sbiw	r24, 0x00	; 0
    564e:	39 f4       	brne	.+14     	; 0x565e <prvAllocateTCBAndStack+0x46>
    5650:	8b 81       	ldd	r24, Y+3	; 0x03
    5652:	9c 81       	ldd	r25, Y+4	; 0x04
    5654:	0e 94 8d 1b 	call	0x371a	; 0x371a <pvPortMalloc>
    5658:	98 87       	std	Y+8, r25	; 0x08
    565a:	8f 83       	std	Y+7, r24	; 0x07
    565c:	04 c0       	rjmp	.+8      	; 0x5666 <prvAllocateTCBAndStack+0x4e>
    565e:	8d 81       	ldd	r24, Y+5	; 0x05
    5660:	9e 81       	ldd	r25, Y+6	; 0x06
    5662:	98 87       	std	Y+8, r25	; 0x08
    5664:	8f 83       	std	Y+7, r24	; 0x07
    5666:	e9 81       	ldd	r30, Y+1	; 0x01
    5668:	fa 81       	ldd	r31, Y+2	; 0x02
    566a:	8f 81       	ldd	r24, Y+7	; 0x07
    566c:	98 85       	ldd	r25, Y+8	; 0x08
    566e:	90 8f       	std	Z+24, r25	; 0x18
    5670:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    5672:	e9 81       	ldd	r30, Y+1	; 0x01
    5674:	fa 81       	ldd	r31, Y+2	; 0x02
    5676:	87 89       	ldd	r24, Z+23	; 0x17
    5678:	90 8d       	ldd	r25, Z+24	; 0x18
    567a:	00 97       	sbiw	r24, 0x00	; 0
    567c:	39 f4       	brne	.+14     	; 0x568c <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    567e:	89 81       	ldd	r24, Y+1	; 0x01
    5680:	9a 81       	ldd	r25, Y+2	; 0x02
    5682:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <vPortFree>
			pxNewTCB = NULL;
    5686:	1a 82       	std	Y+2, r1	; 0x02
    5688:	19 82       	std	Y+1, r1	; 0x01
    568a:	0b c0       	rjmp	.+22     	; 0x56a2 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    568c:	e9 81       	ldd	r30, Y+1	; 0x01
    568e:	fa 81       	ldd	r31, Y+2	; 0x02
    5690:	87 89       	ldd	r24, Z+23	; 0x17
    5692:	90 8d       	ldd	r25, Z+24	; 0x18
    5694:	2b 81       	ldd	r18, Y+3	; 0x03
    5696:	3c 81       	ldd	r19, Y+4	; 0x04
    5698:	65 ea       	ldi	r22, 0xA5	; 165
    569a:	70 e0       	ldi	r23, 0x00	; 0
    569c:	a9 01       	movw	r20, r18
    569e:	0e 94 8a 2c 	call	0x5914	; 0x5914 <memset>
		}
	}

	return pxNewTCB;
    56a2:	89 81       	ldd	r24, Y+1	; 0x01
    56a4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    56a6:	28 96       	adiw	r28, 0x08	; 8
    56a8:	0f b6       	in	r0, 0x3f	; 63
    56aa:	f8 94       	cli
    56ac:	de bf       	out	0x3e, r29	; 62
    56ae:	0f be       	out	0x3f, r0	; 63
    56b0:	cd bf       	out	0x3d, r28	; 61
    56b2:	cf 91       	pop	r28
    56b4:	df 91       	pop	r29
    56b6:	08 95       	ret

000056b8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    56b8:	df 93       	push	r29
    56ba:	cf 93       	push	r28
    56bc:	00 d0       	rcall	.+0      	; 0x56be <prvDeleteTCB+0x6>
    56be:	cd b7       	in	r28, 0x3d	; 61
    56c0:	de b7       	in	r29, 0x3e	; 62
    56c2:	9a 83       	std	Y+2, r25	; 0x02
    56c4:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    56c6:	e9 81       	ldd	r30, Y+1	; 0x01
    56c8:	fa 81       	ldd	r31, Y+2	; 0x02
    56ca:	87 89       	ldd	r24, Z+23	; 0x17
    56cc:	90 8d       	ldd	r25, Z+24	; 0x18
    56ce:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <vPortFree>
		vPortFree( pxTCB );
    56d2:	89 81       	ldd	r24, Y+1	; 0x01
    56d4:	9a 81       	ldd	r25, Y+2	; 0x02
    56d6:	0e 94 d3 1b 	call	0x37a6	; 0x37a6 <vPortFree>
	}
    56da:	0f 90       	pop	r0
    56dc:	0f 90       	pop	r0
    56de:	cf 91       	pop	r28
    56e0:	df 91       	pop	r29
    56e2:	08 95       	ret

000056e4 <main>:
void task2(void *pvparameters);
void task3(void *pvparameters);
void task4(void *pvparameters);

int main(void)
{
    56e4:	af 92       	push	r10
    56e6:	bf 92       	push	r11
    56e8:	cf 92       	push	r12
    56ea:	df 92       	push	r13
    56ec:	ef 92       	push	r14
    56ee:	ff 92       	push	r15
    56f0:	0f 93       	push	r16
    56f2:	df 93       	push	r29
    56f4:	cf 93       	push	r28
    56f6:	cd b7       	in	r28, 0x3d	; 61
    56f8:	de b7       	in	r29, 0x3e	; 62
		DIO_VidSetPinDirection(PORT_A,PIN_0,DIO_OUT);
    56fa:	80 e0       	ldi	r24, 0x00	; 0
    56fc:	60 e0       	ldi	r22, 0x00	; 0
    56fe:	41 e0       	ldi	r20, 0x01	; 1
    5700:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>
		DIO_VidSetPinDirection(PORT_A,PIN_1,DIO_OUT);
    5704:	80 e0       	ldi	r24, 0x00	; 0
    5706:	61 e0       	ldi	r22, 0x01	; 1
    5708:	41 e0       	ldi	r20, 0x01	; 1
    570a:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>
		DIO_VidSetPinDirection(PORT_A,PIN_2,DIO_OUT);
    570e:	80 e0       	ldi	r24, 0x00	; 0
    5710:	62 e0       	ldi	r22, 0x02	; 2
    5712:	41 e0       	ldi	r20, 0x01	; 1
    5714:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>
		DIO_VidSetPinDirection(PORT_A,PIN_3,DIO_OUT);
    5718:	80 e0       	ldi	r24, 0x00	; 0
    571a:	63 e0       	ldi	r22, 0x03	; 3
    571c:	41 e0       	ldi	r20, 0x01	; 1
    571e:	0e 94 c3 09 	call	0x1386	; 0x1386 <DIO_VidSetPinDirection>

		xTaskCreate(task1,NULL,configMINIMAL_STACK_SIZE,NULL,1,NULL);
    5722:	83 ee       	ldi	r24, 0xE3	; 227
    5724:	9b e2       	ldi	r25, 0x2B	; 43
    5726:	60 e0       	ldi	r22, 0x00	; 0
    5728:	70 e0       	ldi	r23, 0x00	; 0
    572a:	45 e5       	ldi	r20, 0x55	; 85
    572c:	50 e0       	ldi	r21, 0x00	; 0
    572e:	20 e0       	ldi	r18, 0x00	; 0
    5730:	30 e0       	ldi	r19, 0x00	; 0
    5732:	01 e0       	ldi	r16, 0x01	; 1
    5734:	ee 24       	eor	r14, r14
    5736:	ff 24       	eor	r15, r15
    5738:	cc 24       	eor	r12, r12
    573a:	dd 24       	eor	r13, r13
    573c:	aa 24       	eor	r10, r10
    573e:	bb 24       	eor	r11, r11
    5740:	0e 94 87 24 	call	0x490e	; 0x490e <xTaskGenericCreate>
		xTaskCreate(task2,NULL,configMINIMAL_STACK_SIZE,NULL,1,NULL);
    5744:	83 ef       	ldi	r24, 0xF3	; 243
    5746:	9b e2       	ldi	r25, 0x2B	; 43
    5748:	60 e0       	ldi	r22, 0x00	; 0
    574a:	70 e0       	ldi	r23, 0x00	; 0
    574c:	45 e5       	ldi	r20, 0x55	; 85
    574e:	50 e0       	ldi	r21, 0x00	; 0
    5750:	20 e0       	ldi	r18, 0x00	; 0
    5752:	30 e0       	ldi	r19, 0x00	; 0
    5754:	01 e0       	ldi	r16, 0x01	; 1
    5756:	ee 24       	eor	r14, r14
    5758:	ff 24       	eor	r15, r15
    575a:	cc 24       	eor	r12, r12
    575c:	dd 24       	eor	r13, r13
    575e:	aa 24       	eor	r10, r10
    5760:	bb 24       	eor	r11, r11
    5762:	0e 94 87 24 	call	0x490e	; 0x490e <xTaskGenericCreate>
		xTaskCreate(task3,NULL,configMINIMAL_STACK_SIZE,NULL,1,NULL);
    5766:	83 e0       	ldi	r24, 0x03	; 3
    5768:	9c e2       	ldi	r25, 0x2C	; 44
    576a:	60 e0       	ldi	r22, 0x00	; 0
    576c:	70 e0       	ldi	r23, 0x00	; 0
    576e:	45 e5       	ldi	r20, 0x55	; 85
    5770:	50 e0       	ldi	r21, 0x00	; 0
    5772:	20 e0       	ldi	r18, 0x00	; 0
    5774:	30 e0       	ldi	r19, 0x00	; 0
    5776:	01 e0       	ldi	r16, 0x01	; 1
    5778:	ee 24       	eor	r14, r14
    577a:	ff 24       	eor	r15, r15
    577c:	cc 24       	eor	r12, r12
    577e:	dd 24       	eor	r13, r13
    5780:	aa 24       	eor	r10, r10
    5782:	bb 24       	eor	r11, r11
    5784:	0e 94 87 24 	call	0x490e	; 0x490e <xTaskGenericCreate>
		xTaskCreate(task4,NULL,configMINIMAL_STACK_SIZE,NULL,1,NULL);
    5788:	83 e1       	ldi	r24, 0x13	; 19
    578a:	9c e2       	ldi	r25, 0x2C	; 44
    578c:	60 e0       	ldi	r22, 0x00	; 0
    578e:	70 e0       	ldi	r23, 0x00	; 0
    5790:	45 e5       	ldi	r20, 0x55	; 85
    5792:	50 e0       	ldi	r21, 0x00	; 0
    5794:	20 e0       	ldi	r18, 0x00	; 0
    5796:	30 e0       	ldi	r19, 0x00	; 0
    5798:	01 e0       	ldi	r16, 0x01	; 1
    579a:	ee 24       	eor	r14, r14
    579c:	ff 24       	eor	r15, r15
    579e:	cc 24       	eor	r12, r12
    57a0:	dd 24       	eor	r13, r13
    57a2:	aa 24       	eor	r10, r10
    57a4:	bb 24       	eor	r11, r11
    57a6:	0e 94 87 24 	call	0x490e	; 0x490e <xTaskGenericCreate>
		vTaskStartScheduler();
    57aa:	0e 94 80 26 	call	0x4d00	; 0x4d00 <vTaskStartScheduler>



return 0;
    57ae:	80 e0       	ldi	r24, 0x00	; 0
    57b0:	90 e0       	ldi	r25, 0x00	; 0
}
    57b2:	cf 91       	pop	r28
    57b4:	df 91       	pop	r29
    57b6:	0f 91       	pop	r16
    57b8:	ff 90       	pop	r15
    57ba:	ef 90       	pop	r14
    57bc:	df 90       	pop	r13
    57be:	cf 90       	pop	r12
    57c0:	bf 90       	pop	r11
    57c2:	af 90       	pop	r10
    57c4:	08 95       	ret

000057c6 <task1>:

void task1(void *pvparameters)
{
    57c6:	df 93       	push	r29
    57c8:	cf 93       	push	r28
    57ca:	00 d0       	rcall	.+0      	; 0x57cc <task1+0x6>
    57cc:	cd b7       	in	r28, 0x3d	; 61
    57ce:	de b7       	in	r29, 0x3e	; 62
    57d0:	9a 83       	std	Y+2, r25	; 0x02
    57d2:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		DIO_VidTogglePin(PORT_A,PIN_0);
    57d4:	80 e0       	ldi	r24, 0x00	; 0
    57d6:	60 e0       	ldi	r22, 0x00	; 0
    57d8:	0e 94 c4 0c 	call	0x1988	; 0x1988 <DIO_VidTogglePin>
		vTaskDelay(150);
    57dc:	86 e9       	ldi	r24, 0x96	; 150
    57de:	90 e0       	ldi	r25, 0x00	; 0
    57e0:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <vTaskDelay>
    57e4:	f7 cf       	rjmp	.-18     	; 0x57d4 <task1+0xe>

000057e6 <task2>:
	}
}
void task2(void *pvparameters)
{
    57e6:	df 93       	push	r29
    57e8:	cf 93       	push	r28
    57ea:	00 d0       	rcall	.+0      	; 0x57ec <task2+0x6>
    57ec:	cd b7       	in	r28, 0x3d	; 61
    57ee:	de b7       	in	r29, 0x3e	; 62
    57f0:	9a 83       	std	Y+2, r25	; 0x02
    57f2:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		DIO_VidTogglePin(PORT_A,PIN_1);
    57f4:	80 e0       	ldi	r24, 0x00	; 0
    57f6:	61 e0       	ldi	r22, 0x01	; 1
    57f8:	0e 94 c4 0c 	call	0x1988	; 0x1988 <DIO_VidTogglePin>
		vTaskDelay(300);
    57fc:	8c e2       	ldi	r24, 0x2C	; 44
    57fe:	91 e0       	ldi	r25, 0x01	; 1
    5800:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <vTaskDelay>
    5804:	f7 cf       	rjmp	.-18     	; 0x57f4 <task2+0xe>

00005806 <task3>:
	}
}
void task3(void *pvparameters)
{
    5806:	df 93       	push	r29
    5808:	cf 93       	push	r28
    580a:	00 d0       	rcall	.+0      	; 0x580c <task3+0x6>
    580c:	cd b7       	in	r28, 0x3d	; 61
    580e:	de b7       	in	r29, 0x3e	; 62
    5810:	9a 83       	std	Y+2, r25	; 0x02
    5812:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		DIO_VidTogglePin(PORT_A,PIN_2);
    5814:	80 e0       	ldi	r24, 0x00	; 0
    5816:	62 e0       	ldi	r22, 0x02	; 2
    5818:	0e 94 c4 0c 	call	0x1988	; 0x1988 <DIO_VidTogglePin>
		vTaskDelay(500);
    581c:	84 ef       	ldi	r24, 0xF4	; 244
    581e:	91 e0       	ldi	r25, 0x01	; 1
    5820:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <vTaskDelay>
    5824:	f7 cf       	rjmp	.-18     	; 0x5814 <task3+0xe>

00005826 <task4>:
	}
}
void task4(void *pvparameters)
{
    5826:	df 93       	push	r29
    5828:	cf 93       	push	r28
    582a:	00 d0       	rcall	.+0      	; 0x582c <task4+0x6>
    582c:	cd b7       	in	r28, 0x3d	; 61
    582e:	de b7       	in	r29, 0x3e	; 62
    5830:	9a 83       	std	Y+2, r25	; 0x02
    5832:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		DIO_VidTogglePin(PORT_A,PIN_3);
    5834:	80 e0       	ldi	r24, 0x00	; 0
    5836:	63 e0       	ldi	r22, 0x03	; 3
    5838:	0e 94 c4 0c 	call	0x1988	; 0x1988 <DIO_VidTogglePin>
		vTaskDelay(1000);
    583c:	88 ee       	ldi	r24, 0xE8	; 232
    583e:	93 e0       	ldi	r25, 0x03	; 3
    5840:	0e 94 4b 26 	call	0x4c96	; 0x4c96 <vTaskDelay>
    5844:	f7 cf       	rjmp	.-18     	; 0x5834 <task4+0xe>

00005846 <__divmodhi4>:
    5846:	97 fb       	bst	r25, 7
    5848:	09 2e       	mov	r0, r25
    584a:	07 26       	eor	r0, r23
    584c:	0a d0       	rcall	.+20     	; 0x5862 <__divmodhi4_neg1>
    584e:	77 fd       	sbrc	r23, 7
    5850:	04 d0       	rcall	.+8      	; 0x585a <__divmodhi4_neg2>
    5852:	0c d0       	rcall	.+24     	; 0x586c <__udivmodhi4>
    5854:	06 d0       	rcall	.+12     	; 0x5862 <__divmodhi4_neg1>
    5856:	00 20       	and	r0, r0
    5858:	1a f4       	brpl	.+6      	; 0x5860 <__divmodhi4_exit>

0000585a <__divmodhi4_neg2>:
    585a:	70 95       	com	r23
    585c:	61 95       	neg	r22
    585e:	7f 4f       	sbci	r23, 0xFF	; 255

00005860 <__divmodhi4_exit>:
    5860:	08 95       	ret

00005862 <__divmodhi4_neg1>:
    5862:	f6 f7       	brtc	.-4      	; 0x5860 <__divmodhi4_exit>
    5864:	90 95       	com	r25
    5866:	81 95       	neg	r24
    5868:	9f 4f       	sbci	r25, 0xFF	; 255
    586a:	08 95       	ret

0000586c <__udivmodhi4>:
    586c:	aa 1b       	sub	r26, r26
    586e:	bb 1b       	sub	r27, r27
    5870:	51 e1       	ldi	r21, 0x11	; 17
    5872:	07 c0       	rjmp	.+14     	; 0x5882 <__udivmodhi4_ep>

00005874 <__udivmodhi4_loop>:
    5874:	aa 1f       	adc	r26, r26
    5876:	bb 1f       	adc	r27, r27
    5878:	a6 17       	cp	r26, r22
    587a:	b7 07       	cpc	r27, r23
    587c:	10 f0       	brcs	.+4      	; 0x5882 <__udivmodhi4_ep>
    587e:	a6 1b       	sub	r26, r22
    5880:	b7 0b       	sbc	r27, r23

00005882 <__udivmodhi4_ep>:
    5882:	88 1f       	adc	r24, r24
    5884:	99 1f       	adc	r25, r25
    5886:	5a 95       	dec	r21
    5888:	a9 f7       	brne	.-22     	; 0x5874 <__udivmodhi4_loop>
    588a:	80 95       	com	r24
    588c:	90 95       	com	r25
    588e:	bc 01       	movw	r22, r24
    5890:	cd 01       	movw	r24, r26
    5892:	08 95       	ret

00005894 <__prologue_saves__>:
    5894:	2f 92       	push	r2
    5896:	3f 92       	push	r3
    5898:	4f 92       	push	r4
    589a:	5f 92       	push	r5
    589c:	6f 92       	push	r6
    589e:	7f 92       	push	r7
    58a0:	8f 92       	push	r8
    58a2:	9f 92       	push	r9
    58a4:	af 92       	push	r10
    58a6:	bf 92       	push	r11
    58a8:	cf 92       	push	r12
    58aa:	df 92       	push	r13
    58ac:	ef 92       	push	r14
    58ae:	ff 92       	push	r15
    58b0:	0f 93       	push	r16
    58b2:	1f 93       	push	r17
    58b4:	cf 93       	push	r28
    58b6:	df 93       	push	r29
    58b8:	cd b7       	in	r28, 0x3d	; 61
    58ba:	de b7       	in	r29, 0x3e	; 62
    58bc:	ca 1b       	sub	r28, r26
    58be:	db 0b       	sbc	r29, r27
    58c0:	0f b6       	in	r0, 0x3f	; 63
    58c2:	f8 94       	cli
    58c4:	de bf       	out	0x3e, r29	; 62
    58c6:	0f be       	out	0x3f, r0	; 63
    58c8:	cd bf       	out	0x3d, r28	; 61
    58ca:	09 94       	ijmp

000058cc <__epilogue_restores__>:
    58cc:	2a 88       	ldd	r2, Y+18	; 0x12
    58ce:	39 88       	ldd	r3, Y+17	; 0x11
    58d0:	48 88       	ldd	r4, Y+16	; 0x10
    58d2:	5f 84       	ldd	r5, Y+15	; 0x0f
    58d4:	6e 84       	ldd	r6, Y+14	; 0x0e
    58d6:	7d 84       	ldd	r7, Y+13	; 0x0d
    58d8:	8c 84       	ldd	r8, Y+12	; 0x0c
    58da:	9b 84       	ldd	r9, Y+11	; 0x0b
    58dc:	aa 84       	ldd	r10, Y+10	; 0x0a
    58de:	b9 84       	ldd	r11, Y+9	; 0x09
    58e0:	c8 84       	ldd	r12, Y+8	; 0x08
    58e2:	df 80       	ldd	r13, Y+7	; 0x07
    58e4:	ee 80       	ldd	r14, Y+6	; 0x06
    58e6:	fd 80       	ldd	r15, Y+5	; 0x05
    58e8:	0c 81       	ldd	r16, Y+4	; 0x04
    58ea:	1b 81       	ldd	r17, Y+3	; 0x03
    58ec:	aa 81       	ldd	r26, Y+2	; 0x02
    58ee:	b9 81       	ldd	r27, Y+1	; 0x01
    58f0:	ce 0f       	add	r28, r30
    58f2:	d1 1d       	adc	r29, r1
    58f4:	0f b6       	in	r0, 0x3f	; 63
    58f6:	f8 94       	cli
    58f8:	de bf       	out	0x3e, r29	; 62
    58fa:	0f be       	out	0x3f, r0	; 63
    58fc:	cd bf       	out	0x3d, r28	; 61
    58fe:	ed 01       	movw	r28, r26
    5900:	08 95       	ret

00005902 <memcpy>:
    5902:	fb 01       	movw	r30, r22
    5904:	dc 01       	movw	r26, r24
    5906:	02 c0       	rjmp	.+4      	; 0x590c <memcpy+0xa>
    5908:	01 90       	ld	r0, Z+
    590a:	0d 92       	st	X+, r0
    590c:	41 50       	subi	r20, 0x01	; 1
    590e:	50 40       	sbci	r21, 0x00	; 0
    5910:	d8 f7       	brcc	.-10     	; 0x5908 <memcpy+0x6>
    5912:	08 95       	ret

00005914 <memset>:
    5914:	dc 01       	movw	r26, r24
    5916:	01 c0       	rjmp	.+2      	; 0x591a <memset+0x6>
    5918:	6d 93       	st	X+, r22
    591a:	41 50       	subi	r20, 0x01	; 1
    591c:	50 40       	sbci	r21, 0x00	; 0
    591e:	e0 f7       	brcc	.-8      	; 0x5918 <memset+0x4>
    5920:	08 95       	ret

00005922 <strncpy>:
    5922:	fb 01       	movw	r30, r22
    5924:	dc 01       	movw	r26, r24
    5926:	41 50       	subi	r20, 0x01	; 1
    5928:	50 40       	sbci	r21, 0x00	; 0
    592a:	48 f0       	brcs	.+18     	; 0x593e <strncpy+0x1c>
    592c:	01 90       	ld	r0, Z+
    592e:	0d 92       	st	X+, r0
    5930:	00 20       	and	r0, r0
    5932:	c9 f7       	brne	.-14     	; 0x5926 <strncpy+0x4>
    5934:	01 c0       	rjmp	.+2      	; 0x5938 <strncpy+0x16>
    5936:	1d 92       	st	X+, r1
    5938:	41 50       	subi	r20, 0x01	; 1
    593a:	50 40       	sbci	r21, 0x00	; 0
    593c:	e0 f7       	brcc	.-8      	; 0x5936 <strncpy+0x14>
    593e:	08 95       	ret

00005940 <sprintf>:
    5940:	ae e0       	ldi	r26, 0x0E	; 14
    5942:	b0 e0       	ldi	r27, 0x00	; 0
    5944:	e6 ea       	ldi	r30, 0xA6	; 166
    5946:	fc e2       	ldi	r31, 0x2C	; 44
    5948:	0c 94 58 2c 	jmp	0x58b0	; 0x58b0 <__prologue_saves__+0x1c>
    594c:	0d 89       	ldd	r16, Y+21	; 0x15
    594e:	1e 89       	ldd	r17, Y+22	; 0x16
    5950:	86 e0       	ldi	r24, 0x06	; 6
    5952:	8c 83       	std	Y+4, r24	; 0x04
    5954:	1a 83       	std	Y+2, r17	; 0x02
    5956:	09 83       	std	Y+1, r16	; 0x01
    5958:	8f ef       	ldi	r24, 0xFF	; 255
    595a:	9f e7       	ldi	r25, 0x7F	; 127
    595c:	9e 83       	std	Y+6, r25	; 0x06
    595e:	8d 83       	std	Y+5, r24	; 0x05
    5960:	9e 01       	movw	r18, r28
    5962:	27 5e       	subi	r18, 0xE7	; 231
    5964:	3f 4f       	sbci	r19, 0xFF	; 255
    5966:	ce 01       	movw	r24, r28
    5968:	01 96       	adiw	r24, 0x01	; 1
    596a:	6f 89       	ldd	r22, Y+23	; 0x17
    596c:	78 8d       	ldd	r23, Y+24	; 0x18
    596e:	a9 01       	movw	r20, r18
    5970:	0e 94 c4 2c 	call	0x5988	; 0x5988 <vfprintf>
    5974:	2f 81       	ldd	r18, Y+7	; 0x07
    5976:	38 85       	ldd	r19, Y+8	; 0x08
    5978:	02 0f       	add	r16, r18
    597a:	13 1f       	adc	r17, r19
    597c:	f8 01       	movw	r30, r16
    597e:	10 82       	st	Z, r1
    5980:	2e 96       	adiw	r28, 0x0e	; 14
    5982:	e4 e0       	ldi	r30, 0x04	; 4
    5984:	0c 94 74 2c 	jmp	0x58e8	; 0x58e8 <__epilogue_restores__+0x1c>

00005988 <vfprintf>:
    5988:	ab e0       	ldi	r26, 0x0B	; 11
    598a:	b0 e0       	ldi	r27, 0x00	; 0
    598c:	ea ec       	ldi	r30, 0xCA	; 202
    598e:	fc e2       	ldi	r31, 0x2C	; 44
    5990:	0c 94 4a 2c 	jmp	0x5894	; 0x5894 <__prologue_saves__>
    5994:	3c 01       	movw	r6, r24
    5996:	2b 01       	movw	r4, r22
    5998:	5a 01       	movw	r10, r20
    599a:	fc 01       	movw	r30, r24
    599c:	17 82       	std	Z+7, r1	; 0x07
    599e:	16 82       	std	Z+6, r1	; 0x06
    59a0:	83 81       	ldd	r24, Z+3	; 0x03
    59a2:	81 fd       	sbrc	r24, 1
    59a4:	03 c0       	rjmp	.+6      	; 0x59ac <vfprintf+0x24>
    59a6:	6f ef       	ldi	r22, 0xFF	; 255
    59a8:	7f ef       	ldi	r23, 0xFF	; 255
    59aa:	c6 c1       	rjmp	.+908    	; 0x5d38 <vfprintf+0x3b0>
    59ac:	9a e0       	ldi	r25, 0x0A	; 10
    59ae:	89 2e       	mov	r8, r25
    59b0:	1e 01       	movw	r2, r28
    59b2:	08 94       	sec
    59b4:	21 1c       	adc	r2, r1
    59b6:	31 1c       	adc	r3, r1
    59b8:	f3 01       	movw	r30, r6
    59ba:	23 81       	ldd	r18, Z+3	; 0x03
    59bc:	f2 01       	movw	r30, r4
    59be:	23 fd       	sbrc	r18, 3
    59c0:	85 91       	lpm	r24, Z+
    59c2:	23 ff       	sbrs	r18, 3
    59c4:	81 91       	ld	r24, Z+
    59c6:	2f 01       	movw	r4, r30
    59c8:	88 23       	and	r24, r24
    59ca:	09 f4       	brne	.+2      	; 0x59ce <vfprintf+0x46>
    59cc:	b2 c1       	rjmp	.+868    	; 0x5d32 <vfprintf+0x3aa>
    59ce:	85 32       	cpi	r24, 0x25	; 37
    59d0:	39 f4       	brne	.+14     	; 0x59e0 <vfprintf+0x58>
    59d2:	23 fd       	sbrc	r18, 3
    59d4:	85 91       	lpm	r24, Z+
    59d6:	23 ff       	sbrs	r18, 3
    59d8:	81 91       	ld	r24, Z+
    59da:	2f 01       	movw	r4, r30
    59dc:	85 32       	cpi	r24, 0x25	; 37
    59de:	29 f4       	brne	.+10     	; 0x59ea <vfprintf+0x62>
    59e0:	90 e0       	ldi	r25, 0x00	; 0
    59e2:	b3 01       	movw	r22, r6
    59e4:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <fputc>
    59e8:	e7 cf       	rjmp	.-50     	; 0x59b8 <vfprintf+0x30>
    59ea:	98 2f       	mov	r25, r24
    59ec:	ff 24       	eor	r15, r15
    59ee:	ee 24       	eor	r14, r14
    59f0:	99 24       	eor	r9, r9
    59f2:	ff e1       	ldi	r31, 0x1F	; 31
    59f4:	ff 15       	cp	r31, r15
    59f6:	d0 f0       	brcs	.+52     	; 0x5a2c <vfprintf+0xa4>
    59f8:	9b 32       	cpi	r25, 0x2B	; 43
    59fa:	69 f0       	breq	.+26     	; 0x5a16 <vfprintf+0x8e>
    59fc:	9c 32       	cpi	r25, 0x2C	; 44
    59fe:	28 f4       	brcc	.+10     	; 0x5a0a <vfprintf+0x82>
    5a00:	90 32       	cpi	r25, 0x20	; 32
    5a02:	59 f0       	breq	.+22     	; 0x5a1a <vfprintf+0x92>
    5a04:	93 32       	cpi	r25, 0x23	; 35
    5a06:	91 f4       	brne	.+36     	; 0x5a2c <vfprintf+0xa4>
    5a08:	0e c0       	rjmp	.+28     	; 0x5a26 <vfprintf+0x9e>
    5a0a:	9d 32       	cpi	r25, 0x2D	; 45
    5a0c:	49 f0       	breq	.+18     	; 0x5a20 <vfprintf+0x98>
    5a0e:	90 33       	cpi	r25, 0x30	; 48
    5a10:	69 f4       	brne	.+26     	; 0x5a2c <vfprintf+0xa4>
    5a12:	41 e0       	ldi	r20, 0x01	; 1
    5a14:	24 c0       	rjmp	.+72     	; 0x5a5e <vfprintf+0xd6>
    5a16:	52 e0       	ldi	r21, 0x02	; 2
    5a18:	f5 2a       	or	r15, r21
    5a1a:	84 e0       	ldi	r24, 0x04	; 4
    5a1c:	f8 2a       	or	r15, r24
    5a1e:	28 c0       	rjmp	.+80     	; 0x5a70 <vfprintf+0xe8>
    5a20:	98 e0       	ldi	r25, 0x08	; 8
    5a22:	f9 2a       	or	r15, r25
    5a24:	25 c0       	rjmp	.+74     	; 0x5a70 <vfprintf+0xe8>
    5a26:	e0 e1       	ldi	r30, 0x10	; 16
    5a28:	fe 2a       	or	r15, r30
    5a2a:	22 c0       	rjmp	.+68     	; 0x5a70 <vfprintf+0xe8>
    5a2c:	f7 fc       	sbrc	r15, 7
    5a2e:	29 c0       	rjmp	.+82     	; 0x5a82 <vfprintf+0xfa>
    5a30:	89 2f       	mov	r24, r25
    5a32:	80 53       	subi	r24, 0x30	; 48
    5a34:	8a 30       	cpi	r24, 0x0A	; 10
    5a36:	70 f4       	brcc	.+28     	; 0x5a54 <vfprintf+0xcc>
    5a38:	f6 fe       	sbrs	r15, 6
    5a3a:	05 c0       	rjmp	.+10     	; 0x5a46 <vfprintf+0xbe>
    5a3c:	98 9c       	mul	r9, r8
    5a3e:	90 2c       	mov	r9, r0
    5a40:	11 24       	eor	r1, r1
    5a42:	98 0e       	add	r9, r24
    5a44:	15 c0       	rjmp	.+42     	; 0x5a70 <vfprintf+0xe8>
    5a46:	e8 9c       	mul	r14, r8
    5a48:	e0 2c       	mov	r14, r0
    5a4a:	11 24       	eor	r1, r1
    5a4c:	e8 0e       	add	r14, r24
    5a4e:	f0 e2       	ldi	r31, 0x20	; 32
    5a50:	ff 2a       	or	r15, r31
    5a52:	0e c0       	rjmp	.+28     	; 0x5a70 <vfprintf+0xe8>
    5a54:	9e 32       	cpi	r25, 0x2E	; 46
    5a56:	29 f4       	brne	.+10     	; 0x5a62 <vfprintf+0xda>
    5a58:	f6 fc       	sbrc	r15, 6
    5a5a:	6b c1       	rjmp	.+726    	; 0x5d32 <vfprintf+0x3aa>
    5a5c:	40 e4       	ldi	r20, 0x40	; 64
    5a5e:	f4 2a       	or	r15, r20
    5a60:	07 c0       	rjmp	.+14     	; 0x5a70 <vfprintf+0xe8>
    5a62:	9c 36       	cpi	r25, 0x6C	; 108
    5a64:	19 f4       	brne	.+6      	; 0x5a6c <vfprintf+0xe4>
    5a66:	50 e8       	ldi	r21, 0x80	; 128
    5a68:	f5 2a       	or	r15, r21
    5a6a:	02 c0       	rjmp	.+4      	; 0x5a70 <vfprintf+0xe8>
    5a6c:	98 36       	cpi	r25, 0x68	; 104
    5a6e:	49 f4       	brne	.+18     	; 0x5a82 <vfprintf+0xfa>
    5a70:	f2 01       	movw	r30, r4
    5a72:	23 fd       	sbrc	r18, 3
    5a74:	95 91       	lpm	r25, Z+
    5a76:	23 ff       	sbrs	r18, 3
    5a78:	91 91       	ld	r25, Z+
    5a7a:	2f 01       	movw	r4, r30
    5a7c:	99 23       	and	r25, r25
    5a7e:	09 f0       	breq	.+2      	; 0x5a82 <vfprintf+0xfa>
    5a80:	b8 cf       	rjmp	.-144    	; 0x59f2 <vfprintf+0x6a>
    5a82:	89 2f       	mov	r24, r25
    5a84:	85 54       	subi	r24, 0x45	; 69
    5a86:	83 30       	cpi	r24, 0x03	; 3
    5a88:	18 f0       	brcs	.+6      	; 0x5a90 <vfprintf+0x108>
    5a8a:	80 52       	subi	r24, 0x20	; 32
    5a8c:	83 30       	cpi	r24, 0x03	; 3
    5a8e:	38 f4       	brcc	.+14     	; 0x5a9e <vfprintf+0x116>
    5a90:	44 e0       	ldi	r20, 0x04	; 4
    5a92:	50 e0       	ldi	r21, 0x00	; 0
    5a94:	a4 0e       	add	r10, r20
    5a96:	b5 1e       	adc	r11, r21
    5a98:	5f e3       	ldi	r21, 0x3F	; 63
    5a9a:	59 83       	std	Y+1, r21	; 0x01
    5a9c:	0f c0       	rjmp	.+30     	; 0x5abc <vfprintf+0x134>
    5a9e:	93 36       	cpi	r25, 0x63	; 99
    5aa0:	31 f0       	breq	.+12     	; 0x5aae <vfprintf+0x126>
    5aa2:	93 37       	cpi	r25, 0x73	; 115
    5aa4:	79 f0       	breq	.+30     	; 0x5ac4 <vfprintf+0x13c>
    5aa6:	93 35       	cpi	r25, 0x53	; 83
    5aa8:	09 f0       	breq	.+2      	; 0x5aac <vfprintf+0x124>
    5aaa:	56 c0       	rjmp	.+172    	; 0x5b58 <vfprintf+0x1d0>
    5aac:	20 c0       	rjmp	.+64     	; 0x5aee <vfprintf+0x166>
    5aae:	f5 01       	movw	r30, r10
    5ab0:	80 81       	ld	r24, Z
    5ab2:	89 83       	std	Y+1, r24	; 0x01
    5ab4:	42 e0       	ldi	r20, 0x02	; 2
    5ab6:	50 e0       	ldi	r21, 0x00	; 0
    5ab8:	a4 0e       	add	r10, r20
    5aba:	b5 1e       	adc	r11, r21
    5abc:	61 01       	movw	r12, r2
    5abe:	01 e0       	ldi	r16, 0x01	; 1
    5ac0:	10 e0       	ldi	r17, 0x00	; 0
    5ac2:	12 c0       	rjmp	.+36     	; 0x5ae8 <vfprintf+0x160>
    5ac4:	f5 01       	movw	r30, r10
    5ac6:	c0 80       	ld	r12, Z
    5ac8:	d1 80       	ldd	r13, Z+1	; 0x01
    5aca:	f6 fc       	sbrc	r15, 6
    5acc:	03 c0       	rjmp	.+6      	; 0x5ad4 <vfprintf+0x14c>
    5ace:	6f ef       	ldi	r22, 0xFF	; 255
    5ad0:	7f ef       	ldi	r23, 0xFF	; 255
    5ad2:	02 c0       	rjmp	.+4      	; 0x5ad8 <vfprintf+0x150>
    5ad4:	69 2d       	mov	r22, r9
    5ad6:	70 e0       	ldi	r23, 0x00	; 0
    5ad8:	42 e0       	ldi	r20, 0x02	; 2
    5ada:	50 e0       	ldi	r21, 0x00	; 0
    5adc:	a4 0e       	add	r10, r20
    5ade:	b5 1e       	adc	r11, r21
    5ae0:	c6 01       	movw	r24, r12
    5ae2:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <strnlen>
    5ae6:	8c 01       	movw	r16, r24
    5ae8:	5f e7       	ldi	r21, 0x7F	; 127
    5aea:	f5 22       	and	r15, r21
    5aec:	14 c0       	rjmp	.+40     	; 0x5b16 <vfprintf+0x18e>
    5aee:	f5 01       	movw	r30, r10
    5af0:	c0 80       	ld	r12, Z
    5af2:	d1 80       	ldd	r13, Z+1	; 0x01
    5af4:	f6 fc       	sbrc	r15, 6
    5af6:	03 c0       	rjmp	.+6      	; 0x5afe <vfprintf+0x176>
    5af8:	6f ef       	ldi	r22, 0xFF	; 255
    5afa:	7f ef       	ldi	r23, 0xFF	; 255
    5afc:	02 c0       	rjmp	.+4      	; 0x5b02 <vfprintf+0x17a>
    5afe:	69 2d       	mov	r22, r9
    5b00:	70 e0       	ldi	r23, 0x00	; 0
    5b02:	42 e0       	ldi	r20, 0x02	; 2
    5b04:	50 e0       	ldi	r21, 0x00	; 0
    5b06:	a4 0e       	add	r10, r20
    5b08:	b5 1e       	adc	r11, r21
    5b0a:	c6 01       	movw	r24, r12
    5b0c:	0e 94 a1 2e 	call	0x5d42	; 0x5d42 <strnlen_P>
    5b10:	8c 01       	movw	r16, r24
    5b12:	50 e8       	ldi	r21, 0x80	; 128
    5b14:	f5 2a       	or	r15, r21
    5b16:	f3 fe       	sbrs	r15, 3
    5b18:	07 c0       	rjmp	.+14     	; 0x5b28 <vfprintf+0x1a0>
    5b1a:	1a c0       	rjmp	.+52     	; 0x5b50 <vfprintf+0x1c8>
    5b1c:	80 e2       	ldi	r24, 0x20	; 32
    5b1e:	90 e0       	ldi	r25, 0x00	; 0
    5b20:	b3 01       	movw	r22, r6
    5b22:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <fputc>
    5b26:	ea 94       	dec	r14
    5b28:	8e 2d       	mov	r24, r14
    5b2a:	90 e0       	ldi	r25, 0x00	; 0
    5b2c:	08 17       	cp	r16, r24
    5b2e:	19 07       	cpc	r17, r25
    5b30:	a8 f3       	brcs	.-22     	; 0x5b1c <vfprintf+0x194>
    5b32:	0e c0       	rjmp	.+28     	; 0x5b50 <vfprintf+0x1c8>
    5b34:	f6 01       	movw	r30, r12
    5b36:	f7 fc       	sbrc	r15, 7
    5b38:	85 91       	lpm	r24, Z+
    5b3a:	f7 fe       	sbrs	r15, 7
    5b3c:	81 91       	ld	r24, Z+
    5b3e:	6f 01       	movw	r12, r30
    5b40:	90 e0       	ldi	r25, 0x00	; 0
    5b42:	b3 01       	movw	r22, r6
    5b44:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <fputc>
    5b48:	e1 10       	cpse	r14, r1
    5b4a:	ea 94       	dec	r14
    5b4c:	01 50       	subi	r16, 0x01	; 1
    5b4e:	10 40       	sbci	r17, 0x00	; 0
    5b50:	01 15       	cp	r16, r1
    5b52:	11 05       	cpc	r17, r1
    5b54:	79 f7       	brne	.-34     	; 0x5b34 <vfprintf+0x1ac>
    5b56:	ea c0       	rjmp	.+468    	; 0x5d2c <vfprintf+0x3a4>
    5b58:	94 36       	cpi	r25, 0x64	; 100
    5b5a:	11 f0       	breq	.+4      	; 0x5b60 <vfprintf+0x1d8>
    5b5c:	99 36       	cpi	r25, 0x69	; 105
    5b5e:	69 f5       	brne	.+90     	; 0x5bba <vfprintf+0x232>
    5b60:	f7 fe       	sbrs	r15, 7
    5b62:	08 c0       	rjmp	.+16     	; 0x5b74 <vfprintf+0x1ec>
    5b64:	f5 01       	movw	r30, r10
    5b66:	20 81       	ld	r18, Z
    5b68:	31 81       	ldd	r19, Z+1	; 0x01
    5b6a:	42 81       	ldd	r20, Z+2	; 0x02
    5b6c:	53 81       	ldd	r21, Z+3	; 0x03
    5b6e:	84 e0       	ldi	r24, 0x04	; 4
    5b70:	90 e0       	ldi	r25, 0x00	; 0
    5b72:	0a c0       	rjmp	.+20     	; 0x5b88 <vfprintf+0x200>
    5b74:	f5 01       	movw	r30, r10
    5b76:	80 81       	ld	r24, Z
    5b78:	91 81       	ldd	r25, Z+1	; 0x01
    5b7a:	9c 01       	movw	r18, r24
    5b7c:	44 27       	eor	r20, r20
    5b7e:	37 fd       	sbrc	r19, 7
    5b80:	40 95       	com	r20
    5b82:	54 2f       	mov	r21, r20
    5b84:	82 e0       	ldi	r24, 0x02	; 2
    5b86:	90 e0       	ldi	r25, 0x00	; 0
    5b88:	a8 0e       	add	r10, r24
    5b8a:	b9 1e       	adc	r11, r25
    5b8c:	9f e6       	ldi	r25, 0x6F	; 111
    5b8e:	f9 22       	and	r15, r25
    5b90:	57 ff       	sbrs	r21, 7
    5b92:	09 c0       	rjmp	.+18     	; 0x5ba6 <vfprintf+0x21e>
    5b94:	50 95       	com	r21
    5b96:	40 95       	com	r20
    5b98:	30 95       	com	r19
    5b9a:	21 95       	neg	r18
    5b9c:	3f 4f       	sbci	r19, 0xFF	; 255
    5b9e:	4f 4f       	sbci	r20, 0xFF	; 255
    5ba0:	5f 4f       	sbci	r21, 0xFF	; 255
    5ba2:	e0 e8       	ldi	r30, 0x80	; 128
    5ba4:	fe 2a       	or	r15, r30
    5ba6:	ca 01       	movw	r24, r20
    5ba8:	b9 01       	movw	r22, r18
    5baa:	a1 01       	movw	r20, r2
    5bac:	2a e0       	ldi	r18, 0x0A	; 10
    5bae:	30 e0       	ldi	r19, 0x00	; 0
    5bb0:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <__ultoa_invert>
    5bb4:	d8 2e       	mov	r13, r24
    5bb6:	d2 18       	sub	r13, r2
    5bb8:	40 c0       	rjmp	.+128    	; 0x5c3a <vfprintf+0x2b2>
    5bba:	95 37       	cpi	r25, 0x75	; 117
    5bbc:	29 f4       	brne	.+10     	; 0x5bc8 <vfprintf+0x240>
    5bbe:	1f 2d       	mov	r17, r15
    5bc0:	1f 7e       	andi	r17, 0xEF	; 239
    5bc2:	2a e0       	ldi	r18, 0x0A	; 10
    5bc4:	30 e0       	ldi	r19, 0x00	; 0
    5bc6:	1d c0       	rjmp	.+58     	; 0x5c02 <vfprintf+0x27a>
    5bc8:	1f 2d       	mov	r17, r15
    5bca:	19 7f       	andi	r17, 0xF9	; 249
    5bcc:	9f 36       	cpi	r25, 0x6F	; 111
    5bce:	61 f0       	breq	.+24     	; 0x5be8 <vfprintf+0x260>
    5bd0:	90 37       	cpi	r25, 0x70	; 112
    5bd2:	20 f4       	brcc	.+8      	; 0x5bdc <vfprintf+0x254>
    5bd4:	98 35       	cpi	r25, 0x58	; 88
    5bd6:	09 f0       	breq	.+2      	; 0x5bda <vfprintf+0x252>
    5bd8:	ac c0       	rjmp	.+344    	; 0x5d32 <vfprintf+0x3aa>
    5bda:	0f c0       	rjmp	.+30     	; 0x5bfa <vfprintf+0x272>
    5bdc:	90 37       	cpi	r25, 0x70	; 112
    5bde:	39 f0       	breq	.+14     	; 0x5bee <vfprintf+0x266>
    5be0:	98 37       	cpi	r25, 0x78	; 120
    5be2:	09 f0       	breq	.+2      	; 0x5be6 <vfprintf+0x25e>
    5be4:	a6 c0       	rjmp	.+332    	; 0x5d32 <vfprintf+0x3aa>
    5be6:	04 c0       	rjmp	.+8      	; 0x5bf0 <vfprintf+0x268>
    5be8:	28 e0       	ldi	r18, 0x08	; 8
    5bea:	30 e0       	ldi	r19, 0x00	; 0
    5bec:	0a c0       	rjmp	.+20     	; 0x5c02 <vfprintf+0x27a>
    5bee:	10 61       	ori	r17, 0x10	; 16
    5bf0:	14 fd       	sbrc	r17, 4
    5bf2:	14 60       	ori	r17, 0x04	; 4
    5bf4:	20 e1       	ldi	r18, 0x10	; 16
    5bf6:	30 e0       	ldi	r19, 0x00	; 0
    5bf8:	04 c0       	rjmp	.+8      	; 0x5c02 <vfprintf+0x27a>
    5bfa:	14 fd       	sbrc	r17, 4
    5bfc:	16 60       	ori	r17, 0x06	; 6
    5bfe:	20 e1       	ldi	r18, 0x10	; 16
    5c00:	32 e0       	ldi	r19, 0x02	; 2
    5c02:	17 ff       	sbrs	r17, 7
    5c04:	08 c0       	rjmp	.+16     	; 0x5c16 <vfprintf+0x28e>
    5c06:	f5 01       	movw	r30, r10
    5c08:	60 81       	ld	r22, Z
    5c0a:	71 81       	ldd	r23, Z+1	; 0x01
    5c0c:	82 81       	ldd	r24, Z+2	; 0x02
    5c0e:	93 81       	ldd	r25, Z+3	; 0x03
    5c10:	44 e0       	ldi	r20, 0x04	; 4
    5c12:	50 e0       	ldi	r21, 0x00	; 0
    5c14:	08 c0       	rjmp	.+16     	; 0x5c26 <vfprintf+0x29e>
    5c16:	f5 01       	movw	r30, r10
    5c18:	80 81       	ld	r24, Z
    5c1a:	91 81       	ldd	r25, Z+1	; 0x01
    5c1c:	bc 01       	movw	r22, r24
    5c1e:	80 e0       	ldi	r24, 0x00	; 0
    5c20:	90 e0       	ldi	r25, 0x00	; 0
    5c22:	42 e0       	ldi	r20, 0x02	; 2
    5c24:	50 e0       	ldi	r21, 0x00	; 0
    5c26:	a4 0e       	add	r10, r20
    5c28:	b5 1e       	adc	r11, r21
    5c2a:	a1 01       	movw	r20, r2
    5c2c:	0e 94 e3 2e 	call	0x5dc6	; 0x5dc6 <__ultoa_invert>
    5c30:	d8 2e       	mov	r13, r24
    5c32:	d2 18       	sub	r13, r2
    5c34:	8f e7       	ldi	r24, 0x7F	; 127
    5c36:	f8 2e       	mov	r15, r24
    5c38:	f1 22       	and	r15, r17
    5c3a:	f6 fe       	sbrs	r15, 6
    5c3c:	0b c0       	rjmp	.+22     	; 0x5c54 <vfprintf+0x2cc>
    5c3e:	5e ef       	ldi	r21, 0xFE	; 254
    5c40:	f5 22       	and	r15, r21
    5c42:	d9 14       	cp	r13, r9
    5c44:	38 f4       	brcc	.+14     	; 0x5c54 <vfprintf+0x2cc>
    5c46:	f4 fe       	sbrs	r15, 4
    5c48:	07 c0       	rjmp	.+14     	; 0x5c58 <vfprintf+0x2d0>
    5c4a:	f2 fc       	sbrc	r15, 2
    5c4c:	05 c0       	rjmp	.+10     	; 0x5c58 <vfprintf+0x2d0>
    5c4e:	8f ee       	ldi	r24, 0xEF	; 239
    5c50:	f8 22       	and	r15, r24
    5c52:	02 c0       	rjmp	.+4      	; 0x5c58 <vfprintf+0x2d0>
    5c54:	1d 2d       	mov	r17, r13
    5c56:	01 c0       	rjmp	.+2      	; 0x5c5a <vfprintf+0x2d2>
    5c58:	19 2d       	mov	r17, r9
    5c5a:	f4 fe       	sbrs	r15, 4
    5c5c:	0d c0       	rjmp	.+26     	; 0x5c78 <vfprintf+0x2f0>
    5c5e:	fe 01       	movw	r30, r28
    5c60:	ed 0d       	add	r30, r13
    5c62:	f1 1d       	adc	r31, r1
    5c64:	80 81       	ld	r24, Z
    5c66:	80 33       	cpi	r24, 0x30	; 48
    5c68:	19 f4       	brne	.+6      	; 0x5c70 <vfprintf+0x2e8>
    5c6a:	99 ee       	ldi	r25, 0xE9	; 233
    5c6c:	f9 22       	and	r15, r25
    5c6e:	08 c0       	rjmp	.+16     	; 0x5c80 <vfprintf+0x2f8>
    5c70:	1f 5f       	subi	r17, 0xFF	; 255
    5c72:	f2 fe       	sbrs	r15, 2
    5c74:	05 c0       	rjmp	.+10     	; 0x5c80 <vfprintf+0x2f8>
    5c76:	03 c0       	rjmp	.+6      	; 0x5c7e <vfprintf+0x2f6>
    5c78:	8f 2d       	mov	r24, r15
    5c7a:	86 78       	andi	r24, 0x86	; 134
    5c7c:	09 f0       	breq	.+2      	; 0x5c80 <vfprintf+0x2f8>
    5c7e:	1f 5f       	subi	r17, 0xFF	; 255
    5c80:	0f 2d       	mov	r16, r15
    5c82:	f3 fc       	sbrc	r15, 3
    5c84:	14 c0       	rjmp	.+40     	; 0x5cae <vfprintf+0x326>
    5c86:	f0 fe       	sbrs	r15, 0
    5c88:	0f c0       	rjmp	.+30     	; 0x5ca8 <vfprintf+0x320>
    5c8a:	1e 15       	cp	r17, r14
    5c8c:	10 f0       	brcs	.+4      	; 0x5c92 <vfprintf+0x30a>
    5c8e:	9d 2c       	mov	r9, r13
    5c90:	0b c0       	rjmp	.+22     	; 0x5ca8 <vfprintf+0x320>
    5c92:	9d 2c       	mov	r9, r13
    5c94:	9e 0c       	add	r9, r14
    5c96:	91 1a       	sub	r9, r17
    5c98:	1e 2d       	mov	r17, r14
    5c9a:	06 c0       	rjmp	.+12     	; 0x5ca8 <vfprintf+0x320>
    5c9c:	80 e2       	ldi	r24, 0x20	; 32
    5c9e:	90 e0       	ldi	r25, 0x00	; 0
    5ca0:	b3 01       	movw	r22, r6
    5ca2:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <fputc>
    5ca6:	1f 5f       	subi	r17, 0xFF	; 255
    5ca8:	1e 15       	cp	r17, r14
    5caa:	c0 f3       	brcs	.-16     	; 0x5c9c <vfprintf+0x314>
    5cac:	04 c0       	rjmp	.+8      	; 0x5cb6 <vfprintf+0x32e>
    5cae:	1e 15       	cp	r17, r14
    5cb0:	10 f4       	brcc	.+4      	; 0x5cb6 <vfprintf+0x32e>
    5cb2:	e1 1a       	sub	r14, r17
    5cb4:	01 c0       	rjmp	.+2      	; 0x5cb8 <vfprintf+0x330>
    5cb6:	ee 24       	eor	r14, r14
    5cb8:	04 ff       	sbrs	r16, 4
    5cba:	0f c0       	rjmp	.+30     	; 0x5cda <vfprintf+0x352>
    5cbc:	80 e3       	ldi	r24, 0x30	; 48
    5cbe:	90 e0       	ldi	r25, 0x00	; 0
    5cc0:	b3 01       	movw	r22, r6
    5cc2:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <fputc>
    5cc6:	02 ff       	sbrs	r16, 2
    5cc8:	1d c0       	rjmp	.+58     	; 0x5d04 <vfprintf+0x37c>
    5cca:	01 fd       	sbrc	r16, 1
    5ccc:	03 c0       	rjmp	.+6      	; 0x5cd4 <vfprintf+0x34c>
    5cce:	88 e7       	ldi	r24, 0x78	; 120
    5cd0:	90 e0       	ldi	r25, 0x00	; 0
    5cd2:	0e c0       	rjmp	.+28     	; 0x5cf0 <vfprintf+0x368>
    5cd4:	88 e5       	ldi	r24, 0x58	; 88
    5cd6:	90 e0       	ldi	r25, 0x00	; 0
    5cd8:	0b c0       	rjmp	.+22     	; 0x5cf0 <vfprintf+0x368>
    5cda:	80 2f       	mov	r24, r16
    5cdc:	86 78       	andi	r24, 0x86	; 134
    5cde:	91 f0       	breq	.+36     	; 0x5d04 <vfprintf+0x37c>
    5ce0:	01 ff       	sbrs	r16, 1
    5ce2:	02 c0       	rjmp	.+4      	; 0x5ce8 <vfprintf+0x360>
    5ce4:	8b e2       	ldi	r24, 0x2B	; 43
    5ce6:	01 c0       	rjmp	.+2      	; 0x5cea <vfprintf+0x362>
    5ce8:	80 e2       	ldi	r24, 0x20	; 32
    5cea:	f7 fc       	sbrc	r15, 7
    5cec:	8d e2       	ldi	r24, 0x2D	; 45
    5cee:	90 e0       	ldi	r25, 0x00	; 0
    5cf0:	b3 01       	movw	r22, r6
    5cf2:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <fputc>
    5cf6:	06 c0       	rjmp	.+12     	; 0x5d04 <vfprintf+0x37c>
    5cf8:	80 e3       	ldi	r24, 0x30	; 48
    5cfa:	90 e0       	ldi	r25, 0x00	; 0
    5cfc:	b3 01       	movw	r22, r6
    5cfe:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <fputc>
    5d02:	9a 94       	dec	r9
    5d04:	d9 14       	cp	r13, r9
    5d06:	c0 f3       	brcs	.-16     	; 0x5cf8 <vfprintf+0x370>
    5d08:	da 94       	dec	r13
    5d0a:	f1 01       	movw	r30, r2
    5d0c:	ed 0d       	add	r30, r13
    5d0e:	f1 1d       	adc	r31, r1
    5d10:	80 81       	ld	r24, Z
    5d12:	90 e0       	ldi	r25, 0x00	; 0
    5d14:	b3 01       	movw	r22, r6
    5d16:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <fputc>
    5d1a:	dd 20       	and	r13, r13
    5d1c:	a9 f7       	brne	.-22     	; 0x5d08 <vfprintf+0x380>
    5d1e:	06 c0       	rjmp	.+12     	; 0x5d2c <vfprintf+0x3a4>
    5d20:	80 e2       	ldi	r24, 0x20	; 32
    5d22:	90 e0       	ldi	r25, 0x00	; 0
    5d24:	b3 01       	movw	r22, r6
    5d26:	0e 94 b7 2e 	call	0x5d6e	; 0x5d6e <fputc>
    5d2a:	ea 94       	dec	r14
    5d2c:	ee 20       	and	r14, r14
    5d2e:	c1 f7       	brne	.-16     	; 0x5d20 <vfprintf+0x398>
    5d30:	43 ce       	rjmp	.-890    	; 0x59b8 <vfprintf+0x30>
    5d32:	f3 01       	movw	r30, r6
    5d34:	66 81       	ldd	r22, Z+6	; 0x06
    5d36:	77 81       	ldd	r23, Z+7	; 0x07
    5d38:	cb 01       	movw	r24, r22
    5d3a:	2b 96       	adiw	r28, 0x0b	; 11
    5d3c:	e2 e1       	ldi	r30, 0x12	; 18
    5d3e:	0c 94 66 2c 	jmp	0x58cc	; 0x58cc <__epilogue_restores__>

00005d42 <strnlen_P>:
    5d42:	fc 01       	movw	r30, r24
    5d44:	05 90       	lpm	r0, Z+
    5d46:	61 50       	subi	r22, 0x01	; 1
    5d48:	70 40       	sbci	r23, 0x00	; 0
    5d4a:	01 10       	cpse	r0, r1
    5d4c:	d8 f7       	brcc	.-10     	; 0x5d44 <strnlen_P+0x2>
    5d4e:	80 95       	com	r24
    5d50:	90 95       	com	r25
    5d52:	8e 0f       	add	r24, r30
    5d54:	9f 1f       	adc	r25, r31
    5d56:	08 95       	ret

00005d58 <strnlen>:
    5d58:	fc 01       	movw	r30, r24
    5d5a:	61 50       	subi	r22, 0x01	; 1
    5d5c:	70 40       	sbci	r23, 0x00	; 0
    5d5e:	01 90       	ld	r0, Z+
    5d60:	01 10       	cpse	r0, r1
    5d62:	d8 f7       	brcc	.-10     	; 0x5d5a <strnlen+0x2>
    5d64:	80 95       	com	r24
    5d66:	90 95       	com	r25
    5d68:	8e 0f       	add	r24, r30
    5d6a:	9f 1f       	adc	r25, r31
    5d6c:	08 95       	ret

00005d6e <fputc>:
    5d6e:	0f 93       	push	r16
    5d70:	1f 93       	push	r17
    5d72:	cf 93       	push	r28
    5d74:	df 93       	push	r29
    5d76:	8c 01       	movw	r16, r24
    5d78:	eb 01       	movw	r28, r22
    5d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    5d7c:	81 ff       	sbrs	r24, 1
    5d7e:	1b c0       	rjmp	.+54     	; 0x5db6 <fputc+0x48>
    5d80:	82 ff       	sbrs	r24, 2
    5d82:	0d c0       	rjmp	.+26     	; 0x5d9e <fputc+0x30>
    5d84:	2e 81       	ldd	r18, Y+6	; 0x06
    5d86:	3f 81       	ldd	r19, Y+7	; 0x07
    5d88:	8c 81       	ldd	r24, Y+4	; 0x04
    5d8a:	9d 81       	ldd	r25, Y+5	; 0x05
    5d8c:	28 17       	cp	r18, r24
    5d8e:	39 07       	cpc	r19, r25
    5d90:	64 f4       	brge	.+24     	; 0x5daa <fputc+0x3c>
    5d92:	e8 81       	ld	r30, Y
    5d94:	f9 81       	ldd	r31, Y+1	; 0x01
    5d96:	01 93       	st	Z+, r16
    5d98:	f9 83       	std	Y+1, r31	; 0x01
    5d9a:	e8 83       	st	Y, r30
    5d9c:	06 c0       	rjmp	.+12     	; 0x5daa <fputc+0x3c>
    5d9e:	e8 85       	ldd	r30, Y+8	; 0x08
    5da0:	f9 85       	ldd	r31, Y+9	; 0x09
    5da2:	80 2f       	mov	r24, r16
    5da4:	09 95       	icall
    5da6:	89 2b       	or	r24, r25
    5da8:	31 f4       	brne	.+12     	; 0x5db6 <fputc+0x48>
    5daa:	8e 81       	ldd	r24, Y+6	; 0x06
    5dac:	9f 81       	ldd	r25, Y+7	; 0x07
    5dae:	01 96       	adiw	r24, 0x01	; 1
    5db0:	9f 83       	std	Y+7, r25	; 0x07
    5db2:	8e 83       	std	Y+6, r24	; 0x06
    5db4:	02 c0       	rjmp	.+4      	; 0x5dba <fputc+0x4c>
    5db6:	0f ef       	ldi	r16, 0xFF	; 255
    5db8:	1f ef       	ldi	r17, 0xFF	; 255
    5dba:	c8 01       	movw	r24, r16
    5dbc:	df 91       	pop	r29
    5dbe:	cf 91       	pop	r28
    5dc0:	1f 91       	pop	r17
    5dc2:	0f 91       	pop	r16
    5dc4:	08 95       	ret

00005dc6 <__ultoa_invert>:
    5dc6:	fa 01       	movw	r30, r20
    5dc8:	aa 27       	eor	r26, r26
    5dca:	28 30       	cpi	r18, 0x08	; 8
    5dcc:	51 f1       	breq	.+84     	; 0x5e22 <__ultoa_invert+0x5c>
    5dce:	20 31       	cpi	r18, 0x10	; 16
    5dd0:	81 f1       	breq	.+96     	; 0x5e32 <__ultoa_invert+0x6c>
    5dd2:	e8 94       	clt
    5dd4:	6f 93       	push	r22
    5dd6:	6e 7f       	andi	r22, 0xFE	; 254
    5dd8:	6e 5f       	subi	r22, 0xFE	; 254
    5dda:	7f 4f       	sbci	r23, 0xFF	; 255
    5ddc:	8f 4f       	sbci	r24, 0xFF	; 255
    5dde:	9f 4f       	sbci	r25, 0xFF	; 255
    5de0:	af 4f       	sbci	r26, 0xFF	; 255
    5de2:	b1 e0       	ldi	r27, 0x01	; 1
    5de4:	3e d0       	rcall	.+124    	; 0x5e62 <__ultoa_invert+0x9c>
    5de6:	b4 e0       	ldi	r27, 0x04	; 4
    5de8:	3c d0       	rcall	.+120    	; 0x5e62 <__ultoa_invert+0x9c>
    5dea:	67 0f       	add	r22, r23
    5dec:	78 1f       	adc	r23, r24
    5dee:	89 1f       	adc	r24, r25
    5df0:	9a 1f       	adc	r25, r26
    5df2:	a1 1d       	adc	r26, r1
    5df4:	68 0f       	add	r22, r24
    5df6:	79 1f       	adc	r23, r25
    5df8:	8a 1f       	adc	r24, r26
    5dfa:	91 1d       	adc	r25, r1
    5dfc:	a1 1d       	adc	r26, r1
    5dfe:	6a 0f       	add	r22, r26
    5e00:	71 1d       	adc	r23, r1
    5e02:	81 1d       	adc	r24, r1
    5e04:	91 1d       	adc	r25, r1
    5e06:	a1 1d       	adc	r26, r1
    5e08:	20 d0       	rcall	.+64     	; 0x5e4a <__ultoa_invert+0x84>
    5e0a:	09 f4       	brne	.+2      	; 0x5e0e <__ultoa_invert+0x48>
    5e0c:	68 94       	set
    5e0e:	3f 91       	pop	r19
    5e10:	2a e0       	ldi	r18, 0x0A	; 10
    5e12:	26 9f       	mul	r18, r22
    5e14:	11 24       	eor	r1, r1
    5e16:	30 19       	sub	r19, r0
    5e18:	30 5d       	subi	r19, 0xD0	; 208
    5e1a:	31 93       	st	Z+, r19
    5e1c:	de f6       	brtc	.-74     	; 0x5dd4 <__ultoa_invert+0xe>
    5e1e:	cf 01       	movw	r24, r30
    5e20:	08 95       	ret
    5e22:	46 2f       	mov	r20, r22
    5e24:	47 70       	andi	r20, 0x07	; 7
    5e26:	40 5d       	subi	r20, 0xD0	; 208
    5e28:	41 93       	st	Z+, r20
    5e2a:	b3 e0       	ldi	r27, 0x03	; 3
    5e2c:	0f d0       	rcall	.+30     	; 0x5e4c <__ultoa_invert+0x86>
    5e2e:	c9 f7       	brne	.-14     	; 0x5e22 <__ultoa_invert+0x5c>
    5e30:	f6 cf       	rjmp	.-20     	; 0x5e1e <__ultoa_invert+0x58>
    5e32:	46 2f       	mov	r20, r22
    5e34:	4f 70       	andi	r20, 0x0F	; 15
    5e36:	40 5d       	subi	r20, 0xD0	; 208
    5e38:	4a 33       	cpi	r20, 0x3A	; 58
    5e3a:	18 f0       	brcs	.+6      	; 0x5e42 <__ultoa_invert+0x7c>
    5e3c:	49 5d       	subi	r20, 0xD9	; 217
    5e3e:	31 fd       	sbrc	r19, 1
    5e40:	40 52       	subi	r20, 0x20	; 32
    5e42:	41 93       	st	Z+, r20
    5e44:	02 d0       	rcall	.+4      	; 0x5e4a <__ultoa_invert+0x84>
    5e46:	a9 f7       	brne	.-22     	; 0x5e32 <__ultoa_invert+0x6c>
    5e48:	ea cf       	rjmp	.-44     	; 0x5e1e <__ultoa_invert+0x58>
    5e4a:	b4 e0       	ldi	r27, 0x04	; 4
    5e4c:	a6 95       	lsr	r26
    5e4e:	97 95       	ror	r25
    5e50:	87 95       	ror	r24
    5e52:	77 95       	ror	r23
    5e54:	67 95       	ror	r22
    5e56:	ba 95       	dec	r27
    5e58:	c9 f7       	brne	.-14     	; 0x5e4c <__ultoa_invert+0x86>
    5e5a:	00 97       	sbiw	r24, 0x00	; 0
    5e5c:	61 05       	cpc	r22, r1
    5e5e:	71 05       	cpc	r23, r1
    5e60:	08 95       	ret
    5e62:	9b 01       	movw	r18, r22
    5e64:	ac 01       	movw	r20, r24
    5e66:	0a 2e       	mov	r0, r26
    5e68:	06 94       	lsr	r0
    5e6a:	57 95       	ror	r21
    5e6c:	47 95       	ror	r20
    5e6e:	37 95       	ror	r19
    5e70:	27 95       	ror	r18
    5e72:	ba 95       	dec	r27
    5e74:	c9 f7       	brne	.-14     	; 0x5e68 <__ultoa_invert+0xa2>
    5e76:	62 0f       	add	r22, r18
    5e78:	73 1f       	adc	r23, r19
    5e7a:	84 1f       	adc	r24, r20
    5e7c:	95 1f       	adc	r25, r21
    5e7e:	a0 1d       	adc	r26, r0
    5e80:	08 95       	ret

00005e82 <_exit>:
    5e82:	f8 94       	cli

00005e84 <__stop_program>:
    5e84:	ff cf       	rjmp	.-2      	; 0x5e84 <__stop_program>
